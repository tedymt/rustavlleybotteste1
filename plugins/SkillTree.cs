using Facepunch;
using Facepunch.Utility;
using HarmonyLib;
using Mono.Cecil;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using Rust.Ai.Gen2;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml.Linq;
using UnityEngine;
using UnityEngine.Tilemaps;
using WebSocketSharp;


/* Ideas
 * Vehiclular combatant - more damage to vehicles (maybe including bradley and heli?)
 * Add heli as XP source.
 * Add CUI option to enable/disable components that are shredded by the shredder perk.
 * Add an XP cap for certain sources (quests, building etc).-
 * Colour the pump bar based on xp progression for the level
 * Possible buff for healing percentage when using medical deviucs with whitelist or blacklist
 * Add a dictionary to override the yield for certain ore types.
 * 
 * Fishing bait skill?
 * - Look at harmony patching GetFish method.
 * 
 * 
 * Crafting xp for tea stations
 * 
 * Shield stamina
 * Bee damage removal (see how hazmat handles it)
 * - DamageType Bee damage - Prevent it?
 * 
 * Look at making the shield block while on the players back.
 * 
 * Timers for ultimate cooldowns. Picture of the skill with a timer over it when active.
 * - Could look at having them inside of the skill tree menu when opened - Shows the time that the skill will be available again.
 * - Might be worth attaching to the background of the tree so it's always there.
 * 
 * Reload speeds
 * - Instant reload (IO) or tiered reload speeds (hooks reload animation and adds a timer to reload instead based on weapon type).
 * 
 * Loot detective
 * - A skill that is command based, that will show a player all nearby StorageContainers that are not empty. 
 * - Can lock to RaidableBases only
 * - Configurable time to display containers
 * - Increasing skill level increases range
 * - Cooldown time via config.
 */

/* 1.7.3
 * Added command: givexpdebt <target> <amount> - gives xp debt to the specified player.
 * Added config option to delete data for players who have not logged in for x amount of days.
 * Updated the tree UI to display nodes that require permissions to unlock rather than reinstantiating the playerData.
 * Fixed an issue with Wolf2 not working with xp event.
 * Fixed an NRE related to the RadiationProtection_Patch.
 * Removed the skin id/url option from config and made it so skills will prioritize skin id, will use url if skin value is 0, and will use a default png if both are invalid.
 * Patched for Feb forced wipe.
 * Fixed a rare bug in OnPlayerConnected that causes buffs to duplicate under very specific circumstances.
 */

namespace Oxide.Plugins
{
    [Info("Skill Tree", "imthenewguy", "1.7.3")]
    [Description("Skills on a tree!")]
    class SkillTree : RustPlugin
    {

        #region Config

        private Configuration config;
        public class Configuration
        {
            [JsonProperty("General settings")]
            public GeneralSettings general_settings = new GeneralSettings();

            public class GeneralSettings
            {
                [JsonProperty("Skill points per level")]
                public int points_per_level = 2;

                [JsonProperty("Modified skill points per level based on permissions [must be higher than default]")]
                public Dictionary<string, int> points_per_level_override = new Dictionary<string, int>();

                [JsonProperty("Maximum points a player can spend [default]")]
                public int max_skill_points = 200;

                [JsonProperty("Modified max skill points based on permissions [must be higher than default]")]
                public Dictionary<string, int> max_skill_points_override = new Dictionary<string, int>();

                [JsonProperty("Maximum level a player can get to")]
                public int max_player_level = 100;

                [JsonProperty("Settings for respecing skill points [Disabled, All, Tree]")]
                public RespecType respecType = RespecType.All;

                [JsonProperty("Cost per point to respec [default]")]
                public double respec_cost = 30;

                [JsonProperty("Cost per point to respec based on permissions [must be lower than default]")]
                public Dictionary<string, double> respec_cost_override = new Dictionary<string, double>();

                [JsonProperty("Respec cost cap [0 = no limit]")]
                public double respec_cost_cap = 0;

                [JsonProperty("Permission based level requirement override")]
                public Dictionary<string, PermOverride> level_requirement_override = new Dictionary<string, PermOverride>(StringComparer.InvariantCultureIgnoreCase);

                [JsonProperty("Permission based point requirement override")]
                public Dictionary<string, PermOverride> point_requirement_override = new Dictionary<string, PermOverride>(StringComparer.InvariantCultureIgnoreCase);

                [JsonProperty("Currency type to respec [scrap, economics, srp, shoppystock, custom]")]
                public string respec_currency = "scrap";

                [JsonProperty("ShoppyStock currency info [if currency type is set to shoppystock]")]
                public ShoppyStockInfo shoppyStockInfo = new ShoppyStockInfo();
                public class ShoppyStockInfo
                {
                    [JsonProperty("Shop name")]
                    public string shopName;
                }

                [JsonProperty("If currency is set to custom, what are the details of the item")]
                public CustomCurrency respec_currency_custom = new CustomCurrency();

                [JsonProperty("Multiplier increase after each respec [0.2 = a 20% increase in the cost to respec each time. 0 = no increase] [resets on wipe or data reset]")]
                public float respec_multiplier = 0;

                [JsonProperty("Maximum value that the respec multiplier can get to [0 = no limit]")]
                public float respec_multiplier_max = 0;

                [JsonProperty("List of rewards the player receives based on level")]
                public Dictionary<int, LevelReward> level_rewards = new Dictionary<int, LevelReward>();

                [JsonProperty("Require players to have specific tree permissions to open them")]
                public bool require_tree_perms = false;

                [JsonProperty("Show the quick navigation buttons to the player")]
                public bool show_navigation_buttons = true;

                [JsonProperty("Drop bag on death")]
                public bool drop_bag_on_death = true;

                [JsonProperty("XP pump bar settings")]
                public PumpBar pump_bar_settings = new PumpBar();
                
                [JsonProperty("Redownload all images when the plugin reloads if using URL?")]
                public bool replace_on_reload = false;

                [JsonProperty("Use skin id for extra pockets icon? [true = skin, false = url]")]
                public bool useSkinForExtraPockets = true;

            }

            [JsonProperty("Base yield settings")]
            public BaseYieldSettings base_yield_settings = new BaseYieldSettings();

            public class BaseYieldSettings
            {
                [JsonProperty("Allow Skill Tree to adjust the base amount of resource received? Buffs will base their modifiers off of the amended base amount.")]
                public bool adjust_base_yield = false;

                [JsonProperty("Yield types multipliers [1.0 = vanilla]")]
                public Dictionary<YieldTypes, float> multipliers = new Dictionary<YieldTypes, float>();
            }

            [JsonProperty("Buff settings")]
            public BuffSettings buff_settings = new BuffSettings();

            public class BuffSettings
            {
                [JsonProperty("Should we remove permissions from permission buffs when the player disconnects from the server or the plugin unloads? [Recommended]")]
                public bool removePermissionsOnDisconnect = true;

                [JsonProperty("Should yield bonus skills be additive [if true, yields will modify the item.amount value, rather than giving additional items]")]
                public bool additiveYields = true;

                [JsonProperty("Minimum components for the component perk")]
                public int min_components = 1;

                [JsonProperty("Maximum components for the component perk")]
                public int max_components = 1;

                [JsonProperty("Minimum electrical components for the electrical component perk")]
                public int min_electrical_components = 1;

                [JsonProperty("Maximum electrical components for the electrical component perk")]
                public int max_electrical_components = 1;

                [JsonProperty("Minimum additional scrap to be added to crates and barrels")]
                public int min_extra_scrap = 1;

                [JsonProperty("Maximum additional scrap to be added to crates and barrels")]
                public int max_extra_scrap = 2;

                [JsonProperty("PVP Buff Critical damage modifier. Picks a random value between 0 and the declared value, and += the damage% onto the hit")]
                public float pvp_critical_modifier = 0.3f;

                [JsonProperty("Should the LootPickup buff only work with melee weapons?")]
                public bool lootPickupBuffMeleeOnly = false;

                [JsonProperty("Should we have a maximum distance for the loot pickup buff [0 = unlimited]?")]
                public float loot_pickup_buff_max_distance = 0;

                [JsonProperty("Allow the LootPickup buff to work with road-side signs?")]
                public bool allow_roadsigns_magnet = false;

                [JsonProperty("Allow the Barrel Smasher buff to work with road-side signs?")]
                public bool allow_roadsigns_smasher = false;

                [JsonProperty("List of animals for animal resist ability", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public HashSet<string> animals = new HashSet<string>();

                [JsonProperty("Delay for HealthRegen perk after taking damage")]
                public float health_regen_combat_delay = 5f;

                [JsonProperty("Delay between attempts at tracking animals")]
                public float track_delay = 10f;

                [JsonProperty("List of skins that the rationer perk will not refund")]
                public HashSet<ulong> no_refund_item_skins = new HashSet<ulong>();

                [JsonProperty("Bag cooldown time")]
                public float bag_cooldown_time = 10f;

                [JsonProperty("Bag prefab")]
                public string bag_prefab = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab";

                [JsonProperty("Allow the Harvest Grown Yield to increase the amount of clones a player receives?")]
                public bool clone_yield = true;

                [JsonProperty("Primitive weapons for the primitive weapons ability", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public HashSet<string> primitive_weapons = new HashSet<string>();

                [JsonProperty("Harvesting yield blacklist [items listed here will not be affected by the harvesting yield perks]")]
                public HashSet<string> harvest_yield_blacklist = new HashSet<string>();

                [JsonProperty("List of items that the Durability perk will not work with")]
                public HashSet<string> durability_blacklist = new HashSet<string>();

                [JsonProperty("Force all modified extended weapons to unload their ammo when the plugin unloads/hook all users with the buff log off?")]
                public bool force_unload_extended_mag_weapons_unload = false;

                [JsonProperty("Prevent flyhack kicks when a player lands?")]
                public bool prevent_flyhack_kick_fall_damage = false;

                [JsonProperty("Automatically apply the boat turbo when a player mounts the boat? [Disables the turbo command]")]
                public bool boat_turbo_on_mount = false;

                [JsonProperty("Distance in front of player for nodes to spawn when the Node_Spawn_Chance buff procs?")]
                public float Node_Spawn_Chance_dist = 2;

                [JsonProperty("Cooldown between hits for the vehicle mechanic buff? [0 = no cooldown]")]
                public float Vehicle_Mechanic_Cooldown = 0;

                [JsonProperty("Forager settings")]
                public ForagerSettings forager_settings = new ForagerSettings();
                public class ForagerSettings
                {
                    [JsonProperty("Command to use the ability")]
                    public string command = "forage";

                    [JsonProperty("Distance to search for map collectibles")]
                    public float distance = 100f;

                    [JsonProperty("Time that the locations are displayed on the screen")]
                    public float time_on_screen = 60f;

                    [JsonProperty("Usage cooldown")]
                    public float cooldown = 60f;

                    [JsonProperty("Black list of shortnames for collecibles that won't be displayed")]
                    public HashSet<string> blacklist = new HashSet<string>();

                    [JsonProperty("Display colours")]
                    public Dictionary<string, float[]> displayColours = new Dictionary<string, float[]>();

                    [JsonProperty("Show distance?")]
                    public bool show_distance = false;
                }

                [JsonProperty("Tea looter settings")]
                public TeaLooterSettings tea_looter_settings = new TeaLooterSettings();

                public class TeaLooterSettings
                {
                    [JsonProperty("Minimum stack of tea that the player will receive when the Tea Looter buff procs?")]
                    public int min_tea = 1;

                    [JsonProperty("Maximum stack of tea that the player will receive when the Tea Looter buff procs?")]
                    public int max_tea = 1;

                    [JsonProperty("Tea looter table [shortname : drop weight]")]
                    public Dictionary<string, int> TeaDropTable = new Dictionary<string, int>(StringComparer.InvariantCultureIgnoreCase);

                    [JsonProperty("Containers that tea can be found in")]
                    public HashSet<string> containers = new HashSet<string>();
                }

                [JsonProperty("Sonar settings")]
                public SonarSettings sonar_settings = new SonarSettings();
                public class SonarSettings
                {
                    [JsonProperty("Command to use the ability")]
                    public string command = "sonar";

                    [JsonProperty("Distance to search for underwater entities")]
                    public float distance = 300f;

                    [JsonProperty("Time that the locations are displayed on the screen")]
                    public float time_on_screen = 10f;

                    [JsonProperty("Usage cooldown")]
                    public float cooldown = 10f;

                    public bool show_tugboats = true;
                    public bool show_dive_sites = true;
                    public bool show_sharks = true;
                    public bool show_scientists = true;
                    public bool show_players = false;

                    [JsonProperty("Show distance?")]
                    public bool show_distance = false;
                }

                [JsonProperty("Raid perk settings")]
                public RaidTreeSettings raid_perk_settings = new RaidTreeSettings();
                public class RaidTreeSettings
                {
                    [JsonProperty("Automatically pass raidable base checks if the plugin is unloaded?")]
                    public bool default_pass = true;

                    [JsonProperty("Settings for trap_damage_reduction")]
                    public TrapDamageReductionSettings trap_damage_reduction_settings = new TrapDamageReductionSettings();
                    public class TrapDamageReductionSettings
                    {
                        [JsonProperty("Traps blacklist - will ignore the buff")]
                        public HashSet<string> blacklist = new HashSet<string>();

                        [JsonProperty("Only allow this buff to work with raidable base traps")]
                        public bool raidable_bases_only = false;
                    }

                    [JsonProperty("Settings for trap_damage_increase")]
                    public TrapDamageIncreaseSettings trap_damage_increase_settings = new TrapDamageIncreaseSettings();
                    public class TrapDamageIncreaseSettings
                    {
                        [JsonProperty("Traps blacklist - will ignore the buff")]
                        public HashSet<string> blacklist = new HashSet<string>();

                        [JsonProperty("Only allow this buff to work with raidable base traps")]
                        public bool raidable_bases_only = false;
                    }

                    [JsonProperty("Settings for Personal_Explosive_Reduction")]
                    public PersonalExplosiveReductionSettings personal_explosive_reduction_settings = new PersonalExplosiveReductionSettings();
                    public class PersonalExplosiveReductionSettings
                    {
                        [JsonProperty("Prefabs blacklist - will ignore the buff")]
                        public HashSet<string> blacklist = new HashSet<string>();

                        [JsonProperty("Work with fire explosives such as molotov's and incin rockets?")]
                        public bool fire_damage_reduction = true;
                    }

                    [JsonProperty("Settings for Double_Explosion_chance")]
                    public DoubleExplosionChanceSettings Double_Explosion_chance_settings = new DoubleExplosionChanceSettings();
                    public class DoubleExplosionChanceSettings
                    {
                        [JsonProperty("Prefabs black - will not trigger with items listed here")]
                        public HashSet<string> blacklist = new HashSet<string>();

                        [JsonProperty("Only allow this buff to work with raidable base?")]
                        public bool raidable_bases_only = false;
                    }

                    [JsonProperty("Settings for Explosion_Radius")]
                    public ExpolosionRadiusSettings Explosion_Radius_settings = new ExpolosionRadiusSettings();
                    public class ExpolosionRadiusSettings
                    {
                        [JsonProperty("Prefabs blacklist - will ignore the buff")]
                        public HashSet<string> blacklist = new HashSet<string>();

                        [JsonProperty("Add the difference to the minimum explosion radius")]
                        public bool add_to_minimum = true;

                        [JsonProperty("Only allow this buff to work with raidable base?")]
                        public bool raidable_bases_only = false;
                    }

                    [JsonProperty("Settings for Lock_Picker")]
                    public LockPickerSettings Lock_Picker_settings = new LockPickerSettings();
                    public class LockPickerSettings
                    {
                        [JsonProperty("Command required for the player to activate their lockpick ability")]
                        public string pick_command = "picklock";

                        [JsonProperty("Time after the command has been used before the ability use expires [seconds]")]
                        public float time = 30;

                        [JsonProperty("Delay before the Lock_Picker ability can be used again [seconds]")]
                        public float use_delay = 600;

                        [JsonProperty("Only allow this buff to work with raidable base?")]
                        public bool raidable_bases_only = false;

                        [JsonProperty("Damage the player receives when they fail an attempt")]
                        public float damage_per_fail = 0;

                        [JsonProperty("Show the pick lock timer when activating the ability")]
                        public bool show_timer = true;

                        [JsonProperty("How often should the timer update")]
                        public int timer_tick_rate = 1;

                        [JsonProperty("Set the lock to unlocked when successfully picking a lock? [false will open the entity but keep it locked]")]
                        public bool unlock_entity = false;
                    }

                    [JsonProperty("Settings for Dudless_Explosive")]
                    public DudlessExplosiveSettings Dudless_Explosiv_settings = new DudlessExplosiveSettings();
                    public class DudlessExplosiveSettings
                    {
                        [JsonProperty("Only allow this buff to work with raidable base?")]
                        public bool raidable_bases_only = false;
                    }

                    [JsonProperty("Settings for Trap_Spotter")]
                    public TrapSpotterSettings Trap_Spotter_settings = new TrapSpotterSettings();
                    public class TrapSpotterSettings
                    {
                        [JsonProperty("Max distance from the player to search for traps")]
                        public float distance = 20f;

                        [JsonProperty("Cooldown between uses [seconds]")]
                        public float cooldown = 60f;

                        [JsonProperty("Time that the traps will be displayed for [seconds]")]
                        public float time_on_screen = 60f;

                        [JsonProperty("Show the names of each trap prefab")]
                        public bool show_names = true;

                        [JsonProperty("Command to perform the search")]
                        public string command = "traps";

                        [JsonProperty("Only allow this buff to work with raidable base?")]
                        public bool raidable_bases_only = false;

                        [JsonProperty("Colours that the traps will be displayed in")]
                        public Dictionary<string, float[]> trap_colours = new Dictionary<string, float[]>();
                    }

                    [JsonProperty("Settings for Loot_Spotter")]
                    public LootSpotterSettings Loot_Spotter_settings = new LootSpotterSettings();
                    public class LootSpotterSettings
                    {
                        [JsonProperty("Cooldown between uses [seconds]")]
                        public float cooldown = 60f;

                        [JsonProperty("Time that the traps will be displayed for [seconds]")]
                        public float time_on_screen = 60f;

                        [JsonProperty("Text colour")]
                        public (float, float, float) text_col = (1, 0, 0);

                        [JsonProperty("Show the names of each container prefab")]
                        public bool show_names = true;

                        [JsonProperty("Command to perform the search")]
                        public string command = "crates";

                        [JsonProperty("Only allow this buff to work with raidable base?")]
                        public bool raidable_bases_only = true;

                        public Color GetColour()
                        {
                            return new Color(text_col.Item1, text_col.Item2, text_col.Item3);
                        }
                    }
                }

                [JsonProperty("Underwater Breathing settings")]
                public UnderwaterBreathingSettings underwaterSettings = new UnderwaterBreathingSettings();
                public class UnderwaterBreathingSettings
                {
                    public string anchor_min = "1 1";
                    public string anchor_max = "1 1";
                    public string offset_min = "-48 -48";
                    public string offset_max = "-12 -12";
                }

                [JsonProperty("Allow the UnderwaterDamageBonus to function in PVP")]
                public bool UnderwaterDamageBonus_pvp = true;

                [JsonProperty("Base the crafting xp on the time it takes to craft the item? [false will use blueprint craft time]")]
                public bool timeBasedCraftingXP = true;

                [JsonProperty("Comfort settings")]
                public ComfortSettings comfortSettings = new ComfortSettings();
                public class ComfortSettings
                {
                    [JsonProperty("How often should we update comfort levels for nearby team members [seconds]")]
                    public float Interval = 5;

                    [JsonProperty("Distance that team members receive comfort from")]
                    public float Distance = 10;
                }

                [JsonProperty("Mobile Workbench settings")]
                public MobileWorkbenchSettings mobileWorkbenchSettings = new MobileWorkbenchSettings();
                public class MobileWorkbenchSettings
                {
                    [JsonProperty("How often should we run the update cycle for workbenches [seconds]")]
                    public float Interval = 5;

                    [JsonProperty("Distance that team members can access workbench from")]
                    public float Distance = 10;

                    [JsonProperty("Position in the map where the workbenches spawn [default 0,0,0]")]
                    public Vector3 MapSpawnPosition = Vector3.zero;
                }

                [JsonProperty("Tea Share settings")]
                public TeaShareSettings teaShareSettings = new TeaShareSettings();
                public class TeaShareSettings
                {
                    [JsonProperty("Distance that team members can receive tea buffs from")]
                    public float Distance = 10;
                }

                [JsonProperty("Metabolism Share settings")]
                public MetabolismShareSettings metabolismShareSettings = new MetabolismShareSettings();
                public class MetabolismShareSettings
                {
                    [JsonProperty("Distance that team members can receive calory and hydration from")]
                    public float Distance = 10;
                }

                [JsonProperty("Heal Share settings")]
                public HealShareSettings healShareSettings = new HealShareSettings();
                public class HealShareSettings
                {
                    [JsonProperty("Distance that team members can receive healing from")]
                    public float Distance = 10;
                }

                [JsonProperty("XP Share settings")]
                public XPShareSettings xpShareSettings = new XPShareSettings();
                public class XPShareSettings
                {
                    [JsonProperty("Distance that team members can receive xp from")]
                    public float Distance = 10;

                    [JsonProperty("Base the percentage using modified xp [true] or the base xp amount [false]")]
                    public bool modifiedXP = false;
                }

                [JsonProperty("Double Bandage Heal Cooldown [seconds]")]
                public float Double_Bandage_Heal_Cooldown = 0;

                [JsonProperty("Wounded Resist Cooldown [seconds]")]
                public float Wounded_Resist_Cooldown = 0;

                [JsonProperty("Harvesting luck settings")]
                public HarvestingLuckSettings harvesting_luck_settings = new HarvestingLuckSettings();
                public class HarvestingLuckSettings
                {
                    [JsonProperty("Allow the harvesting luck buff to work with player grown collectibles [uses its own drop table]?")]
                    public bool Harvesting_luck_works_with_grown = true;

                    [JsonProperty("List of entities that won't trigger the buff")]
                    public HashSet<string> blacklist = new HashSet<string>();
                }

                [JsonProperty("Awareness settings")]
                public AwarenessSettings awareness_settings = new AwarenessSettings();
                public class AwarenessSettings
                {
                    [JsonProperty("How often should awareness update?")]
                    public float updateRate = 5;

                    [JsonProperty("Show corpse locations?")]
                    public bool corpse = true;

                    [JsonProperty("Show bag locations?")]
                    public bool bag = true;

                    [JsonProperty("Show dropped item locations?")]
                    public bool droppedItem = true;

                    [JsonProperty("Show animal locations?")]
                    public bool animals = true;

                    [JsonProperty("Show Human Npc locations?")]
                    public bool humanNPC = true;

                    [JsonProperty("Blacklist of item shortnames that will not show up")]
                    public HashSet<string> blacklist = new HashSet<string>();
                }

                [JsonProperty("SharkSkinner blacklist [item shortname]")]
                public HashSet<string> SharkSkinnerblacklist = new HashSet<string>();

                [JsonProperty("ShieldReflect Settings")]
                public ShieldReflectSettings shield_ReflectSettings = new ShieldReflectSettings();

                public class ShieldReflectSettings
                {
                    [JsonProperty("Maximum distance the buff will work from [-1 = no max]")]
                    public float maxDistance = -1;

                    [JsonProperty("Bullet damage reflection modifier [1 = 100%]")]
                    public float bulletReflectMod = 1f;

                    [JsonProperty("Arrow damage reflection modifier [1 = 100%]")]
                    public float arrowReflectMod = 1f;
                }
            }

            [JsonProperty("Chat command settings")]
            public ChatCommands chat_commands = new ChatCommands();

            public class ChatCommands
            {
                [JsonProperty("Use mouse 3 to toggle the boat turbo (performance heavy on high pop servers). Set false to use a chat command instead")]
                public bool use_input_key_boat = false;

                [JsonProperty("Chat command for turbo")]
                public string turbo_cmd = "turbo";

                [JsonProperty("Chat commands to open the skill tree", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<string> chat_cmd = new List<string>() { "st", "skilltree", "skills" };

                [JsonProperty("Chat/console commands to open the score board", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<string> score_chat_cmd = new List<string>() { "score", "scoreboard" };

                [JsonProperty("Chat command for tracking an animal with the AnimalTracker buff")]
                public string track_animal_cmd = "track";
            }

            [JsonProperty("XP settings")]
            public XPSettings xp_settings = new XPSettings();

            public class XPSettings
            {
                [JsonProperty("XP Loss settings")]
                public XPLossSettings xp_loss_settings = new XPLossSettings();

                public class XPLossSettings
                {
                    [JsonProperty("Allow players to lose xp when they die?")]
                    public bool allow_xp_loss = true;

                    [JsonProperty("Allow players to go into xp debt if they lose more xp than their level would allow?")]
                    public bool allow_xp_debt = true;

                    [JsonProperty("Xp loss type [PercentageOfCurrentLevel, PercentageOfTotalXp, XpValue]")]
                    public XPLossType xp_loss_type = XPLossType.PercentageOfCurrentLevel;

                    [JsonProperty("Death penalty grace period - players won't lose xp if they die again within the specified time [seconds]")]
                    public float no_xp_loss_time = 0;

                    [JsonProperty("XP loss values [if percentage, 1.0 = 100%. If XpValue, 100.0 = 100xp]")]
                    public XP_Loss_Amounts xp_loss_table = new XP_Loss_Amounts();
                    public class XP_Loss_Amounts
                    {
                        public float PVP = 0.1f;
                        public float Heli = 0.2f;
                        public float Bradley = 0.2f;
                        public float Scientist = 0.2f;
                        public float Animal = 0.2f;
                        public float Suicide = 0.2f;
                        public float Fire = 0.2f;
                        public float Cold = 0.2f;
                        public float Fall = 0.2f;
                        public float Traps = 0.2f;
                        public float Codelock = 0.2f;
                        public float Drowned = 0.2f;
                        public float Radiation = 0.2f;
                        public float Hunger = 0.2f;
                        public float Thirst = 0.2f;
                    }

                    [JsonProperty("Prevent xp loss when a player is offline?")]
                    public bool prevent_offline_xp_loss = true;

                    [JsonProperty("Permission based modifiers [1.0 = no reduced amount]")]
                    public Dictionary<string, double> xp_loss_override = new Dictionary<string, double>();
                }

                [JsonProperty("Permissions to adjust xp gain modifiers (skilltree.<perm>) [1.0 is default modifier]")]
                public Dictionary<string, double> xp_perm_modifier = new Dictionary<string, double>();

                [JsonProperty("How long should the xp be displayed for")]
                public float xp_display_time = 1f;

                [JsonProperty("Colour of the xp text when unmodified")]
                public string xp_display_col_unmodified = "FFFFFF";

                [JsonProperty("Colour of the xp text when modified")]
                public string xp_display_col_modified = "00b6ff";

                [JsonProperty("Colour of the xp text when modified by Skill Tree: XP Event")]
                public string xp_display_col_xp_event_modified = "c900ff";

                [JsonProperty("Prevent XP loss when dying at an event hosted by EventManager")]
                public bool prevent_xp_loss = true;

                [JsonProperty("Enable xp drop hud for players by default")]
                public bool enable_xp_drop_by_default = true;

                [JsonProperty("Restrict XP gain to the tools listed in their respective tools list?")]
                public bool white_listed_tools_only = false;

                [JsonProperty("Require grown plants to be ripe to provide xp")]
                public bool ripe_required = true;

                [JsonProperty("Give xp for crafting ingredients? [Requires Cooking.cs]")]
                public bool cooking_award_xp_ingredients = false;

                [JsonProperty("Whitelist - List of items to award crafting xp")]
                public HashSet<string> craft_xp_whitelist = new HashSet<string>();

                [JsonProperty("Blacklist - List of items that will not award crafting xp")]
                public HashSet<string> craft_xp_blacklist = new HashSet<string>();

                [JsonProperty("Use LootDefender to handle the XP for BradleyAPC")]
                public bool UseLootDefender = true;

                [JsonProperty("Allow players with god mode to receive xp?")]
                public bool allow_godemode_xp = true;

                [JsonProperty("Cooldown for awarding xp after using a swipe card")]
                public float swipe_card_xp_cooldown = 0;

                [JsonProperty("Decimal places for the xp to be rounded to")]
                public int xp_rounding = 2;

                [JsonProperty("Maximum amount of pending xp a player can accumulate [0 = no limit]")]
                public int pending_xp_cap = 0;

                [JsonProperty("List of meals that will not provide xp [Requires Cooking.cs]")]
                public HashSet<string> cooking_black_list = new HashSet<string>();

                [JsonProperty("Scale the xp based on the scale of the entity?")]
                public bool scaleXP = true;

                [JsonProperty("Experience sources - Set xp value to 0 to disable for that type", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public XPSources xp_sources = new XPSources();

                [JsonProperty("Night time settings")]
                public NightTimeGains night_settings = new NightTimeGains();

                public class NightTimeGains
                {
                    [JsonProperty("Modifier for xp gained at night [1.0 = standard]")]
                    public float night_xp_gain_modifier = 1f;

                    [JsonProperty("Modifier for woodcutting yield at night [1.0 = standard]")]
                    public float night_woodcutting_yield_modifier = 1f;

                    [JsonProperty("Modifier for mining yield at night [1.0 = standard]")]
                    public float night_mining_yield_modifier = 1f;

                    [JsonProperty("Modifier for skinning yield at night [1.0 = standard]")]
                    public float night_skinning_yield_modifier = 1f;

                    [JsonProperty("Modifier for harvesting yield at night [1.0 = standard]")]
                    public float night_harvesting_yield_modifier = 1f;

                    [JsonProperty("Should the harvesting yield increase include player-grown plants?")]
                    public bool include_grown_harvesting = false;

                    [JsonProperty("Send all players a gametip when night time bonuses start?")]
                    public bool announce_at_night = false;

                    [JsonProperty("How many seconds should we show the gametip for?")]
                    public float announcement_duration = 8;
                }

                [JsonProperty("Allow players to move their XP bar?")]
                public bool allow_move_xp_bar = true;

                [JsonProperty("Force the cursor to appear when moving the XP bar?")]
                public bool force_cursor_on_move = true;

                [JsonProperty("Should the givexp console command search for offline players as well?")]
                public bool givexp_offline = false;

                [JsonProperty("Should the givesp console command search for offline players as well?")]
                public bool givesp_offline = false;

                [JsonProperty("Should the givexpdebt console command search for offline players as well?")]
                public bool givexpdebt_offline = false;

                [JsonProperty("XP Cap Settings")]
                public XPCapSettings xPCapSettings = new XPCapSettings();

                public class XPCapSettings
                {
                    [JsonProperty("Daily xp cap [0 = no cap]")]
                    public double cap = 0;

                    [JsonProperty("What time should the cap reset each day [hh:mm AM/PM]")]
                    public string resetTime = "06:00 AM";
                }
            }

            [JsonProperty("Prestige settings")]
            public PrestigeSettings prestige_settings = new PrestigeSettings();
            public class PrestigeSettings
            {
                [JsonProperty("Allow players to reset their progresss and gain Prestige levels?")]
                public bool enabled = false;

                [JsonProperty("Ignore the level reward bonuses if the player has prestige levels?")]
                public bool ignore_level_rewards = false;

                [JsonProperty("Remove players from lower level prestige groups?")]
                public bool remove_from_lower_groups = false;

                [JsonProperty("Run reset commands for level rewards when the player prestiges?")]
                public bool run_level_rewards_reset_on_Prestige = false;

                [JsonProperty("Show the prestige button before the player achieves the level? (they won't be able to accept the rank up until max level)")]
                public bool show_button_before_level = true;

                [JsonProperty("Should the player keep excess skill points outside of what they received from leveling/starting points?")]
                public bool should_keep_excess_points = false;

                [JsonProperty("Should we apply the xp bonus multiplicatively? [false = additively]")]
                public bool apply_bonus_multiplicatively = false;

                [JsonProperty("Prestige levels")]
                public Dictionary<int, PrestigeInfo> levels = new Dictionary<int, PrestigeInfo>();
                public class PrestigeInfo
                {
                    [JsonProperty("Permissions [name : perm]")]
                    public Dictionary<string, string> perms;

                    [JsonProperty("Commands to run when the player prestiges ({id} = userid. {name} = player name) [description : command]")]
                    public Dictionary<string, string> commands;

                    [JsonProperty("Additional benefits descriptions")]
                    public List<string> additionalBenfitsDescription = new List<string>();

                    [JsonProperty("Format for BetterChat title showing the prestige level. {0} is the colour value and {1} is the player prestige value")]
                    public string better_title_format = "<color=#{0}>[Pr.{1}]</color>";

                    [JsonProperty("Colour for BetterChat xp titles")]
                    public string better_title_default_col = "d109ec";

                    [JsonProperty("Skin ID that will be displayed when ranking up")]
                    public ulong RankUpPic;

                    [JsonProperty("Rank title")]
                    public string rankTitle;

                    [JsonProperty("XP modifier")]
                    public float xp_mod = 1;

                    public PrestigeInfo(Dictionary<string, string> perms, ulong RankUpPic, string title)
                    {
                        this.perms = perms;
                        this.RankUpPic = RankUpPic;
                        this.rankTitle = title;
                    }
                }

                public void Initialize()
                {
                    if (levels != null && levels.Count > 0)
                    {
                        foreach (var level in levels)
                        {
                            if (string.IsNullOrEmpty(level.Value.rankTitle)) level.Value.rankTitle = $"Prestige Rank {level.Key}";
                        }
                        return;
                    }
                    levels = new Dictionary<int, PrestigeInfo>()
                    {
                        [1] = new PrestigeInfo(new Dictionary<string, string>() { ["Your perm title"] = "yourperm.use" }, 3165843865, "Prestige Rank 1"),
                        [2] = new PrestigeInfo(new Dictionary<string, string>() { ["Your perm title"] = "yourperm.use" }, 3165843987, "Prestige Rank 2"),
                        [3] = new PrestigeInfo(new Dictionary<string, string>() { ["Your perm title"] = "yourperm.use" }, 3165844049, "Prestige Rank 3")
                    };
                }

                public int HighestLevel()
                {
                    if (levels == null) return 0;
                    var result = 0;
                    foreach (var level in levels.Keys)
                    {
                        if (level > result) result = level;
                    }
                    return result;
                }
            }

            [JsonProperty("Wipe and plugin update settings")]
            public WipeUpdate wipe_update_settings = new WipeUpdate();

            public class WipeUpdate
            {
                /* Wipe xp/level -
                 * Refund points -
                 * Prestige
                 * Extra pockets
                 * Pending xp
                 * Rested xp
                 * Xp debt
                 */
                [JsonConverter(typeof(StringEnumConverter))]
                public enum WipeType
                {
                    None,
                    Reset,
                    Refund
                }

                [JsonProperty("Automatically wipe player data after x days if they have not logged in? [0 = off] [only checks on wipe]")]
                public int wipe_after_days = 0;

                [JsonProperty("Wipe all player data files [setting true will ignore all below settings that handle data reset]?")]
                public bool wipe_everything = false;

                [JsonProperty("How should we handle xp, levels and skills when the server wipes [None, Reset, Refund]?")]
                public WipeType xp_wipe_type = WipeType.Refund;

                [JsonProperty("Should we wipe prestige levels?")]
                public bool prestige_wipe = false;

                [JsonProperty("Wipe xp debt?")]
                public bool xp_debt_wipe = true;

                [JsonProperty("Wipe respec multiplier?")]
                public bool respec_multiplier_wipe = true;

                [JsonProperty("Reset pending xp pools on wipe?")]
                public bool reset_pending_xp_on_wipe = true;

                [JsonProperty("Erase ExtraPockets storage on wipe")]
                public bool erase_ExtraPockets_on_wipe = true;

                [JsonProperty("Give the player with the highest xp bonus skill points next wipe")]
                public bool bonus_skill_points = false;

                [JsonProperty("How many skill points should they receive for winning?")]
                public int bonus_skill_points_amount = 5;

                [JsonProperty("Automatically add new trees from the default config?")]
                public bool auto_update_trees = true;

                [JsonProperty("Automatically add new nodes from the default config?")]
                public bool auto_update_nodes = true;

                [JsonProperty("Starting skill points")]
                public int starting_skill_points = 0;

                [JsonProperty("Dictionary of permission based overrides for starting skill points")]
                public Dictionary<string, int> starting_skill_point_overrides = new Dictionary<string, int>();
            }

            [JsonProperty("Rested XP Settings")]
            public RestXPSettings rested_xp_settings = new RestXPSettings();

            public class RestXPSettings
            {
                [JsonProperty("Give players who have been offline a bonus to xp gain when they log in next?")]
                public bool rested_xp_enabled = true;

                [JsonProperty("Rested xp pool to accumulate per hour offline")]
                public double rested_xp_per_hour = 1000;

                [JsonProperty("Bonus xp rate while rested (until the rested xp pool is depleted) [0.25 = 25% bonus]")]
                public double rested_xp_rate = 0.25;

                [JsonProperty("Maximum xp a player can have in their rested pool [0 = no limit]")]
                public double rested_xp_pool_max = 25000;

                [JsonProperty("Reset rested xp pools on wipe?")]
                public bool rested_xp_reset_on_wipe = false;

                [JsonProperty("Modifiers based on permissions to adjust the rested xp value [1.0 = 100% increase. 0.0 = no increase]")]
                public Dictionary<string, float> rested_xp_modifier_perm_mod = new Dictionary<string, float>();
            }

            [JsonProperty("Tools and Black list/White list settings")]
            public ToolAndListSettings tools_black_white_list_settings = new ToolAndListSettings();

            public class ToolAndListSettings
            {
                [JsonProperty("Global black list - these items will not gain xp and benefits at all")]
                public HashSet<string> black_listed_gather_items = new HashSet<string>();

                [JsonProperty("Electrical and component luck settings")]
                public ElectricalAndComponentLuckSettings electricalComponentSettings = new ElectricalAndComponentLuckSettings();
                public class ElectricalAndComponentLuckSettings
                {
                    [JsonProperty("Black listed parts for component and electrical luck abilities", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                    public HashSet<string> comp_blacklist = new HashSet<string>();

                    [JsonProperty("Electrical custom loot override [use addelectricaloverride console command to add example to config]", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                    public List<LootItems> electrical_loot_override = new List<LootItems>();

                    [JsonProperty("Component list custom loot override [use addcomponentoverride console command to add example to config]", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                    public List<LootItems> component_loot_override = new List<LootItems>();

                }

                [JsonProperty("Power tool modifiers (chainsaw and jackhammer). 1 = full xp/buffs. 0 = off. 0.5 = half xp/buffs.")]
                public PowerTools power_tool_modifier = new PowerTools()
                {
                    mining_yield_modifier = 0.25f,
                    mining_xp_modifier = 0.25f,
                    mining_luck_modifier = 0.25f,

                    skinning_yield_modifier = 0.25f,
                    skinning_xp_modifier = 0.25f,
                    skinning_luck_modifier = 0.25f,

                    woodcutting_yield_modifier = 0.25f,
                    woodcutting_xp_modifier = 0.25f,
                    woodcutting_luck_modifier = 0.25f
                };

                [JsonProperty("Extra Pockets black list - disallows items that match")]
                public HashSet<string> black_list = new HashSet<string>();

                [JsonProperty("Extra Pockets white list - will only allow items that match")]
                public HashSet<string> white_list = new HashSet<string>();

                [JsonProperty("Extra pockets button anchor settings")]
                public AnchorSettings extra_pockets_button_anchor = new AnchorSettings("0.5 0", "0.5 0", "185.4 25.4", "227.4 67.4");

                [JsonProperty("A black list of items that will not be refunded when using the thrifty tinkerer buff", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public HashSet<string> craft_refund_blacklist = new HashSet<string>() { "gunpowder", "explosives", "sulfur" };

                [JsonProperty("A black list of items that will not be duplicated while using the thirfty duplicator buff", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public HashSet<string> craft_duplicate_blacklist = new HashSet<string>() { "gunpowder", "explosives", "sulfur" };

                [JsonProperty("Woodcutting tools - Tools that meet whitelist requirements and work with the reduced durability ability", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public HashSet<string> wc_tools = new HashSet<string>();

                [JsonProperty("Mining tools - Tools that meet whitelist requirements and work with the reduced durability ability", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public HashSet<string> mining_tools = new HashSet<string>();

                [JsonProperty("Skinning tools - Tools that meet whitelist requirements and work with the reduced durability ability", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public HashSet<string> skinning_tools = new HashSet<string>();

                [JsonProperty("Blacklist of weapon prefab shortnames that cannot benefit from the Extended Mag buff")]
                public HashSet<string> extendedMag_weapon_blacklist = new HashSet<string>();

                [JsonProperty("Blacklist of ammo item shortnames that cannot benefit from the Extended Mag buff")]
                public HashSet<string> extendedMag_ammotype_blacklist = new HashSet<string>();
            }

            [JsonProperty("Effect settings")]
            public EffectSettings effect_settings = new EffectSettings();

            public class EffectSettings
            {
                [JsonProperty("Instant repair effect")]
                public string repair_effect = "assets/bundled/prefabs/fx/build/repair_full_metal.prefab";

                [JsonProperty("Level up effect")]
                public string level_effect = "assets/prefabs/misc/halloween/lootbag/effects/gold_open.prefab";

                [JsonProperty("Node unlock effect")]
                public string skill_point_unlock_effect = "assets/prefabs/misc/halloween/lootbag/effects/loot_bag_upgrade.prefab";

                [JsonProperty("Node level effect")]
                public string skill_point_level_effect = "assets/prefabs/misc/easter/painted eggs/effects/eggpickup.prefab";

                [JsonProperty("Lock pick fail attempt")]
                public string lockpick_fail_effect = "assets/prefabs/deployable/bear trap/effects/bear-trap-deploy.prefab";

                [JsonProperty("Lock pick success attempt")]
                public string lockpick_success_effect = "assets/prefabs/deployable/locker/effects/locker-deploy.prefab";
            }

            [JsonProperty("Better Chat settings")]
            public BetterChatSettings betterchat_settings = new BetterChatSettings();

            public class BetterChatSettings
            {
                [JsonProperty("Format for BetterChat title showing the playeres level. Set to null to disable. {0} is the colour value and {1} is the player level value")]
                public string better_title_format = "<color=#{0}>[Lv.{1}]</color>";

                [JsonProperty("Default colour for BetterChat xp titles")]
                public string better_title_default_col = "0cb072";

                [JsonProperty("Colour for BetterChat xp titles for players who are max level")]
                public string better_title_max_col = "32ff00";
            }

            [JsonProperty("Loot settings")]
            public LootTables loot_settings = new LootTables();

            public class LootTables
            {
                [JsonProperty("Mining luck loot table", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<LootItems> mining_loot_table = new List<LootItems>();

                [JsonProperty("Woodcutting luck loot table", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<LootItems> wc_loot_table = new List<LootItems>();

                [JsonProperty("Skinning luck loot table", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<LootItems> skinning_loot_table = new List<LootItems>();

                [JsonProperty("Fishing luck loot table", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<LootItems> fishing_loot_table = new List<LootItems>();

                [JsonProperty("Metal detector luck loot table", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<LootItems> metal_detector_loot_table = new List<LootItems>();

                [JsonProperty("Harvesting luck loot table [Wild]", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<LootItems> harvesting_loot_table_wild = new List<LootItems>();

                [JsonProperty("Harvesting luck loot table [Grown]", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<LootItems> harvesting_loot_table_grown = new List<LootItems>();

                [JsonProperty("Whitelist of loot crates to trigger the spawn chance for components, electronics and scrap. Set to null to not use the whitelist.", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public HashSet<string> loot_crate_whitelist = new HashSet<string>();
            }

            [JsonProperty("Ultimate settings")]
            public UltimateSettings ultimate_settings = new UltimateSettings();

            public class UltimateSettings
            {
                [JsonProperty("Background colour for the ultimate node")]
                public string ultimate_node_background_col = "1 0.8741453 0 1";

                [JsonProperty("Ultimate settings for woodcutting")]
                public WoodcuttingUltimate ultimate_woodcutting = new WoodcuttingUltimate();

                [JsonProperty("Ultimate settings for mining")]
                public MiningUltimate ultimate_mining = new MiningUltimate();

                [JsonProperty("Ultimate settings for vehicle")]
                public VehicleUltimate ultimate_vehicle = new VehicleUltimate();

                [JsonProperty("Ultimate settings for medical")]
                public MedicalUltimate ultimate_medical = new MedicalUltimate();

                [JsonProperty("Ultimate settings for harvesting")]
                public HarvesterUltimate ultimate_harvesting = new HarvesterUltimate();

                [JsonProperty("Ultimate settings for scavenger")]
                public Scav_Ultimate ultimate_scavenger = new Scav_Ultimate();

                [JsonProperty("Ultimate settings for combat")]
                public CombatUltimate ultimate_combat = new CombatUltimate();

                [JsonProperty("Ultimate settings for skinning")]
                public SkinningUltimate ultimate_skinning = new SkinningUltimate();

                [JsonProperty("Ultimate settings for build craft")]
                public BuildCraftUltimate ultimate_buildCraft = new BuildCraftUltimate();

                [JsonProperty("Ultimate settings for raiding")]
                public RaidingUltimate ultimate_raiding = new RaidingUltimate();

                [JsonProperty("Ultimate settings for cooking")]
                public CookingUltimate ultimate_cooking = new CookingUltimate();
            }

            [JsonProperty("Misc settings")]
            public MiscSettings misc_settings = new MiscSettings();

            public class MiscSettings
            {
                [JsonProperty("UI Settings")]
                public UISettings uiSettings = new UISettings();

                [JsonProperty("BotRespawn settings")]
                public BotRespawnSettings botRespawnSettings = new BotRespawnSettings();
                public class BotRespawnSettings
                {
                    [JsonProperty("Should we consider the BotRespawn NPCs as regular NPCs when calculating buffs?")]
                    public bool BotRespawn_IsNPC = true;

                    [JsonProperty("Enable botrespawn profile tracking and xp")]
                    public bool enabled = true;

                    [JsonProperty("BotReSpawn profile and xp list", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                    public Dictionary<string, double> botrespawn_profiles = new Dictionary<string, double>();
                }

                [JsonProperty("Human NPC's name that can be used to open the skill tree")]
                public string npc_name = "";

                [JsonProperty("Should we add a button to the pump bar to open SkillTree?")]
                public bool button_to_pump_bar = true;

                [JsonProperty("Should SkillTree call out to other plugins before it starts modifying the value of the items? [required for plugins that need pre-modified item amounts]")]
                public bool call_HandleDispenser = false;

                [JsonProperty("Log all xp that players gain [Will create a very large log file]?")]
                public bool log_player_xp_gain = false;

                [JsonProperty("Allow the rationer perk to work with cooking meals?")]
                public bool ration_cooking_meals = true;

                [JsonProperty("Steam64 ID to use when sending a message to a player [0 is the default rust icon]")]
                public ulong ChatID = 76561199514393612;

                [JsonProperty("Anchor points for time left UI")]
                public AnchorSettings timeLeft_anchor = new AnchorSettings("0.5 0", "0.5 0", "-69.664 87.1", "70.336 103.1");

                [JsonProperty("Update skin IDs from the default config if they are set to 0?")]
                public bool update_skinIDs_from_default = false;

                [JsonProperty("Prevent tea bonuses when handling yields? [skilltree.teabonus bypasses this]")]
                public bool prevent_tea_bonus_on_yields = false;

                [JsonProperty("ZoneManager settings")]
                public ZoneManagerSettings zoneManagerSettings = new ZoneManagerSettings();
                public class ZoneManagerSettings
                {
                    [JsonProperty("List of zone ids that will prevent xp loss")]
                    public HashSet<string> NoXPLossZones = new HashSet<string>();

                    [JsonProperty("List of zone ids that will prevent player skills from functioning")]
                    public HashSet<string> NoSkillZones = new HashSet<string>();
                }

                [JsonProperty("Scoreboard settings")]
                public ScoreBoardSettings scoreBoardSettings = new ScoreBoardSettings();
                public class ScoreBoardSettings
                {
                    [JsonProperty("How many offline score files should we attempt to read per game-tick?")]
                    public int ScoreUpdateIteration = 10;

                    [JsonProperty("How often (seconds) should the scoreboard check for updates [online players only]?")]
                    public float ScoreUpdateTime = 60;

                    [JsonProperty("How many decimal places should the xp be rounded to?")]
                    public int xpRounding = 2;

                    [JsonProperty("Maximum scores to display")]
                    public int maxScores = 250;
                }

                [JsonProperty("List of buffs that you do not want players to disable from the buff settings menu")]
                public HashSet<Buff> noSettingsBuffs = new HashSet<Buff>();

                [JsonProperty("Skill tree preset settings")]
                public PresetSettings presetSettings = new PresetSettings();
                public class PresetSettings
                {
                    [JsonProperty("Allow players to create skill presets (profiles)?")]
                    public bool enabled = true;

                    [JsonProperty("Allow players to change presets anywhere?")]
                    public bool allowChangeAnywhere = true;

                    [JsonProperty("Allow players to change presets in TC range?")]
                    public bool allowChangeTC = true;

                    [JsonProperty("Allow players to change presets in safe zones?")]
                    public bool allowChangeSafeZone = true;

                    [JsonProperty("Maximum presets a player can setup [0 = no limit]")]
                    public int maxPresets = 3;

                    [JsonProperty("Maximum presets overrides [must be higher than default]")]
                    public Dictionary<string, int> maxPresetsOverride = new Dictionary<string, int>();

                    [JsonProperty("Cost settings for creating a new preset")]
                    public SetupCostSettings setupCosts = new SetupCostSettings();

                    public class SetupCostSettings
                    {
                        [JsonProperty("Should we charge the player their standard respec cost when adding a new profile?")]
                        public bool chargeRespecCost = true;

                        [JsonProperty("Economics cost to setup a new preset")]
                        public double econ = 0;

                        [JsonProperty("Server rewards cost to setup a new preset")]
                        public int srp = 0;

                        [JsonProperty("ShoppyStock cost to setup a new preset")]
                        public int shoppyStock = 0;

                        [JsonProperty("Items cost to setup a new preset")]
                        public List<ItemCost> items = new List<ItemCost>();
                    }

                    [JsonProperty("Cost settings for swapping to a preset")]
                    public SwapCostSettings swapCost = new SwapCostSettings();

                    public class SwapCostSettings
                    {
                        [JsonProperty("Should we charge the player their standard respec cost when swapping profiles?")]
                        public bool chargeRespecCost = true;

                        [JsonProperty("Additional Economics cost to swap [requires: Economics]")]
                        public double additionalEconCost = 0;

                        [JsonProperty("Additional Server rewards cost to swap [requires: ServerRewards]")]
                        public int additionalSRCost = 0;

                        [JsonProperty("Additional ShoppyStock cost to swap [requires: ServerRewards]")]
                        public int additionalShoppyStockCost = 0;

                        [JsonProperty("Additional item costs to swap")]
                        public List<ItemCost> additionalItemCost = new List<ItemCost>();
                    }

                    public class ItemCost
                    {
                        public string shortname;
                        public string displayName;
                        public ulong skin;
                        public int amount;
                        public ItemCost(string shortname, int amount, ulong skin, string displayName = null)
                        {
                            this.shortname = shortname;
                            this.amount = amount;
                            this.skin = skin;
                            this.displayName = displayName;
                        }

                        public bool IsMatch(Item item)
                        {
                            if (item.info.shortname != shortname) return false;
                            if (item.skin != skin) return false;
                            if (!string.IsNullOrEmpty(displayName) && item.name != displayName) return false;
                            return true;
                        }
                    }
                }

                [JsonProperty("Message settings")]
                public MessageSettings messageSettings = new MessageSettings();
                public class MessageSettings
                {
                    [JsonProperty("Message type when a node is levelled successfully [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType NodeLevelUp = MessageType.CUISuccess;

                    [JsonProperty("Message type when the player tries to level up a node without points [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType FailLevelUpNoPoints = MessageType.CUIWarn;

                    [JsonProperty("Message type when the player tries to level up a node when they are at max total points [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType FailLevelUpMaxPoints = MessageType.CUIWarn;

                    [JsonProperty("Message type when the player tries to level up a node when the skill is maxed [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType FailLevelUpMaxNode = MessageType.CUIWarn;

                    [JsonProperty("Message type when the player tries to level up a node when they do not have the minimum level [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType FailLevelUpMinLevel = MessageType.CUIWarn;

                    [JsonProperty("Message type when the player tries to level up a node when they do not have the minimum points spent [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType FailLevelUpMinPointsSpent = MessageType.CUIWarn;

                    [JsonProperty("Message type when the player tries to level up a node when they do not have the prestige level required [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType FailLevelUpMinPrestige = MessageType.CUIWarn;
                    
                    [JsonProperty("Message type when the player tries to level up a specific node when they do not have a high enough level [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType FailLevelUpMinLevelOnNode = MessageType.CUIWarn;

                    [JsonProperty("Message type when the player tries to level up a node when they do not have prerequisite skill [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType FailLevelMissingSkill = MessageType.CUIWarn;

                    [JsonProperty("Message type when the player tries to level up a node when they have an excluded skill [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType FailLevelExcludedSkill = MessageType.CUIWarn;

                    [JsonProperty("Message type when the player tries to level up a node when they do not have the prestige level required for the tree [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType FailLevelUpMinPrestigeForTree = MessageType.CUIWarn;

                    [JsonProperty("Message type when the player successfully respecs [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType Respec = MessageType.CUINormal;

                    [JsonProperty("Message type when the player fails to respec [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType RespecFail = MessageType.CUIWarn;

                    [JsonProperty("Message type when the player tries to level up an inaccessible node [None, Chat, CUISuccess, CUIWarn, CUINormal]")]
                    public MessageType FailInaccessible = MessageType.CUIWarn;

                    [JsonProperty("CUI colours for CUIWarn, CUISuccess and CUINormal")]
                    public CUICols cuiCols = new CUICols();
                    public class CUICols
                    {
                        public string CUISuccess = "0.056 0.481 0.065 1";
                        public string CUIWarn = "0.528 0.175 0.137 1";
                        public string CUINormal = "0.051 0.392 0.478 1";
                    }

                    [JsonProperty("Time before a message is sent before it's removed")]
                    public float CUIRemoveDelay = 3;

                    [JsonProperty("Should we expand the height of the CUI to accomodate messages with multiple lines?")]
                    public bool expandheight = true;
                }

                [JsonProperty("Enable video previous for skills")]
                public bool enable_videos = true;

                [JsonProperty("Urls for demo videos")]
                public Dictionary<Buff, string> videoURLs = new Dictionary<Buff, string>();

                [JsonProperty("Enable debug")]
                public bool enableDebug = true;
            }

            [JsonProperty("NpcSpawn (by KpucTaji) settings")]
            public BetterNPC betternpc_settings = new BetterNPC();

            public class BetterNPC
            {
                [JsonProperty("Give xp based on the name of a NpcSpawn, rather than the scientist type?")]
                public bool betternpc_give_xp = true;

                [JsonProperty("Dictionary of NPC names and the value that they provide")]
                public Dictionary<string, double> NPC_xp_table = new Dictionary<string, double>(StringComparer.InvariantCultureIgnoreCase);
            }

            [JsonProperty("Boss Monster (by KpucTaji) settings")]
            public BossMonster bossMonster_settings = new BossMonster();
            public class BossMonster
            {
                [JsonProperty("Dictionary of boss names and the damage modifier for the MLRS ultimate [Name:Damage multiplier]")]
                public Dictionary<string, float> mlrs_damage_mods = new Dictionary<string, float>();
            }

            [JsonProperty("Skill tree", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, Configuration.TreeInfo> trees = new Dictionary<string, Configuration.TreeInfo>();

            [JsonProperty("Leveling information. Y value must be set to 2 or 3")]
            public ExperienceInfo level = new ExperienceInfo();

            [JsonProperty("Notification settings")]
            public NotificationSettings notification_settings = new NotificationSettings();

            [JsonProperty("Third-party plugin settings")]
            public ThirdPartyPluginSettings thirdPartyPluginSettings = new ThirdPartyPluginSettings();
            public class ThirdPartyPluginSettings
            {
                [JsonProperty("SurvivalArena Settings")]
                public SurvivalArenaSettings survivalArenaSettings = new SurvivalArenaSettings();
                public class SurvivalArenaSettings
                {
                    [JsonProperty("Disable the skinning ultimate buff when the player joins the game?")]
                    public bool disable_skinning_ultimate_buff_on_join = true;
                }

                [JsonProperty("Paintball Settings")]
                public PaintballSettings paintballSettings = new PaintballSettings();
                public class PaintballSettings
                {
                    [JsonProperty("Disable the skinning ultimate buff when the player joins the game?")]
                    public bool disable_skinning_ultimate_buff_on_join = true;
                }
            }

            [JsonProperty("Roguelike settings")]
            public RoguelikeSettings roguelikeSettings = new RoguelikeSettings();
            public class RoguelikeSettings
            {
                [JsonProperty("Roguelike - Completely wipe a players progress when they die?")]
                public bool enabled = false;

                [JsonProperty("Require the player to have the skilltree.roguelike permission in order to participate?")]
                public bool require_permission = true;

                [JsonProperty("If the Roguelike setting is enabled, trigger when a player dies in PVE?")]
                public bool wipeOnPVEDeath = true;

                [JsonProperty("If the Roguelike setting is enabled, trigger when a player dies in PVP?")]
                public bool wipeOnPVPDeath = true;

                [JsonProperty("If the Roguelike setting is enabled, trigger when a player dies from suicide?")]
                public bool wipeOnSuicideDeath = true;

                [JsonProperty("If the Roguelike setting is enabled, trigger when a player dies from fall damage?")]
                public bool wipeOnFallDeath = true;

                [JsonProperty("Require the player to be connected to the service when they die and lose XP?")]
                public bool requireConnection = true;
            }

            public class NotificationSettings
            {
                [JsonProperty("Settings for Notify plugin")]
                public NotifySettings notifySettings = new NotifySettings();

                [JsonProperty("Settings for NotificationSystem plugin")]
                public NotificationSystemSettings notificationSystemSettings = new NotificationSystemSettings();

                [JsonProperty("Settings for Discord plugin")]
                public DiscordSettings discordSettings = new DiscordSettings();

                [JsonProperty("Settings chat notifications")]
                public ChatMessageNotificationSettings chatMessageNotificationSettings = new ChatMessageNotificationSettings();

                public class ChatMessageNotificationSettings
                {
                    [JsonProperty("Send a message when the Woodcutting ultimate goes on cooldown?")]
                    public bool Cooldown_woodcutting_ultimate = true;

                    [JsonProperty("Send a message when the Double Bandage Heal skill goes on cooldown?")]
                    public bool Cooldown_Double_Bandage_Heal = true;

                    [JsonProperty("Send a message when the Wounded Resist skill goes on cooldown?")]
                    public bool Cooldown_Wounded_Resist = true;

                    [JsonProperty("Send a message when the Rationed skill procs?")]
                    public bool Rationed_Proc = true;

                    [JsonProperty("Send a message when Skinning Luck procs?")]
                    public bool SkinningLuck_Proc = true;

                    [JsonProperty("Send a message when Mining Luck procs?")]
                    public bool MiningLuck_Proc = true;

                    [JsonProperty("Send a message when Woodcutting Luck procs?")]
                    public bool WoodcuttingLuck_Proc = true;

                    [JsonProperty("Send a message when Fishing Luck procs?")]
                    public bool FishingLuck_Proc = true;

                    [JsonProperty("Send a message when Harvesting Luck procs?")]
                    public bool HarvestingLuck_Proc = true;

                    [JsonProperty("Send a message when the Regrowth skill procs?")]
                    public bool Regrowth_Proc = true;

                    [JsonProperty("Send a message when receiving extra fish?")]
                    public bool Extra_Fish_Proc = true;

                    [JsonProperty("Send a message when Crafting Refund procs?")]
                    public bool Craft_Refund_Proc = true;

                    [JsonProperty("Send a message when Crafting Duplicate procs?")]
                    public bool Craft_Duplicate_Proc = true;

                    [JsonProperty("Send a message when Node Respawn procs?")]
                    public bool Node_Respawn_Proc = true;

                    [JsonProperty("Send a message when Iron Stomach procs?")]
                    public bool Iron_Stomach_Proc = true;

                    [JsonProperty("Send a message when Free Upgrade procs?")]
                    public bool Free_Upgrade_Proc = true;

                    [JsonProperty("Send a message when Research Refund procs?")]
                    public bool Research_Refund_Proc = true;

                    [JsonProperty("Send a message when Recycler Efficiency procs?")]
                    public bool Recycler_Efficiency_Proc = true;

                    [JsonProperty("Send notifications to players when the tea share skill procs?")]
                    public bool Tea_Share_Notify = true;

                    [JsonProperty("Send notifications to players when the metabolism share skill procs?")]
                    public bool Metabolism_Share_Notify = true;

                    [JsonProperty("Send notifications to players when the metal_detector_luck skill procs?")]
                    public bool Metal_Detector_Luck_Notify = true;
                }
            }

            public class DiscordSettings
            {
                [JsonProperty("Webhook URL")]
                public string webhook;

                [JsonProperty("Send a discord notification when a player levels up?")]
                public bool send_level_up = true;

                [JsonProperty("Send a discord notification when a player increases their prestige level?")]
                public bool send_prestige_up = true;
            }

            public class NotifySettings
            {
                [JsonProperty("Language key and message type to display when a player gains a level")]
                public KeyValuePair<string, int> level_up_notification = new KeyValuePair<string, int>("NotifyLevelGained", 0);

            }

            public class NotificationSystemSettings
            {
                [JsonProperty("Icon to show on the message")]
                public ulong icon = 3008683897;

                [JsonProperty("Send a notification when a player levels up?")]
                public bool SendLevelUp = true;

                [JsonProperty("Send a notification when a player hits max level?")]
                public bool SendLevelUpMax = true;

                [JsonProperty("Send a notification when a player receives increases their prestige level?")]
                public bool SendPrestigLevelRewards = true;
            }

            public class CustomCurrency
            {
                public string displayName = "";
                public string shortname = "";
                public ulong skin = 0;
            }

            public class TreeInfo
            {
                public bool enabled = true;
                [JsonProperty("Minimum level to unlock")]
                public int min_level = 0;
                [JsonProperty("Minimum points to unlock")]
                public int min_points = 0;
                [JsonProperty("Minimum prestige level to unlock")]
                public int min_prestige = 0;
                [JsonProperty("Points required to unlock skills [tier: points required] [tier 100 = ultimate]")]
                public Dictionary<int, int> point_requirements = new Dictionary<int, int>();

                public Dictionary<string, NodeInfo> nodes = new Dictionary<string, NodeInfo>();

                [JsonConstructor]
                public TreeInfo(Dictionary<string, NodeInfo> nodes, bool enabled = true)
                {
                    this.nodes = nodes;
                    this.enabled = enabled;
                }
                public TreeInfo(Dictionary<string, NodeInfo> nodes, bool enabled, int min_level)
                {
                    this.nodes = nodes;
                    this.enabled = enabled;
                    this.min_level = min_level;
                }
                public class NodeInfo
                {
                    [JsonProperty("Permission required to show this node")]
                    public string required_permission;
                    [JsonProperty("Minimum prestige required to unlock this node")]
                    public int min_prestige;
                    [JsonProperty("Minimum player level required to unlock this node")]
                    public int min_level;
                    [JsonProperty("Skill required to unlock node [Requires max level]")]
                    public string required_skill;
                    [JsonProperty("Skill that if unlocked, will prevent this node from unlocking")]
                    public string excluded_skill;
                    public bool enabled;
                    public int max_level;
                    public int tier;
                    public float value_per_buff;
                    public KeyValuePair<Buff, BuffType> buff_info;
                    public string icon_url;
                    public ulong skin;
                    public Permissions permissions;
                    public NodeInfo(bool enabled, int max_level, int tier, float value_per_buff, KeyValuePair<Buff, BuffType> buff_info, string icon_url, ulong skin, Permissions permissions = null)
                    {
                        this.enabled = enabled;
                        this.max_level = max_level;
                        this.tier = tier;
                        this.value_per_buff = value_per_buff;
                        this.buff_info = buff_info;
                        this.icon_url = icon_url;
                        this.permissions = permissions;
                        this.skin = skin;
                    }
                }
            }

            public class PowerTools
            {
                [JsonProperty("Yield modifier when using a jackhammer to mine")]
                public float mining_yield_modifier;

                [JsonProperty("Yield modifier when using a chainsaw to chop wood")]
                public float woodcutting_yield_modifier;

                [JsonProperty("Yield modifier when using a power tool to skin")]
                public float skinning_yield_modifier;

                [JsonProperty("XP modifier when using a jackhammer to mine")]
                public float mining_xp_modifier;

                [JsonProperty("XP modifier when using a chainsaw to chop wood")]
                public float woodcutting_xp_modifier;

                [JsonProperty("XP modifier when using a power tool to skin")]
                public float skinning_xp_modifier;

                [JsonProperty("Luck modifier when using a jackhammer to mine")]
                public float mining_luck_modifier;

                [JsonProperty("Luck modifier when using a chainsaw to chop wood")]
                public float woodcutting_luck_modifier;

                [JsonProperty("Luck modifier when using a power tool to skin")]
                public float skinning_luck_modifier;
            }

            public class ExperienceInfo
            {
                public double x = 0.07;
                public double y = 2;
                public Dictionary<int, double> xp_table = new Dictionary<int, double>();

                //XP - (Level / X) ^ 2
                //Level = X * SQR-Y

                public void CalculateTable(int max_level)
                {
                    for (int i = 0; i <= max_level; i++)
                    {
                        if (xp_table.ContainsKey(i))
                        {
                            var newValue = Math.Floor(Math.Pow(i / x, y));
                            if (xp_table[i] != newValue)
                            {
                                xp_table[i] = newValue;
                                UpdatedTable = true;
                            }
                        }

                        else xp_table.Add(i, Math.Floor(Math.Pow(i / x, y)));
                    }
                }
                public int GetLevel(double xp)
                {
                    int highest = 0;
                    for (int i = 0; i < 9999; i++)
                    {
                        if (xp > Math.Floor(Math.Pow(i / x, y))) highest = i;
                        else return highest;
                    }

                    return 9999;
                }

                public double GetLevelStartXP(int level)
                {
                    return Math.Pow(level / x, y);
                }

                public static bool UpdatedTable = false;
            }

            public class XPSources
            {
                public double NodeHit = 12;
                public double NodeHitFinal = 50;
                public double TreeHit = 8;
                public double TreeHitFinal = 40;
                public double SkinHit = 10;
                public double SkinHitFinal = 50;
                public double CollectWildPlant = 30;
                public double CollectGrownPlant = 5;
                public double BuildingBlockDeployed = 0;
                [JsonProperty("CatchCatfish")] // This was required due to the original field being FishCaught. 
                public double FishCaught = 100;
                public double CatchOrangeRoughy = 100;
                public double CatchSalmon = 100;
                public double CatchSmallShark = 100;
                public double CatchSmallTrout = 100;
                public double CatchYellowPerch = 100;
                public double CatchAnchovy = 100;
                public double CatchHerring = 100;
                public double CatchSardine = 100;
                public double CatchTrash = 50;
                public double Crafting = 0.25;
                public double ScientistNormal = 150;
                public double Scientist2 = 150;
                public double TunnelDweller = 125;
                public double UnderwaterDweller = 125;
                public double ScientistHeavy = 300;
                public double SmallAnimal = 20;
                public double MediumAnimal = 50;
                public double LargeAnimal = 100;
                public double RoadSign = 10;
                public double Barrel = 20;
                public double Scarecrow = 100;
                public double Mission = 1000;
                public double BradleyAPC = 1000;
                public double LootHackedCrate = 200;
                public double LootHeliCrate = 250;
                public double LootBradleyCrate = 50;
                public double CookingMealXP = 10;
                public double RaidableBaseCompletion_Easy = 100;
                public double RaidableBaseCompletion_Medium = 200;
                public double RaidableBaseCompletion_Hard = 300;
                public double RaidableBaseCompletion_Expert = 400;
                public double RaidableBaseCompletion_Nightmare = 500;
                public double Win_HungerGames = 2000;
                public double Win_ScubaArena = 2000;
                public double Win_Skirmish = 2000;
                public double Gut_Fish = 10;
                public double default_botrespawn = 100;
                public double crate_basic = 0;
                public double crate_elite = 50;
                public double crate_mine = 0;
                public double crate_normal = 0;
                public double crate_normal_2 = 0;
                public double crate_normal_2_food = 0;
                public double crate_normal_2_medical = 0;
                public double crate_tools = 0;
                public double crate_underwater_advanced = 100;
                public double crate_underwater_basic = 25;
                public double crate_ammunition = 0;
                public double crate_food_1 = 0;
                public double crate_food_2 = 0;
                public double crate_fuel = 0;
                public double crate_medical = 0;
                public double supply_drop = 500;
                public double detect_diggable = 100;
                public double Harbor_Event_Winner = 2000f;
                public double Junkyard_Event_Winner = 2000f;
                public double PowerPlant_Event_Winner = 2000f;
                public double Satellite_Event_Winner = 2000f;
                public double Water_Event_Winner = 2000f;
                public double Air_Event_Winner = 2000f;
                public double Armored_Train_Winner = 2000f;
                public double Convoy_Winner = 2000f;
                public double SurvivalArena_Winner = 2000f;
                public double swipe_card_level_1 = 50;
                public double swipe_card_level_2 = 100;
                public double swipe_card_level_3 = 250;
                public double boss_monster = 1000;
                public double Zombie = 100;
                public double Raider = 100;
                public double JetPilot = 100;
                public double ArcticBaseEvent_Winner = 2000f;
                public double GasStationEvent_Winner = 2000f;
                public double SputnikEvent_Winner = 2000f;
                public double ShipWreckEvent_Winner = 2000f;
                public double Triangulation_Winner = 2000f;
                public double Caravan_Winner = 2000f;
                public double SupermarketEvent_Winner = 2000f;
                public double GingerbreadNPC = 100f;
                public double PVP = 0;
                public double AutoTurret = 0;
            }

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        public class UISettings
        {
            [JsonProperty("Node UI Settings")]
            public NodeSettings nodeSettings = new NodeSettings();

            [JsonProperty("Buff Info Settings")]
            public BuffInfoSettings buffInfoSettings = new BuffInfoSettings();
        }

        public class NodeSettings
        {
            [JsonProperty("Node panel width")]
            public float width = 310;

            [JsonProperty("Space between each node in the UI")]
            public float NodeSpace = 10;

            [JsonProperty("Size of each node in the UI")]
            public float NodeSize = 58;

            [JsonProperty("Width of the vertical scroll bar on the nodes panel [0 = no bar]")]
            public float verticalScrollBarWidth = 2;

            [JsonProperty("Width of the horizontal scroll bar on the nodes panel [0 = no bar]")]
            public float horizontalScrollBarWidth = 2;
        }

        public class BuffInfoSettings
        {
            [JsonProperty("Width of the vertical scroll bar on the active buff info panel [0 = no bar]")]
            public float verticalScrollBarWidth = 2;
        }

        public class PermOverride
        {
            [JsonProperty("Dictionary of trees and their override values [case sensitive]")]
            public Dictionary<string, int> treeRequirementOverride = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            public PermOverride(Dictionary<string, int> treeRequirementOverride)
            {
                this.treeRequirementOverride = treeRequirementOverride;
            }
        }

        public class Permissions
        {
            public string description;
            public Dictionary<int, PermissionInfo> perms = new Dictionary<int, PermissionInfo>();

            public Permissions(string description, Dictionary<int, PermissionInfo> perms)
            {
                this.description = description;
                this.perms = perms;
            }
        }

        public class PermissionInfo
        {
            public Dictionary<string, string> perms_list = new Dictionary<string, string>();

            // Key = perm. Value = displayName.
            public PermissionInfo(Dictionary<string, string> perms_to_add)
            {
                this.perms_list = perms_to_add;
            }
        }

        public class LootItems
        {
            public string shortname;
            public int min;
            public int max;
            public int dropWeight;
            public string displayName;
            public ulong skin;
            public LootItems(string shortname, int min, int max, ulong skin = 0, string displayName = null, int dropWeight = 100)
            {
                this.shortname = shortname;
                this.min = min;
                this.max = max;
                this.skin = skin;
                this.displayName = displayName;
                this.dropWeight = dropWeight;
            }
        }

        public class PumpBar
        {
            [JsonProperty("Enable the xp bar?")]
            public bool enabled = true;

            [JsonProperty("Default xp bar offset - this is for any new player connecting to the server")]
            public xp_bar_offset offset_default = new xp_bar_offset()
            {
                min_x = -365.713f,
                min_y = 20f,
                max_x = -233.287f,
                max_y = 42f
            };

            [JsonProperty("Anchor points")]
            public XP_Bar_Anchors anchor_default = new XP_Bar_Anchors()
            {
                anchor_min = "1 0",
                anchor_max = "1 0"
            };

            [JsonProperty("Colour of the pump bar")]
            public string pump_bar_colour = "0.5471698 0.3533202 0 0.6078432";

            [JsonProperty("Colour of the pump bar when in xp debt")]
            public string pump_bar_colour_debt = "0.8 0 0 0.6078432";

            [JsonProperty("Font set for the pump bar")]
            public string pump_bar_font = "robotocondensed-regular.ttf";

            [JsonProperty("Font size for the pump bar")]
            public int pump_bar_font_size = 10;

            [JsonProperty("Pump bar formatting [1= (CurrentXP)/(TotalXP)] [2= (LevelCurrentXP)/(LevelTotalXP)] [3= (XPLeft) (%)]")]
            public int pump_bar_formatting = 2;

            [JsonProperty("Display the prestige image next to the pump bar?")]
            public bool displayPrestigeImg = false;
        }

        public class RaidingUltimate
        {
            [JsonProperty("Command to call in MLRS strike")]
            public string command = "strike";

            [JsonProperty("Use the actual MLRS entity to fire the payload?")]
            public bool use_real_MLRS_entity = false;

            [JsonProperty("Maximum duration that the Raiding Ultimate can be active for [seconds]")]
            public float max_duration = 30;

            [JsonProperty("Cooldown between uses [minutes]")]
            public float cooldown = 360;

            [JsonProperty("How long between each update tick when targeting [seconds]")]
            public float tick_interval = 1f;

            [JsonProperty("How many ticks are required for the targeting to be successful")]
            public int ticks_required = 5;

            [JsonProperty("How many rockets should be fired when the ultimate is successful")]
            public int missile_amount = 6;

            [JsonProperty("Effect to run when the target is successfully acquired [leave blank for no effect]")]
            public string missile_fire_confirmation_effect = "assets/prefabs/building/wall.frame.shopfront/effects/metal_transaction_complete.prefab";

            [JsonProperty("Effect to run each time a valid position is ticked up [leave blank for no effect]")]
            public string valid_position_effect = "assets/prefabs/gamemodes/objects/capturepoint/effects/capturepoint_progress_beep.prefab";

            [JsonProperty("Delay between each rocket when the barrage starts")]
            public float delay_between_rockets = 0.5f;

            [JsonProperty("Allow the Double_Explosion_chance buff to trigger with this ultimate?")]
            public bool allow_doubling = false;

            [JsonProperty("Reset the MLRS strike cool down on respec?")]
            public bool reset_strike_cooldown_on_respec = false;

            [JsonProperty("Only allow the ultimate to work in RaidableBase Zones?")]
            public bool raidable_bases_only = false;

            [JsonProperty("Blacklist of raidable base tier that the ultimate will not work in")]
            public HashSet<string> raidable_bases_mode_blacklist = new HashSet<string>();

            [JsonProperty("Prevent multiple players using the MLRS ability at the same location?")]
            public bool prevent_mlrs_spamming = true;

            [JsonProperty("Radius from the strike centre point that will disallow additional strikes")]
            public float prevention_radius = 60f;

            [JsonProperty("Time that strikes will be prevented in that location [seconds]")]
            public float prevention_duration = 1800;

            [JsonProperty("Require the player to have MLRS rockets in their inventory in order to use the ultimate?")]
            public bool require_ammo = false;

            [JsonProperty("Show time remaining to launch a strike")]
            public bool show_time_remaining = true;

            [JsonProperty("How long after a server is wiped should we prevent the MLRS ultimate from being used? [Hours]")]
            public float wipe_prevention_time = 2;
        }

        public class BuildCraftUltimate
        {
            [JsonProperty("Chance that a card with lower access will successfully unlock the door (the card is damaged regardless) [%]")]
            public int success_chance = 100;

            [JsonProperty("Notify the player when their ultimate failed")]
            public bool notify_fail = true;
        }

        public class SkinningUltimate
        {
            [JsonProperty("How long should each buff last for [0 = off]?")]
            public Dictionary<AnimalBuff, float> enabled_buffs = new Dictionary<AnimalBuff, float>();

            [JsonProperty("Wolf perk: what health scale bonus should the player receive per team member near by [1.0 is 100%]?")]
            public float wolf_health_scale = 0.25f;

            [JsonProperty("Wolf perk: How close do teammates need to be in order to contribute to the perk [radius]?")]
            public float wolf_team_dist = 30f;

            [JsonProperty("Bear perk: Maximum health of the overshield")]
            public float bear_overshield_max = 50f;

            [JsonProperty("Stag perk: Maximum distance that the perk can detect dangerous entities from [radius]")]
            public float stag_danger_dist = 30f;

            [JsonProperty("Stag perk: Time between procs [seconds]")]
            public float stag_timer = 10f;

            [JsonProperty("Stag perk: Draw the enemy location?")]
            public bool stag_draw_enemy = true;

            [JsonProperty("Boar perk: Blacklist of components for the boar buff")]
            public HashSet<string> boar_blackList = new HashSet<string>();

            [JsonProperty("Boar perk: Chance when collecting mushrooms and berries that a player [%]")]
            public float boar_chance = 2f;

            [JsonProperty("Boar perk: Minimum quantity to give")]
            public int boar_min_quantity = 1;

            [JsonProperty("Boar perk: Maximum quantity to give")]
            public int boar_max_quantity = 4;

            [JsonProperty("Anchor points for the stag danger UI icon")]
            public AnchorSettings stag_danger_icon_anchor = new AnchorSettings("0.5 0", "0.5 0", "-201.4 87.6", "33.4 107.6");

            [JsonProperty("Anchor points for the bear overshield UI")]
            public AnchorSettings overshield_anchor = new AnchorSettings("0.5 0", "0.5 0", "-201.4 87.6", "-97.4 107.6");
        }

        public class AnchorSettings
        {
            public string anchorMin;
            public string anchorMax;
            public string offsetMin;
            public string offsetMax;
            public AnchorSettings(string anchorMin, string anchorMax, string offsetMin, string offsetMax)
            {
                this.anchorMin = anchorMin;
                this.anchorMax = anchorMax;
                this.offsetMin = offsetMin;
                this.offsetMax = offsetMax;
            }
        }

        public class CookingUltimate
        {
            [JsonProperty("Command to activate the buff")]
            public string command = "teatime";

            [JsonProperty("Cooldown between uses [minutes]")]
            public float buff_cooldown = 240;

            [JsonProperty("Apply modifiers even if the player has an existing buff of the same type with a higher modifier?")]
            public bool override_better_mod = false;

            [JsonProperty("Apply modifiers even if the player has an existing buff of the same type with a longer duration?")]
            public bool override_better_duration = true;

            [JsonProperty("Modifiers that the player will receive when the buff is used")]
            public Dictionary<Modifier.ModifierType, ModifierValues> tea_mods = new Dictionary<Modifier.ModifierType, ModifierValues>();

            public class ModifierValues
            {
                [JsonProperty("Duration [seconds]")]
                public float duration;
                [JsonProperty("Modifier [1.0 = 100%]")]
                public float modifier;

                public ModifierValues(float duration, float modifier)
                {
                    this.duration = duration;
                    this.modifier = modifier;
                }
            }
        }

        public class CombatUltimate
        {
            [JsonProperty("What scale of damage should the player receive as health [1.0 = 100%]")]
            public float health_scale = 0.01f;

            [JsonProperty("Should the healing effect of the ultimate work against players")]
            public bool players_enabled = true;

            [JsonProperty("Should the healing effect of the ultimate work against animals")]
            public bool animals_enabled = true;

            [JsonProperty("Should the healing effect of the ultimate work against scientists")]
            public bool scientists_enabled = true;

            [JsonProperty("List of weapon prefabs (not items) that will not trigger the heal")]
            public HashSet<string> weapon_blacklist = new HashSet<string>();

            [JsonProperty("Allow fire based damage to heal players?")]
            public bool heal_from_fire_damage = false;
        }

        public class Scav_Ultimate
        {
            [JsonProperty("List of items that you dont want the perk to recycle")]
            public HashSet<string> item_blacklist = new HashSet<string>();

            [JsonProperty("Scrap items that have a unique name?")]
            public bool scrap_named_items = false;

            [JsonProperty("Scrap items that have a unique text field?")]
            public bool scrap_text_items = false;

            [JsonProperty("Scrap items that have a non-default skin?")]
            public bool scrap_skinned_items = false;
        }

        public class HarvesterUltimate
        {
            [JsonProperty("Chat command that players can use to set their plant genes")]
            public string gene_chat_command = "setgenes";

            [JsonProperty("Cooldown between ultimate triggers. Set to 0 if you want all plants to have their genes adjusted [seconds]")]
            public float cooldown = 0f;

            [JsonProperty("Notify a player in chat when they go on cooldown (recommended for longer cooldowns)")]
            public bool notify_on_cooldown = true;

            [JsonProperty("List of item shortnames to blacklist [example: seed.hemp]")]
            public HashSet<string> blacklist = new HashSet<string>();
        }

        public class MedicalUltimate
        {
            [JsonProperty("Chance for the player to resurrect [out of 100]")]
            public float resurrection_chance = 50f;

            [JsonProperty("Delay between resurrections after a successful resurrection [seconds]")]
            public float resurrection_delay = 1200f;

            [JsonProperty("Prevent the button being sent when a player kills themselves or is the aggressor of their own death?")]
            public bool prevent_on_suicide = true;

            [JsonProperty("Allow this skill to function if the player died in pvp?")]
            public bool allow_in_pvp_death = true;
        }

        public class VehicleUltimate
        {
            [JsonProperty("Prevent damage from samsites?")]
            public bool prevent_damage_from_sams = true;
        }

        public class WoodcuttingUltimate
        {
            [JsonProperty("Award xp for each tree that the perk cuts down?")]
            public bool award_xp = false;

            [JsonProperty("Distance from the player (radius) that trees will be cut down?")]
            public float distance_from_player = 10f;

            [JsonProperty("Cooldown between uses [seconds]")]
            public float cooldown_between_uses = 0f;
        }

        public class MiningUltimate
        {
            [JsonProperty("Distance from the player (radius) that nodes will appear (radius)")]
            public float distance_from_player = 200f;

            [JsonProperty("Cooldown time on the ability (seconds)")]
            public float cooldown = 60f;

            [JsonProperty("How many seconds should the marked ores appear on the players hud?")]
            public float hud_time = 60f;

            [JsonProperty("Text size")]
            public int text_size = 12;

            [JsonProperty("Chat command to find the nodes.")]
            public string find_node_cmd = "locatenodes";

            [JsonProperty("Automatically trigger the mining ultimate when the player equips a pickaxe (still abides by the cooldown time)")]
            public bool trigger_on_item_change = false;

            [JsonProperty("UI Colour for sulfur nodes [0:red, 1:green, 2:blue, 3:white, 4:black, 5:yellow, 6:cyan, 7:magenta]")]
            public int sulfur_colour = 5;

            [JsonProperty("UI Colour for metal nodes [0:red, 1:green, 2:blue, 3:white, 4:black, 5:yellow, 6:cyan, 7:magenta]")]
            public int metal_colour = 0;

            [JsonProperty("UI Colour for stone nodes [0:red, 1:green, 2:blue, 3:white, 4:black, 5:yellow, 6:cyan, 7:magenta]")]
            public int stone_colour = 6;

            [JsonProperty("Show the player the distance of the node?")]
            public bool show_distance = true;

            [JsonProperty("List of tools to trigger the ultimate")]
            public HashSet<string> tools_list = new HashSet<string>();
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();
            config.level.CalculateTable(config.general_settings.max_player_level > 0 ? config.general_settings.max_player_level : 100);
            config.trees = DefaultTrees;

            config.general_settings.level_rewards.Add(100, new LevelReward(new Dictionary<string, string>() { ["say <color=#ffae00>{name}</color> reached level <color=#4cff03>100</color>!"] = "You have reached a milestone level!" }, new HashSet<string>() { "say Test data reset." }));

            config.tools_black_white_list_settings.wc_tools = new HashSet<string>()
            {
                "hatchet", "axe.salvaged", "stonehatchet", "chainsaw"
            };

            config.ultimate_settings.ultimate_mining.tools_list = DefaultUltimateToolsList;

            config.tools_black_white_list_settings.mining_tools = new HashSet<string>()
            {
                "pickaxe", "stone.pickaxe", "icepick.salvaged", "jackhammer"
            };

            config.tools_black_white_list_settings.skinning_tools = new HashSet<string>()
            {
                "knife.bone", "knife.butcher", "knife.combat", "hatchet"
            };

            config.loot_settings.mining_loot_table = DefaultLootItems;

            config.loot_settings.wc_loot_table = DefaultLootItems;

            config.loot_settings.skinning_loot_table = DefaultLootItems;

            config.loot_settings.fishing_loot_table = DefaultLootItems;

            config.loot_settings.metal_detector_loot_table = DefaultLootItems;

            config.loot_settings.harvesting_loot_table_wild = DefaultLootItems;
            config.loot_settings.harvesting_loot_table_grown = DefaultLootItems;

            config.tools_black_white_list_settings.electricalComponentSettings.comp_blacklist = new HashSet<string>() { "generic", "chassis", "glue", "bleach", "ducttape", "sticks", "vehicle.chassis", "vehicle.module", "vehicle.chassis.4mod", "vehicle.chassis.3mod", "vehicle.chassis.2mod", "electric.generator.small" };

            config.buff_settings.primitive_weapons = new HashSet<string>() { "spear.stone", "spear.wooden", "bone.club", "bow.hunting" };

            config.buff_settings.animals = new HashSet<string>() { "boar", "horse", "stag", "chicken", "wolf", "wolf2", "bear", "scarecrow", "polarbear", "tiger", "panther", "crocodile", "snake.entity" };

            config.loot_settings.loot_crate_whitelist = new HashSet<string>()
            {
                "assets/bundled/prefabs/radtown/crate_elite.prefab",
                "assets/bundled/prefabs/radtown/crate_basic.prefab",
                "assets/bundled/prefabs/radtown/crate_normal.prefab",
                "assets/bundled/prefabs/radtown/crate_normal_2.prefab",
                "assets/bundled/prefabs/radtown/crate_tools.prefab",
                "assets/bundled/prefabs/radtown/crate_underwater_advanced.prefab",
                "assets/bundled/prefabs/radtown/underwater_labs/crate_elite.prefab",
                "assets/bundled/prefabs/radtown/underwater_labs/crate_normal.prefab",
                "assets/bundled/prefabs/radtown/underwater_labs/crate_normal_2.prefab",
                "assets/bundled/prefabs/radtown/underwater_labs/crate_tools.prefab",
                "assets/bundled/prefabs/radtown/crate_normal_2_food.prefab",
                "assets/bundled/prefabs/radtown/crate_normal_2_medical.prefab",
                "assets/bundled/prefabs/radtown/underwater_labs/crate_food_1.prefab",
                "assets/bundled/prefabs/radtown/underwater_labs/crate_food_2.prefab",
                "assets/bundled/prefabs/radtown/underwater_labs/crate_fuel.prefab",
                "assets/bundled/prefabs/radtown/underwater_labs/crate_medical.prefab",
                "assets/bundled/prefabs/radtown/underwater_labs/vehicle_parts.prefab"
            };

            config.tools_black_white_list_settings.black_listed_gather_items = new HashSet<string>() { "bone.club" };

            config.general_settings.respec_cost_override.Add("vip", Math.Round(config.general_settings.respec_cost / 2, 0));
            config.general_settings.max_skill_points_override.Add("vip", config.general_settings.max_skill_points + (Convert.ToInt32(config.general_settings.max_skill_points * 0.2)));
            config.general_settings.max_skill_points_override.Add("nolimit", 0);
            config.xp_settings.xp_loss_settings.xp_loss_override.Add("vip", 0.5);
            config.xp_settings.xp_perm_modifier.Add("vip", 1.0);

            config.buff_settings.no_refund_item_skins = new HashSet<ulong>() { 2529344523, 2546992444, 2546992685 };
            config.ultimate_settings.ultimate_scavenger.item_blacklist = DefaultScavengerUltimateBlacklist;
            config.ultimate_settings.ultimate_skinning.enabled_buffs = DefaultAnimalBuffs;

            config.xp_settings.cooking_black_list = new HashSet<string>() { "ingredient bag" };

            config.buff_settings.durability_blacklist = DefaultDurabilityBlacklist;

            config.buff_settings.tea_looter_settings.TeaDropTable = DefaultTeaWeights;
            config.buff_settings.tea_looter_settings.containers = DefaultTeaContainers;
            config.buff_settings.forager_settings.displayColours = DefaultForagerColours;
            config.ultimate_settings.ultimate_cooking.tea_mods = DefaultCookingUltimateMods;

            config.buff_settings.raid_perk_settings.Trap_Spotter_settings.trap_colours = DefaultSpotterCols;
            config.misc_settings.videoURLs = DefaultUrls;

            LoadDefaultPrestige();
        }

        Dictionary<Buff, string> DefaultUrls
        {
            get
            {
                return new Dictionary<Buff, string>()
                {
                    [Buff.Woodcutting_Ultimate] = "https://files.catbox.moe/ahtv9q.mp4",
                    [Buff.Instant_Mine] = "https://files.catbox.moe/kmjmw3.mp4",
                    [Buff.Mining_Ultimate] = "https://files.catbox.moe/wm6ps4.mp4",
                    [Buff.Mining_Hotspot] = "https://files.catbox.moe/fq96lp.mp4",
                    [Buff.Node_Spawn_Chance] = "https://files.catbox.moe/chtktm.mp4",
                    [Buff.Regrowth] = "https://files.catbox.moe/azp0wq.mp4",
                    [Buff.Instant_Chop] = "https://files.catbox.moe/wz15hz.mp4",
                    [Buff.Woodcutting_Hotspot] = "https://files.catbox.moe/8yrygo.mp4",
                    [Buff.AnimalTracker] = "https://files.catbox.moe/4jmrhj.mp4",
                    [Buff.Instant_Skin] = "https://files.catbox.moe/j2jyxx.mp4",
                    [Buff.Bite_Speed] = "https://files.catbox.moe/0dga8w.mp4",
                    [Buff.Rod_Tension_Bonus] = "https://files.catbox.moe/o6dqrj.mp4",
                    [Buff.Forager] = "https://files.catbox.moe/tlkiel.mp4",
                    [Buff.Wounded_Resist] = "https://files.catbox.moe/5gsb1w.mp4",
                    [Buff.Harvester_Ultimate] = "https://files.catbox.moe/w2cxt2.mp4",
                    [Buff.Medical_Ultimate] = "https://files.catbox.moe/y5ly4j.mp4",
                    [Buff.Awareness] = "https://files.catbox.moe/bmclck.mp4",
                    [Buff.Loot_Pickup] = "https://files.catbox.moe/t11plq.mp4",
                    [Buff.Build_Craft_Ultimate] = "https://files.catbox.moe/evxtd1.mp4",
                    [Buff.Barrel_Smasher] = "https://files.catbox.moe/doiqvg.mp4",
                    [Buff.Magnetic_Digger] = "https://files.catbox.moe/q2dcdz.mp4",
                    [Buff.Efficient_Digger] = "https://files.catbox.moe/eui0ud.mp4",
                    [Buff.Scavengers_Ultimate] = "https://files.catbox.moe/68k7td.mp4",
                    [Buff.Riding_Speed] = "https://files.catbox.moe/8nnif6.mp4",
                    [Buff.Boat_Speed] = "https://files.catbox.moe/yf631x.mp4",
                    [Buff.Heli_Speed] = "https://files.catbox.moe/0gcq3m.mp4",
                    [Buff.Vehicle_Mechanic] = "https://files.catbox.moe/po2m1o.mp4",
                    [Buff.BikeEnginePower] = "https://files.catbox.moe/kf9upt.mp4",
                    [Buff.Cooking_Ultimate] = "https://files.catbox.moe/t961aq.mp4",
                    [Buff.WaterBreathing] = "https://files.catbox.moe/obw3da.mp4",
                    [Buff.Rationer] = "https://files.catbox.moe/lg70s7.mp4",
                    [Buff.Sonar] = "https://files.catbox.moe/cp8m9m.mp4",
                    [Buff.Vehicle_Ultimate] = "https://files.catbox.moe/hg5zk3.mp4",
                    [Buff.InstantUntie] = "https://files.catbox.moe/t1vntn.mp4",
                    [Buff.Dudless_Explosive] = "https://files.catbox.moe/cq5vbq.mp4",
                    [Buff.Double_Explosion_Chance] = "https://files.catbox.moe/ual4ai.mp4",
                    [Buff.Explosion_Radius] = "https://files.catbox.moe/jsmslv.mp4",
                    [Buff.Trap_Spotter] = "https://files.catbox.moe/bt7z17.mp4",
                    [Buff.Raiding_Ultimate] = "https://files.catbox.moe/3h4qwd.mp4",
                    [Buff.Human_Workbench] = "https://files.catbox.moe/ujlesy.mp4",
                    [Buff.Lock_Picker] = "https://files.catbox.moe/ixodix.mp4",
                };
            }
        }

        //Dictionary<Buff, string> DefaultUrls
        //{
        //    get
        //    {
        //        return new Dictionary<Buff, string>()
        //        {
        //            [Buff.Woodcutting_Ultimate] = "https://ia902304.us.archive.org/31/items/Deforest/Deforest.mp4",
        //            [Buff.Instant_Mine] = "https://ia904601.us.archive.org/5/items/mining-ultimate/InstantMining.mp4",
        //            [Buff.Mining_Ultimate] = "https://ia904601.us.archive.org/5/items/mining-ultimate/MiningUltimate.mp4",
        //            [Buff.Mining_Hotspot] = "https://ia600608.us.archive.org/13/items/mining-hotspot/MiningHotspot.mp4",
        //            [Buff.Node_Spawn_Chance] = "https://archive.org/download/node-spawn-chance/NodeSpawnChance.mp4",
        //            [Buff.Regrowth] = "https://archive.org/download/Regrowth/Regrowth.mp4",
        //            [Buff.Instant_Chop] = "https://archive.org/download/Regrowth/InstantWoodcut.mp4",
        //            [Buff.Woodcutting_Hotspot] = "https://archive.org/download/Regrowth/WoodcuttingHotspot.mp4",
        //            [Buff.AnimalTracker] = "https://archive.org/download/animal-tracking/AnimalTracking.mp4",
        //            [Buff.Instant_Skin] = "https://archive.org/download/instant-skin/InstantSkin.mp4",
        //            [Buff.Bite_Speed] = "https://archive.org/download/hook-speed/HookSpeed.mp4",
        //            [Buff.Rod_Tension_Bonus] = "https://archive.org/download/hook-speed/LineStrength.mp4",
        //            [Buff.Forager] = "https://archive.org/download/hook-speed/ForagersIntuition.mp4",
        //            [Buff.Wounded_Resist] = "https://archive.org/download/harvesting-ultimate/SecondWind.mp4",
        //            [Buff.Harvester_Ultimate] = "https://archive.org/download/harvesting-ultimate/HarvestingUltimate.mp4",
        //            [Buff.Medical_Ultimate] = "https://archive.org/download/messiah_202501/Messiah.mp4",
        //            [Buff.Awareness] = "https://archive.org/download/sixth-sense_202501/SixthSense.mp4",
        //            [Buff.Loot_Pickup] = "https://archive.org/download/access-granted_202501/LootMagnet.mp4",
        //            [Buff.Build_Craft_Ultimate] = "https://archive.org/download/access-granted_202501/AccessGranted.mp4",
        //            [Buff.Barrel_Smasher] = "https://archive.org/download/access-granted_202501/BarrelSmasher.mp4",
        //            [Buff.Magnetic_Digger] = "https://archive.org/download/magnetic-digger/MagneticDigger.mp4",
        //            [Buff.Efficient_Digger] = "https://archive.org/download/digger_202501/Digger.mp4",
        //            [Buff.Scavengers_Ultimate] = "https://archive.org/download/horse-speed/Shredder.mp4",
        //            [Buff.Riding_Speed] = "https://archive.org/download/horse-speed/HorseSpeed.mp4",
        //            [Buff.Boat_Speed] = "https://archive.org/download/heli-speed/BoatSpeed.mp4",
        //            [Buff.Heli_Speed] = "https://archive.org/download/heli-speed/HeliSpeed.mp4",
        //            [Buff.Vehicle_Mechanic] = "https://archive.org/download/heli-speed/Mechanic.mp4",
        //            [Buff.BikeEnginePower] = "https://archive.org/download/heli-speed/MotorbikeSpeed.mp4",
        //            [Buff.Cooking_Ultimate] = "https://archive.org/download/sonar_202501/CookingUltimate.mp4",
        //            [Buff.WaterBreathing] = "https://archive.org/download/sonar_202501/Gilled.mp4",
        //            [Buff.Rationer] = "https://archive.org/download/sonar_202501/FruggalRationer.mp4",
        //            [Buff.Sonar] = "https://archive.org/download/sonar_202501/Sonar.mp4",
        //            [Buff.Vehicle_Ultimate] = "https://archive.org/download/sonar_202501/Tank.mp4",
        //            [Buff.InstantUntie] = "https://archive.org/download/instant-untie/InstantUntie.mp4",
        //            [Buff.Dudless_Explosive] = "https://archive.org/download/reliable-explosives/ReliableExplosives.mp4",
        //            [Buff.Double_Explosion_Chance] = "https://archive.org/download/demolition_202501/Demolition.mp4",
        //            [Buff.Explosion_Radius] = "https://archive.org/download/demolition_202501/ExplosionRadius.mp4",
        //            [Buff.Trap_Spotter] = "https://archive.org/download/raiding-ultimate/TrapDetector.mp4",
        //            [Buff.Raiding_Ultimate] = "https://archive.org/download/raiding-ultimate/RaidingUltimate.mp4",
        //            [Buff.Human_Workbench] = "https://archive.org/download/craftsmans-aura/CraftsmansAura.mp4",
        //            [Buff.Lock_Picker] = "https://archive.org/download/picklock_202501/Picklock.mp4",
        //        };
        //    }
        //}

        void LoadDefaultPrestige()
        {
            config.prestige_settings.Initialize();
        }

        Dictionary<Modifier.ModifierType, CookingUltimate.ModifierValues> DefaultCookingUltimateMods
        {
            get
            {
                return new Dictionary<Modifier.ModifierType, CookingUltimate.ModifierValues>()
                {
                    [Modifier.ModifierType.Max_Health] = new CookingUltimate.ModifierValues(3600, 0.2f),
                    [Modifier.ModifierType.Ore_Yield] = new CookingUltimate.ModifierValues(3600, 0.5f),
                    [Modifier.ModifierType.Radiation_Exposure_Resistance] = new CookingUltimate.ModifierValues(3600, 0.5f),
                    [Modifier.ModifierType.Radiation_Resistance] = new CookingUltimate.ModifierValues(3600, 0.5f),
                    [Modifier.ModifierType.Scrap_Yield] = new CookingUltimate.ModifierValues(3600, 4),
                    [Modifier.ModifierType.Wood_Yield] = new CookingUltimate.ModifierValues(3600, 2)
                };
            }
        }

        [ConsoleCommand("addleveloverride")]
        void AddLevelOverride(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, perm_admin)) return;
            if (!config.general_settings.level_requirement_override.IsNullOrEmpty())
            {
                arg.ReplyWith("There is already data in the Level requirement override field.");
                return;
            }

            config.general_settings.level_requirement_override = DefaultLevelPermOverride;
            SaveConfig();
            arg.ReplyWith("Added entry for level requirement override to the config.");
        }

        Dictionary<string, PermOverride> DefaultLevelPermOverride
        {
            get
            {
                return new Dictionary<string, PermOverride>()
                {
                    ["skilltree.minleveloverride"] = new PermOverride(new Dictionary<string, int>()
                    {
                        ["Raiding"] = 10
                    })
                };
            }
        }

        [ConsoleCommand("addpointoverride")]
        void AddPointOverride(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, perm_admin)) return;
            if (!config.general_settings.point_requirement_override.IsNullOrEmpty())
            {
                arg.ReplyWith("There is already data in the Level requirement override field.");
                return;
            }

            config.general_settings.point_requirement_override = DefaultPointPermOverride;
            SaveConfig();
            arg.ReplyWith("Added entry for point requirement override to the config.");
        }

        Dictionary<string, PermOverride> DefaultPointPermOverride
        {
            get
            {
                return new Dictionary<string, PermOverride>()
                {
                    ["skilltree.minpointsoverride"] = new PermOverride(new Dictionary<string, int>()
                    {
                        ["Raiding"] = 10
                    })
                };
            }
        }

        Dictionary<string, float[]> DefaultForagerColours
        {
            get
            {
                return new Dictionary<string, float[]>()
                {
                    ["hemp-collectable"] = new float[3] { 0.0965f, 0.550f, 0.0165f },
                    ["corn-collectable"] = new float[3] { 0.906f, 0.920f, 0.101f },
                    ["pumpkin-collectable"] = new float[3] { 0.840f, 0.547f, 0.0420f },
                    ["potato-collectable"] = new float[3] { 0.360f, 0.245f, 0.0468f },
                    ["berry-blue-collectable"] = new float[3] { 0.0670f, 0.600f, 0.670f },
                    ["berry-green-collectable"] = new float[3] { 0.0315f, 0.450f, 0.0385f },
                    ["berry-yellow-collectable"] = new float[3] { 0.710f, 0.699f, 0.0355f },
                    ["berry-red-collectable"] = new float[3] { 0.720f, 0.0360f, 0.253f },
                    ["berry-white-collectable"] = new float[3] { 1f, 1f, 1f },
                    ["diesel_collectable"] = new float[3] { 0.940f, 0.681f, 0.423f },
                    ["mushroom-cluster-5"] = new float[3] { 0.530f, 0.265f, 0.349f },
                    ["mushroom-cluster-6"] = new float[3] { 0.530f, 0.265f, 0.349f },
                    ["sulfur-collectable"] = new float[3] { 0.630f, 0.515f, 0.101f },
                    ["metal-collectable"] = new float[3] { 0.320f, 0.314f, 0.294f },
                    ["stone-collectable"] = new float[3] { 0.440f, 0.435f, 0.418f },
                    ["wood-collectable"] = new float[3] { 0.250f, 0.225f, 0.135f },
                    ["orchid-collectable"] = new float[3] { 0.250f, 0.225f, 0.135f },
                    ["rose-collectable"] = new float[3] { 0.250f, 0.225f, 0.135f },
                    ["sunflower-collectable"] = new float[3] { 0.250f, 0.225f, 0.135f },
                };
            }
        }

        Dictionary<string, int> DefaultTeaWeights
        {
            get
            {
                return new Dictionary<string, int>()
                {
                    ["radiationresisttea"] = 100,
                    ["radiationresisttea.advanced"] = 100,
                    ["radiationresisttea.pure"] = 100,
                    ["healingtea"] = 100,
                    ["healingtea.advanced"] = 100,
                    ["healingtea.pure"] = 100,
                    ["maxhealthtea"] = 100,
                    ["maxhealthtea.advanced"] = 100,
                    ["maxhealthtea.pure"] = 100,
                    ["oretea"] = 100,
                    ["oretea.advanced"] = 100,
                    ["oretea.pure"] = 100,
                    ["radiationremovetea"] = 100,
                    ["radiationremovetea.advanced"] = 100,
                    ["radiationremovetea.pure"] = 100,
                    ["scraptea"] = 100,
                    ["scraptea.advanced"] = 100,
                    ["scraptea.pure"] = 100,
                    ["woodtea"] = 100,
                    ["woodtea.advanced"] = 100,
                    ["woodtea.pure"] = 100
                };
            }
        }

        HashSet<string> DefaultTeaContainers
        {
            get
            {
                return new HashSet<string>()
                {
                    "crate_normal_2_food",
                    "invisible_crate_normal_2_food",
                    "crate_food_1",
                    "crate_food_2",
                    "wagon_crate_normal_2_food",
                    "foodbox",
                    "invisible_foodbox",
                    "dmfood"
                };
            }
        }

        HashSet<string> DefaultDurabilityBlacklist
        {
            get
            {
                return new HashSet<string>()
                {
                    "keycard_blue",
                    "keycard_red",
                    "keycard_green"
                };
            }
        }

        HashSet<string> DefaultDoubpleExplosionList
        {
            get
            {
                return new HashSet<string>()
                {
                    "rocket_basic",
                    "40mm_grenade_he",
                    "rocket_hv",
                    "grenade.beancan.entity"
                };
            }
        }

        HashSet<string> DefaultUltimateToolsList
        {
            get
            {
                return new HashSet<string>()
                {
                    "pickaxe", "stone.pickaxe", "icepick.salvaged", "jackhammer"
                };
            }
        }

        List<LootItems> DefaultLootItems
        {
            get
            {
                return new List<LootItems>()
                {
                    new LootItems("keycard_blue", 1, 1),
                    new LootItems("keycard_green", 1, 1),
                    new LootItems("keycard_red", 1, 1),
                    new LootItems("lowgradefuel", 1, 10)
                };
            }
        }

        public class LevelReward
        {
            [JsonProperty("List of commands and chat messages that the player receives when reaching the specified level [Left = command. Right = Private message to player]. {id} = steam ID. {name} == name.")]
            public Dictionary<string, string> reward_commands = new Dictionary<string, string>();

            [JsonProperty("List of commands that are fired off when the player data is reset")]
            public HashSet<string> reset_commands = new HashSet<string>();

            public LevelReward(Dictionary<string, string> reward_commands, HashSet<string> reset_commands = null)
            {
                this.reward_commands = reward_commands;
                this.reset_commands = reset_commands;
            }
        }

        Dictionary<string, float> DefaultUnderwaterChance
        {
            get
            {
                return new Dictionary<string, float>()
                {
                    ["assets/bundled/prefabs/radtown/underwater_labs/crate_elite.prefab"] = 5f,
                    ["assets/bundled/prefabs/radtown/underwater_labs/crate_normal.prefab"] = 5f,
                    ["assets/bundled/prefabs/radtown/underwater_labs/crate_normal_2.prefab"] = 5f,
                    ["assets/bundled/prefabs/radtown/crate_underwater_advanced.prefab"] = 5f,
                    ["assets/bundled/prefabs/radtown/crate_underwater_basic.prefab"] = 5f
                };
            }
        }

        List<LootItems> GetSharkLoot()
        {
            if (SharkLootTable == null)
            {
                List<LootItems> loot = new List<LootItems>();
                foreach (var item in GetCleanItemDefinitions())
                    if (!config.buff_settings.SharkSkinnerblacklist.Contains(item.shortname)) loot.Add(new LootItems(item.shortname, 1, item.isWearable ? 1 : item.isHoldable ? 1 : UnityEngine.Random.Range(2, 5)));
                SharkLootTable = loot;
            }
            return SharkLootTable;
        }

        public Dictionary<string, List<LootItems>> DeepSeaLooterLootTable;
        public List<LootItems> SharkLootTable;

        Dictionary<string, List<LootItems>> GetUnderwaterLoot()
        {
            Dictionary<string, List<LootItems>> result = new Dictionary<string, List<LootItems>>();

            List<LootItems> items = new List<LootItems>();

            foreach (var item in GetCleanItemDefinitions().Where(x => x.category == ItemCategory.Component))
                items.Add(new LootItems(item.shortname, 1, 3));

            result.Add("assets/bundled/prefabs/radtown/crate_underwater_basic.prefab", items);
            result.Add("assets/bundled/prefabs/radtown/underwater_labs/crate_normal_2.prefab", items);
            result.Add("assets/bundled/prefabs/radtown/underwater_labs/crate_normal.prefab", items);

            foreach (var item in GetCleanItemDefinitions().Where(x => x.category == ItemCategory.Electrical || x.category == ItemCategory.Weapon || x.category == ItemCategory.Attire))
            {
                if (item.category == ItemCategory.Attire || item.category == ItemCategory.Weapon) items.Add(new LootItems(item.shortname, 1, 1));
                else items.Add(new LootItems(item.shortname, 1, 3));
            }
            result.Add("assets/bundled/prefabs/radtown/crate_underwater_advanced.prefab", items);
            result.Add("assets/bundled/prefabs/radtown/underwater_labs/crate_elite.prefab", items);

            return result;
        }

        public const int UltimateLevel = 100;

        Dictionary<string, Configuration.TreeInfo> DefaultTrees
        {
            get
            {
                return new Dictionary<string, Configuration.TreeInfo>()
                {
                    ["Mining"] = new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()
                    {
                        ["Amature Miner"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Mining_Yield, BuffType.Percentage), "https://www.dropbox.com/s/dajctapqtv8bt4z/Amature_Miner.png?dl=1", 2873965665),
                        ["Stroke of luck"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Node_Spawn_Chance, BuffType.Percentage), "https://www.dropbox.com/s/ym4bktn12jr6t4p/Stroke_of_Luck.png?dl=1", 2873042230),
                        ["Adept Miner"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.075f, new KeyValuePair<Buff, BuffType>(Buff.Mining_Yield, BuffType.Percentage), "https://www.dropbox.com/s/pon14r7e6bvn2kd/Adept_Miner.png?dl=1", 2873042840),
                        ["Instant Mining"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Instant_Mine, BuffType.Percentage), "https://www.dropbox.com/s/x3awxx2vkfun2io/Instant_Mining.png?dl=1", 2873042968),
                        ["Mining Luck"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.01f, new KeyValuePair<Buff, BuffType>(Buff.Mining_Luck, BuffType.Percentage), "https://www.dropbox.com/s/uk7oix7ojnsqyjh/Mining_Luck.png?dl=1", 2873043145),
                        ["Expert Miner"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Mining_Yield, BuffType.Percentage), "https://www.dropbox.com/s/rgoj7fey7xvzrgk/Expert_Miner.png?dl=1", 2873043244),
                        ["Refiner"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Smelt_On_Mine, BuffType.Percentage), "https://www.dropbox.com/s/wbsgo1egl10dwcx/Refiner.png?dl=1", 2873043347),
                        ["Robust pickaxe"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Mining_Tool_Durability, BuffType.Percentage), "https://www.dropbox.com/s/j4nnel0lzonhu9b/Robust_pickaxe.png?dl=1", 2873043495),
                        ["Stone Sense"] = new Configuration.TreeInfo.NodeInfo(true, 1, UltimateLevel, 1f, new KeyValuePair<Buff, BuffType>(Buff.Mining_Ultimate, BuffType.IO), "https://www.dropbox.com/s/kkge1vpuptc37z4/Stone_Sense.png?dl=1", 2873043666),
                        ["Efficient Miner"] = new Configuration.TreeInfo.NodeInfo(true, 1, 2, 1f, new KeyValuePair<Buff, BuffType>(Buff.Mining_Hotspot, BuffType.IO), "https://www.dropbox.com/s/xgyvuu1x28u22js/Mining_Hotspot.v1.png?dl=1", 2987629553),
                    }),
                    ["Woodcutting"] = new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()
                    {

                        ["Amature Woodcutter"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Woodcutting_Yield, BuffType.Percentage), "https://www.dropbox.com/s/2s89vo3bmqyefux/Amature_Woodcutter.png?dl=1", 2873043851),
                        ["Adept Woodcutter"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.075f, new KeyValuePair<Buff, BuffType>(Buff.Woodcutting_Yield, BuffType.Percentage), "https://www.dropbox.com/s/nf9reuenek59a6y/Adept_Woodcutter.png?dl=1", 2873043965),
                        ["Instant Woodcutting"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Instant_Chop, BuffType.Percentage), "https://www.dropbox.com/s/7vut5y0vub9e05c/Instant_Woodcutting.png?dl=1", 2873044070),
                        ["Woodcutting Luck"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.01f, new KeyValuePair<Buff, BuffType>(Buff.Woodcutting_Luck, BuffType.Percentage), "https://www.dropbox.com/s/6acfo7hlj0sxviq/Woodcutters_Luck.png?dl=1", 2873044171),
                        ["Efficient Lumberjack"] = new Configuration.TreeInfo.NodeInfo(true, 1, 2, 1f, new KeyValuePair<Buff, BuffType>(Buff.Woodcutting_Hotspot, BuffType.Percentage), "https://www.dropbox.com/s/8zmb3b99qqqfc7p/Woodcutting_Hotspot.v1.png?dl=1", 2987395716),
                        ["Expert Woodcutter"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Woodcutting_Yield, BuffType.Percentage), "https://www.dropbox.com/s/tzlbixc5ufbxqjs/Expert_Woodcutter.png?dl=1", 2873044270),
                        ["Chimney"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Woodcutting_Coal, BuffType.Percentage), "https://www.dropbox.com/s/d8ovy2trv5tuipw/Chimney.png?dl=1", 2873044493),
                        ["Tree Regrowth"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.025f, new KeyValuePair<Buff, BuffType>(Buff.Regrowth, BuffType.Percentage), "https://www.dropbox.com/s/kbyk4nhzu7akmhb/Tree_Regrowth.png?dl=1", 2874292571),
                        ["Robust Axe"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Woodcutting_Tool_Durability, BuffType.Percentage), "https://www.dropbox.com/s/4p5gqo7fbfaw9jz/Robust_Axe.png?dl=1", 2873044601),
                        ["Deforestation"] = new Configuration.TreeInfo.NodeInfo(true, 1, UltimateLevel, 1f, new KeyValuePair<Buff, BuffType>(Buff.Woodcutting_Ultimate, BuffType.IO), "https://www.dropbox.com/s/tww0gg1pwh90qbb/Deforestation.png?dl=1", 2873044743)
                    }),
                    ["Skinning"] = new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()
                    {
                        ["Amature Skinner"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Skinning_Yield, BuffType.Percentage), "https://www.dropbox.com/s/dxrecqcjlsaqskm/Amature_Skinner.png?dl=1", 2873044870),
                        ["Skilled Tracker"] = new Configuration.TreeInfo.NodeInfo(true, 1, 1, 1f, new KeyValuePair<Buff, BuffType>(Buff.AnimalTracker, BuffType.IO), "https://www.dropbox.com/s/mai6z52eiqqqrwx/Skilled_Tracker.png?dl=1", 2873044977),
                        ["Adept Skinner"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.075f, new KeyValuePair<Buff, BuffType>(Buff.Skinning_Yield, BuffType.Percentage), "https://www.dropbox.com/s/cy3eo6mr6r4gbeb/Adept_Skinner.png?dl=1", 2873045152),
                        ["Instant Skinner"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Instant_Skin, BuffType.Percentage), "https://www.dropbox.com/s/wgic15j3uecdegl/Instant_Skinner.png?dl=1", 2873045291),
                        ["Robust Knife"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Skinning_Tool_Durability, BuffType.Percentage), "https://www.dropbox.com/s/j8fkg0xu1cfz7wd/Robust_Knife.png?dl=1", 2873045413),
                        ["Expert Skinner"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Skinning_Yield, BuffType.Percentage), "https://www.dropbox.com/s/fs66l8mad4uci9p/Expert_Skinner.png?dl=1", 2873045569),
                        ["Survival Chef"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Skin_Cook, BuffType.Percentage), "https://www.dropbox.com/s/eahszj2z8lppx66/Survival_Chef.png?dl=1", 2873046097),
                        ["Steel Knife"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Skinning_Tool_Durability, BuffType.Percentage), "https://www.dropbox.com/s/0c8kf86a43rmo5r/Steel_Knife.png?dl=1", 2873046697),
                        ["Skilled Hunter"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Animal_NPC_Damage, BuffType.Percentage), "https://www.dropbox.com/s/asrhyvazu2ilkqx/Skilled_Hunter.png?dl=1", 2873046221),
                        ["Primal Identity"] = new Configuration.TreeInfo.NodeInfo(true, 1, UltimateLevel, 1f, new KeyValuePair<Buff, BuffType>(Buff.Skinning_Ultimate, BuffType.IO), "https://www.dropbox.com/s/ba8gmtvr62rek6q/Primal_Identity.png?dl=1", 2873046423),
                        ["Skinning Luck"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.03f, new KeyValuePair<Buff, BuffType>(Buff.Skinning_Luck, BuffType.Percentage), "https://www.dropbox.com/s/mpqadgqy1h6uj38/Shamanskill_09_nobg.v1.png?dl=1", 2912885514),
                    }),
                    ["Harvesting"] = new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()
                    {
                        ["Amature Harvester"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Harvest_Wild_Yield, BuffType.Percentage), "https://www.dropbox.com/s/kpvo6cniebzgvdx/Amature_Harvester.png?dl=1", 2873046943),
                        ["Hobbiest Harvester"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.15f, new KeyValuePair<Buff, BuffType>(Buff.Harvest_Wild_Yield, BuffType.Percentage), "https://www.dropbox.com/s/s5slqgk7sxdd1w3/Hobbiest_Harvester.png?dl=1", 2873047153),
                        ["Amature Farmer"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.075f, new KeyValuePair<Buff, BuffType>(Buff.Harvest_Grown_Yield, BuffType.Percentage), "https://www.dropbox.com/s/sqpubic88t7oyaw/Amature_Farmer.png?dl=1", 2873047337),
                        ["Extra pockets"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 2f, new KeyValuePair<Buff, BuffType>(Buff.ExtraPockets, BuffType.Slots), "https://www.dropbox.com/s/damaguptw7r54r5/Extra_pockets.png?dl=1", 2873047443),
                        ["Expert Harvester"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Harvest_Wild_Yield, BuffType.Percentage), "https://www.dropbox.com/s/t8xms1jaxgoissj/Expert_Harvester.png?dl=1", 2873047547),
                        ["Expert Farmer"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Harvest_Grown_Yield, BuffType.Percentage), "https://www.dropbox.com/s/s1z0p2z80r6bkpn/Expert_Farmer.png?dl=1", 2873047644),
                        ["Fisherman"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Extra_Fish, BuffType.Percentage), "https://www.dropbox.com/s/ohvnyq50bmt46ok/Fisherman.png?dl=1", 2873047745),
                        ["Botanist"] = new Configuration.TreeInfo.NodeInfo(true, 1, UltimateLevel, 1f, new KeyValuePair<Buff, BuffType>(Buff.Harvester_Ultimate, BuffType.IO), "https://www.dropbox.com/s/8fylvtokuhcj24u/Botanist.png?dl=1", 2873047865),
                        ["Fishing Luck"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.03f, new KeyValuePair<Buff, BuffType>(Buff.Fishing_Luck, BuffType.Percentage), "https://www.dropbox.com/s/lrwsqmsyx7a8653/Shamanskill_14_nobg.v1.png?dl=1", 2912896627),
                        ["Ichthyologist"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Bite_Speed, BuffType.Percentage), "https://www.dropbox.com/s/o60v2xmswg9nb91/Archerskill_09_nobg.v2.png?dl=1", 3006635760),
                        ["Foragers Intuition"] = new Configuration.TreeInfo.NodeInfo(true, 1, 3, 1f, new KeyValuePair<Buff, BuffType>(Buff.Forager, BuffType.IO), "https://www.dropbox.com/s/y2k9s25terdic5p/Druideskill_10_nobg.v1.png?dl=1", 3010448075),
                        ["Braided Line"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.07f, new KeyValuePair<Buff, BuffType>(Buff.Rod_Tension_Bonus, BuffType.Percentage), "https://www.dropbox.com/s/p3rkfmoay0tglpz/Warriorskill_38_nobg.v1.png?dl=1", 3012306483),
                        ["Lucky forager"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.01f, new KeyValuePair<Buff, BuffType>(Buff.Harvesting_Luck, BuffType.Percentage), "https://www.dropbox.com/scl/fi/kzvv6m81kt8mkpva3zx8y/Priestskill_44_nobg.v1.png?rlkey=e2ilpig2rmw8fuz5enkdmgt6l&st=20qs3eya&dl=1", 3305668585),
                    }),
                    ["Medical"] = new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()
                    {
                        ["Bandage Expert"] = new Configuration.TreeInfo.NodeInfo(true, 1, 1, 1f, new KeyValuePair<Buff, BuffType>(Buff.Double_Bandage_Heal, BuffType.IO), "https://www.dropbox.com/s/p1wlvzz5vtyvd24/Bandage_Expert.png?dl=1", 2873048071),
                        ["Radiation Expert"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Radiation_Reduction, BuffType.Percentage), "https://www.dropbox.com/s/g18h9sv1q5wi1t7/Radiation_Expert.png?dl=1", 2873965334),
                        ["Revitalization"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.HealthRegen, BuffType.PerSecond), "https://www.dropbox.com/s/9neapkjx2ntpclm/Revitalization.png?dl=1", 2873048224),
                        ["Flame Retardant"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Fire_Damage_Reduction, BuffType.Percentage), "https://www.dropbox.com/s/mmvn40hp81niuc5/Flame_Retardant.png?dl=1", 2873048354),
                        ["Accident Evasion"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Fall_Damage_Reduction, BuffType.Percentage), "https://www.dropbox.com/s/1n69ohui470smxj/Accident_Evasion.png?dl=1", 2873048450),
                        ["Battle Medic"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Reviver, BuffType.Percentage), "https://www.dropbox.com/s/opmy93244kmtj7j/Battle_Medic.png?dl=1", 2873048560),
                        ["Exposed Radiation"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.RadiationBaseValue, BuffType.Percentage), "https://www.dropbox.com/scl/fi/orz96x04gin3wwcu255sf/Warriorskill_30_nobg.v1.png?rlkey=u8pw2vu444594syp4hszf3bx4&st=8u6gqv64&dl=1", 3263581628),
                        ["Rugged Up"] = new Configuration.TreeInfo.NodeInfo(true, 1, 3, 1f, new KeyValuePair<Buff, BuffType>(Buff.No_Cold_Damage, BuffType.IO), "https://www.dropbox.com/s/l9hmad91yyb8v3x/Rugged_Up.png?dl=1", 2873048673),
                        ["Perfect Balance"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Fall_Damage_Reduction, BuffType.Percentage), "https://www.dropbox.com/s/vn5rf6prsaviblj/Perfect_Balance.png?dl=1", 2873048757),
                        ["Second Wind"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Wounded_Resist, BuffType.Percentage), "https://www.dropbox.com/s/zh9wcs2alr4uzlm/Second_Wind.png?dl=1", 2873048855),
                        ["Fresh Spawn"] = new Configuration.TreeInfo.NodeInfo(true, 1, 3, 1.0f, new KeyValuePair<Buff, BuffType>(Buff.Spawn_Health, BuffType.Percentage), "https://www.dropbox.com/scl/fi/241p09h1vhv7v0anqfz91/Priestskill_27_nobg.v1.png?rlkey=vqt9cl274qcxkq050mzqhdhcs&dl=1", 3036169025),
                        ["Lead Lined"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.RadiationResistModifier, BuffType.Percentage), "https://www.dropbox.com/scl/fi/v6tmo0swqgatqswygwr7g/Warriorskill_30_nobg.v1_purple.png?rlkey=x6f26fk8ouvfu6jlk2clo3dvs&st=se4rah7b&dl=1", 3263581772),
                        ["Messiah"] = new Configuration.TreeInfo.NodeInfo(true, 1, UltimateLevel, 1f, new KeyValuePair<Buff, BuffType>(Buff.Medical_Ultimate, BuffType.IO), "https://www.dropbox.com/s/qz76ogz9tayfgwb/Messiah.png?dl=1", 2873048963)

                    }),
                    ["Combat"] = new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()
                    {
                        ["Animal Tamer"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Animal_Damage_Resist, BuffType.Percentage), "https://www.dropbox.com/s/5wgfza2h6d1nxpd/Animal_Tamer.png?dl=1", 2873049142),
                        ["Defence Research"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Human_NPC_Defence, BuffType.Percentage), "https://www.dropbox.com/s/rs66cu2qrawjfjw/Defence_Research.png?dl=1", 2873049362),
                        ["Resourceful"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.Free_Bullet_Chance, BuffType.Percentage), "https://www.dropbox.com/s/1vmyged7iu3j9fi/Resourceful.png?dl=1", 2873049496),
                        ["Scientific Breakthrough"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Human_NPC_Damage, BuffType.Percentage), "https://www.dropbox.com/s/910bdsqaon9ja22/Scientific_Breakthrough.png?dl=1", 2873049588),
                        ["Duelist"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Melee_Resist, BuffType.Percentage), "https://www.dropbox.com/s/619ww8i1fu7a28e/Duelist.png?dl=1", 2873049666),
                        ["Lucky Shot"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.01f, new KeyValuePair<Buff, BuffType>(Buff.PVP_Critical, BuffType.Percentage), "https://www.dropbox.com/s/iezzpbs15qbmt1u/Lucky_Shot.png?dl=1", 2873049731),
                        ["Assassin"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.01f, new KeyValuePair<Buff, BuffType>(Buff.PVP_Damage, BuffType.Percentage), "https://www.dropbox.com/s/i39yhkrdvwti1dn/Assassin.png?dl=1", 2873049790),
                        ["Guarded"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.PVP_Shield, BuffType.Percentage), "https://www.dropbox.com/s/yufh2ieo4kysb5g/Guarded.png?dl=1", 2873049899),
                        ["Drum Mag"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Extended_Mag, BuffType.Percentage), "https://www.dropbox.com/s/2zil9t4brndzgd7/Extended_Mag.v1.png?dl=1", 2995245729),
                        ["Vampiric Tendencies"] = new Configuration.TreeInfo.NodeInfo(true, 1, UltimateLevel, 1f, new KeyValuePair<Buff, BuffType>(Buff.Combat_Ultimate, BuffType.IO), "https://www.dropbox.com/s/3brv8bohuk75npj/Vampiric_Tendencies.png?dl=1", 2873050024),
                        ["Maintenance"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Durability, BuffType.Percentage), "https://www.dropbox.com/s/b1bgfqdxe2wunr0/Maintenance.png?dl=1", 2873050116),
                        ["Sixth Sense"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 5f, new KeyValuePair<Buff, BuffType>(Buff.Awareness, BuffType.Distance), "https://www.dropbox.com/scl/fi/zybvoa859xxdlj99sjb3u/Archerskill_14_nobg.v1.png?rlkey=v7npg3s5bghc3z7egkmr43bz7&st=u9c43a91&dl=1", 3393706448),
                        ["Supersonic Thrust"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 1f, new KeyValuePair<Buff, BuffType>(Buff.Rocket_Velocity, BuffType.Percentage), "https://www.dropbox.com/scl/fi/wnxbqcr3tf1skr86c5n6x/Archerskill_05_nobg.v1.png?rlkey=534ipsyv0zasw3mlclyf2eido&st=s4cnj9ly&dl=1", 3470847198),
                        ["Ricochet"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Shield_Reflect, BuffType.Percentage), "https://www.dropbox.com/scl/fi/by0ecvqo94p275odes6ph/Assassinskill_17_nobg.v1.png?rlkey=by53d2j3tfoizrn02vr7ekax1&st=7u0bo2jw&dl=1", 3475613624),
                        ["Tank Buster"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Bradley_Damage_Bonus, BuffType.Percentage), "https://www.dropbox.com/scl/fi/w73higanxue1n5jjlxgte/Engineerskill_27_nobg.v1.png?rlkey=khmvqdixsby2x6bncyzohz10q&st=3c34eha6&dl=1", 3538449981),
                        ["Skybane"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Heli_Damage_Bonus, BuffType.Percentage), "https://www.dropbox.com/scl/fi/7ywy7mfqgy9e9pjdlfv5q/Engineerskill_12_nobg.v1.png?rlkey=p6g6m826bx8jzwj0ox6drgf2d&st=ja0y2c6m&dl=1", 3538450199)
                    }),
                    ["Build_Craft"] = new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()
                    {
                        ["Amature Tinkerer"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Craft_Speed, BuffType.Percentage), "https://www.dropbox.com/s/4hw98tpjmsohf9n/Amature_Tinkerer.png?dl=1", 2873050271),
                        ["Thrifty Renovator"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Upgrade_Refund, BuffType.Percentage), "https://www.dropbox.com/s/36274c1xkjjtb0f/Thirfty_Renovator.png?dl=1", 2873050381),
                        ["Adept Tinkerer"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Craft_Speed, BuffType.Percentage), "https://www.dropbox.com/s/mikhmlqfx5y7fvl/Adept_Tinkerer.png?dl=1", 2873050490),
                        ["Thrifty Tinkerer"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Craft_Refund, BuffType.Percentage), "https://www.dropbox.com/s/yp73p3ruy4l4oh2/Thrifty_Tinkerer.png?dl=1", 2873050600),
                        ["Researcher"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Research_Refund, BuffType.Percentage), "https://www.dropbox.com/s/armldhxjctbg67w/Research.png?dl=1", 2873050672),
                        ["Expert Tinkerer"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Craft_Speed, BuffType.Percentage), "https://www.dropbox.com/s/8ibntd9n1033dh4/Expert_Tinkerer.png?dl=1", 2873050815),
                        ["Blast Furnace"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Smelt_Speed, BuffType.Percentage), "https://www.dropbox.com/s/p0i3ef8mq4mug05/Blast_Furnace.png?dl=1", 2873050908),
                        ["Primitive Expert"] = new Configuration.TreeInfo.NodeInfo(true, 1, 1, 1f, new KeyValuePair<Buff, BuffType>(Buff.Primitive_Expert, BuffType.IO), "https://www.dropbox.com/s/gvy0dreisfvd9t5/Primitive_Expert.png?dl=1", 2873051010),
                        ["Thrifty Duplicator"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.03f, new KeyValuePair<Buff, BuffType>(Buff.Craft_Duplicate, BuffType.Percentage), "https://www.dropbox.com/s/lzd1p3l8q5t7rx2/Thrifty_Duplicator.png?dl=1", 2873051123),
                        ["Access Granted"] = new Configuration.TreeInfo.NodeInfo(true, 1, UltimateLevel, 1f, new KeyValuePair<Buff, BuffType>(Buff.Build_Craft_Ultimate, BuffType.IO), "https://www.dropbox.com/s/58hmrgytnntn314/Access_Granted.png?dl=1", 2873051221),
                        ["Blacksmith"] = new Configuration.TreeInfo.NodeInfo(true, 1, 3, 1f, new KeyValuePair<Buff, BuffType>(Buff.MaxRepair, BuffType.IO), "https://www.dropbox.com/s/b4k6p03u77x9d7t/Blacksmith.png?dl=1", 2873051294),
                        ["Quality Crafter"] = new Configuration.TreeInfo.NodeInfo(true, 3, 3, 1f, new KeyValuePair<Buff, BuffType>(Buff.Armor_Slots, BuffType.Slots), "https://www.dropbox.com/scl/fi/2g68c63roneqxo38evfv7/Engineerskill_18_nobg.v1.png?rlkey=w1glrclf04vyvbc6hntgdkmhu&st=lwv432tp&dl=1", 3475570774),
                        ["MacGyver"] = new Configuration.TreeInfo.NodeInfo(true, 1, 2, 1f, new KeyValuePair<Buff, BuffType>(Buff.Free_Repairs, BuffType.IO), "https://www.dropbox.com/scl/fi/fcha2r1mqcmlo3ab23hvu/Mageskill_14_nobg.v1.png?rlkey=81z810i63wkeqik2xmhj96x8z&st=t63ib277&dl=1", 3521517428)

                    }),
                    ["Scavenging"] = new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()
                    {
                        ["Looter"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Extra_Scrap_Barrel, BuffType.Percentage), "https://www.dropbox.com/s/y1cmvfjafenh1du/Looter.png?dl=1", 2873051741),
                        ["Barrel Smasher"] = new Configuration.TreeInfo.NodeInfo(true, 1, 1, 1f, new KeyValuePair<Buff, BuffType>(Buff.Barrel_Smasher, BuffType.IO), "https://www.dropbox.com/s/sebu0m6s5v2sual/Barrel_Smasher.png?dl=1", 2873051884),
                        ["Loot Magnet"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Loot_Pickup, BuffType.Percentage), "https://www.dropbox.com/s/hqthffkbbm73krh/Loot_Magnet.png?dl=1", 2873965904),
                        ["Digger"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Efficient_Digger, BuffType.Percentage), "https://www.dropbox.com/scl/fi/p4sckiln8e7au5f16z4vi/Warriorskill_11_nobg.v1.png?rlkey=p2zzuwfd5xeoc2kg53t3epa0h&st=kd4g27re&dl=1", 3245028577),
                        ["Magnetic Digger"] = new Configuration.TreeInfo.NodeInfo(true, 2, 1, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Magnetic_Digger, BuffType.Percentage), "https://www.dropbox.com/scl/fi/1a0hwynzstfe20sa25jbg/Shamanskill_24_nobg.v1.png?rlkey=3xe8m2vie59wjapk7jnljedsy&st=ebtv0qsm&dl=1", 3250636327),
                        ["Lucky Looter"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.05f, new KeyValuePair<Buff, BuffType>(Buff.Extra_Scrap_Crate, BuffType.Percentage), "https://www.dropbox.com/s/wpo449q9tinohgh/Lucky_Looter.png?dl=1", 2873052061),
                        ["Electronics Luck"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.Electronic_Chest, BuffType.Percentage), "https://www.dropbox.com/s/zshx9nme86dqrhm/Electronics_Luck.png?dl=1", 2873052180),
                        ["Component Luck"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.Component_Chest, BuffType.Percentage), "https://www.dropbox.com/s/vlz5kic6d0qw5df/Components_Luck.png?dl=1", 2873052277),
                        ["Luck Detective"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.Metal_Detector_Luck, BuffType.Percentage), "https://www.dropbox.com/scl/fi/f096z1u46rj1iv4wekwir/Mageskill_04_nobg.v1.png?rlkey=p9051jj6jletrapq0szc1kw68&st=5nhahqgf&dl=1", 3244936873),
                        ["Component Salvager"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.Component_Barrel, BuffType.Percentage), "https://www.dropbox.com/s/b4xu8xxe7zjwrwj/Component_Salvager.png?dl=1", 2873052390),
                        ["Electronics Salvager"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.Electronic_Barrel, BuffType.Percentage), "https://www.dropbox.com/s/jcgwgqzvoxw8y9e/Electronics_Salvager.png?dl=1", 2873052471),
                        ["Optimized Recycling"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.5f, new KeyValuePair<Buff, BuffType>(Buff.Recycler_Speed, BuffType.Seconds), "https://www.dropbox.com/s/3mq7xdj8zmdltp7/Optimized_Recycling.png?dl=1", 2873052554),
                        ["Efficient Recycling"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.Recycler_Efficiency, BuffType.Percentage), "https://www.dropbox.com/scl/fi/scv3574g4cqks05ckrn1x/RecyclerEfficiency.png?rlkey=qljou4kcu1rdpysfr11k3ihy3&st=i1t4soa7&dl=1", 3237995572),
                        ["Shredder"] = new Configuration.TreeInfo.NodeInfo(true, 1, UltimateLevel, 1f, new KeyValuePair<Buff, BuffType>(Buff.Scavengers_Ultimate, BuffType.IO), "https://www.dropbox.com/s/xib7ax3gwo6gg97/Shredder.png?dl=1", 2873052624)
                    }),
                    ["Vehicles"] = new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()
                    {
                        ["Amature Rider"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Riding_Speed, BuffType.Percentage), "https://www.dropbox.com/s/9lj4colvhioznl1/Amature_Rider.png?dl=1", 2873052721),
                        ["Adept Rider"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Riding_Speed, BuffType.Percentage), "https://www.dropbox.com/s/javi1k9ys88iwxg/Adept_Rider.png?dl=1", 2873053592),
                        ["Expert Rider"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Riding_Speed, BuffType.Percentage), "https://www.dropbox.com/s/oxfeh3b1xvqqo7t/Expert_Rider.png?dl=1", 2873053752),
                        ["Economical Pilot"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.03f, new KeyValuePair<Buff, BuffType>(Buff.Heli_Fuel_Rate, BuffType.Percentage), "https://www.dropbox.com/s/0h1hq0nco5dimtv/Economical_Pilot.png?dl=1", 2873054261),
                        ["Hybrid Pilot"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.07f, new KeyValuePair<Buff, BuffType>(Buff.Heli_Fuel_Rate, BuffType.Percentage), "https://www.dropbox.com/s/wgjms949cdlzegm/Hybrid_Pilot.png?dl=1", 2873054373),
                        ["Yachtman"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Boat_Speed, BuffType.Percentage), "https://www.dropbox.com/s/86096soadnsy2qh/Yachtman.png?dl=1", 2873054539),
                        ["Economical Captain"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.15f, new KeyValuePair<Buff, BuffType>(Buff.Boat_Fuel_Rate, BuffType.Percentage), "https://www.dropbox.com/s/5f4agk38f2y1ch4/Economical_Captain.png?dl=1", 2873054654),
                        ["Mechanic"] = new Configuration.TreeInfo.NodeInfo(true, 1, 3, 1f, new KeyValuePair<Buff, BuffType>(Buff.Vehicle_Mechanic, BuffType.IO), "https://www.dropbox.com/s/pdpum3gj4sfiowy/Mechanic.png?dl=1", 2873054766),
                        ["Tank"] = new Configuration.TreeInfo.NodeInfo(true, 1, UltimateLevel, 1f, new KeyValuePair<Buff, BuffType>(Buff.Vehicle_Ultimate, BuffType.Percentage), "https://www.dropbox.com/s/xdcl74d0e82e32l/Tank.png?dl=1", 2873054991),
                        ["Jet Engine"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.3f, new KeyValuePair<Buff, BuffType>(Buff.Heli_Speed, BuffType.Percentage), "https://www.dropbox.com/s/9948qp5tv7oc6l9/Shamanskill_42_nobg.v1.png?dl=1", 3009474256),
                        ["Supercharged"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.BikeEnginePower, BuffType.Percentage), "https://www.dropbox.com/scl/fi/es3bzvvda9i6d4hpwvyno/Priestskill_33_nobg.v1.png?rlkey=pz2r6h1zf19afem50eyxxu5xe&st=s71u9p0n&dl=1", 3283818174),
                        ["Airbags"] = new Configuration.TreeInfo.NodeInfo(true, 2, 2, 0.5f, new KeyValuePair<Buff, BuffType>(Buff.DriverCollisionResistance, BuffType.Percentage), "https://www.dropbox.com/scl/fi/24ytza9zomxv2eas6lqjx/Paladinskill_13_nobg.v1.png?rlkey=mp9nauo14unbttbptrvhu20bp&st=3wjgqq9j&dl=1", 3287404627),
                    }),
                    ["Cooking"] = new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()
                    {
                        ["Easily satisfied"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Extra_Food_Water, BuffType.Percentage), "https://www.dropbox.com/s/473rrrfjnt9huij/Easily_Satisfied.png?dl=1", 2873055105),
                        ["Iron Stomach"] = new Configuration.TreeInfo.NodeInfo(true, 1, 2, 1f, new KeyValuePair<Buff, BuffType>(Buff.Iron_Stomach, BuffType.IO), "https://www.dropbox.com/s/221dsnnubpa2825/Iron_Stomach.png?dl=1", 2873055201),
                        ["Glutton"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Metabolism_Boost, BuffType.Percentage), "https://www.dropbox.com/s/t0r4pttz6b7663c/Glutton.png?dl=1", 2873055301),
                        ["Fruggal Rationer"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Rationer, BuffType.Percentage), "https://www.dropbox.com/s/azdltk7o99y7mpk/Fruggal_Rationer.png?dl=1", 2873055400),
                        ["Tea Party"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Extended_Tea_Duration, BuffType.Percentage), "https://www.dropbox.com/s/himcda9ukseslvf/TeTime.png?dl=1", 3005685932),
                        ["Tea Connoisseur"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.Tea_Looter, BuffType.Percentage), "https://www.dropbox.com/s/htpiwo9aeqildv8/Archerskill_38_nobg.v1.png?dl=1", 3006539324),
                        ["Burst Of Energy"] = new Configuration.TreeInfo.NodeInfo(true, 1, UltimateLevel, 1f, new KeyValuePair<Buff, BuffType>(Buff.Cooking_Ultimate, BuffType.IO), "https://www.dropbox.com/s/jjhk0ug4ydajdqa/Assassinskill_12_nobg.v1.png?dl=1", 3011025470),
                        ["Fry Cook"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.19f, new KeyValuePair<Buff, BuffType>(Buff.Cooking_Speed, BuffType.Percentage), "https://www.dropbox.com/scl/fi/a0ihdbfkga5kbrfnv16gb/Shamanskill_07_nobg.v1.png?rlkey=vhf56q0p5bk2dw2qcxqatitid&st=5p793xdv&dl=1", 3464633815)                    }),
                    ["Underwater"] = new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()
                    {
                        ["Cage Diver"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.SharkResistance, BuffType.Percentage), "https://www.dropbox.com/s/hti5v35qh45lj94/Cage_Diver.png?dl=1", 2873055798),
                        ["Gilled"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 60f, new KeyValuePair<Buff, BuffType>(Buff.WaterBreathing, BuffType.Seconds), "https://www.dropbox.com/s/e48z07x10qkmh4s/Gilled.png?dl=1", 2873055882),
                        ["Reckless Diver"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.SharkResistance, BuffType.Percentage), "https://www.dropbox.com/s/k204yk4b6upj0r4/Reckless_Diver.png?dl=1", 2873056389),
                        ["Shark Veterinarian"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.SharkSkinner, BuffType.Percentage), "https://www.dropbox.com/s/zjiqshz9tzpgh82/Shark_Veterinarian.png?dl=1", 2873056528),
                        ["Treasure Hunter"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.DeepSeaLooter, BuffType.Percentage), "https://www.dropbox.com/s/po3zsz763hopkjc/Treasure_Hunter.png?dl=1", 2873056606),
                        ["Nimble Fingers"] = new Configuration.TreeInfo.NodeInfo(true, 1, 3, 1f, new KeyValuePair<Buff, BuffType>(Buff.InstantUntie, BuffType.IO), "https://www.dropbox.com/s/3m853nqxq2qmoih/Nimble_Fingers.png?dl=1", 2873056697),
                        ["Aquatic Combatant"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.10f, new KeyValuePair<Buff, BuffType>(Buff.UnderwaterDamageBonus, BuffType.Percentage), "https://www.dropbox.com/s/683npn5fwvkbtni/Aquatic_Combatant.png?dl=1", 2873056786),
                        ["Sonar Pulse"] = new Configuration.TreeInfo.NodeInfo(true, 1, 2, 1f, new KeyValuePair<Buff, BuffType>(Buff.Sonar, BuffType.IO), "https://www.dropbox.com/scl/fi/rthqet410byv4bpj80hgl/Priestskill_42_nobg.v1.png?rlkey=67h0gyem1x08nh7idb19zvtds&dl=1", 3111209702),
                    }),
                    ["Raiding"] = new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()
                    {
                        ["Trap Evader"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Trap_Damage_Reduction, BuffType.Percentage), "https://www.dropbox.com/s/lr88azap541gn7s/Trappingly%20Challenged.v1.png?dl=1", 2928072989),
                        ["Mine Sweeper"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Trap_Damage_Increase, BuffType.Percentage), "https://www.dropbox.com/s/j35nvrjiyg7wadl/Trap_Damage_Increase.v1.png?dl=1", 2928093322),
                        ["Blast Suit"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Personal_Explosive_Reduction, BuffType.Percentage), "https://www.dropbox.com/s/szg0pp5ow0fi11r/Personal_Explosive_Reduction.v1.png?dl=1", 2928111784),
                        ["Demolition"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.Double_Explosion_Chance, BuffType.Percentage), "https://www.dropbox.com/s/wk8xom6d7ab09jw/Double_Explosion_chance.v1.png?dl=1", 2928137975),
                        ["Pressed Explosive"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Explosion_Radius, BuffType.Percentage), "https://www.dropbox.com/s/nk89h8chtl4svx1/Explosion_Radius.v1.png?dl=1", 2928169093),
                        ["Master Thief"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.Lock_Picker, BuffType.Percentage), "https://www.dropbox.com/s/pcuy6jo1q567p9b/Lock_Picker.png?dl=1", 2928793256),
                        ["Rain hellfire"] = new Configuration.TreeInfo.NodeInfo(true, 1, UltimateLevel, 1.0f, new KeyValuePair<Buff, BuffType>(Buff.Raiding_Ultimate, BuffType.IO), "https://www.dropbox.com/s/tfn326c3pnhyri4/Raiding_Ultimate.v1.png?dl=1", 2929679053),
                        ["Reliable Explosive"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Dudless_Explosive, BuffType.Percentage), "https://www.dropbox.com/s/rrxxt78hu2r0vb4/Dudless_Explosive.png?dl=1", 2930484526),
                        ["Perceptive"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Trap_Spotter, BuffType.Percentage), "https://www.dropbox.com/s/as74z7rjlfiwy98/Druideskill_27_nobg.v1.png?dl=1", 3012262421),
                        ["Scavenger's Instinct"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 5f, new KeyValuePair<Buff, BuffType>(Buff.Loot_Spotter, BuffType.Distance), "https://www.dropbox.com/scl/fi/hmzmcxp11vjngivq96vy8/Paladinskill_46_nobg.v1.png?rlkey=1r93hrv402wc6fw1xwhn35i7c&st=pgajkxyi&dl=1", 3566102972),
                    }),
                    ["Team"] = new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()
                    {
                        ["Comforting Aura"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Comfort, BuffType.Percentage), "https://www.dropbox.com/scl/fi/203ir1w3pr9gd0xya60iu/Comfort.v1.png?rlkey=nfvtp3c63jch4zqqaxy1q8moo&dl=1", 3215096322),
                        ["Medic"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Heal_Share, BuffType.Percentage), "https://www.dropbox.com/scl/fi/3l01pud44z0gtqt6oea8n/HealShare.v1.png?rlkey=eyj5p55byk3y3m4b5hsu5rvrk&dl=1", 3215096612),
                        ["Guidance"] = new Configuration.TreeInfo.NodeInfo(true, 5, 3, 0.02f, new KeyValuePair<Buff, BuffType>(Buff.XP_Share, BuffType.Percentage), "https://www.dropbox.com/scl/fi/lg80ela2owff2bk4vxd1h/XPShare.v1.png?rlkey=gcxehwk7hker0xybzzyf01gfj&dl=1", 3215096872),
                        ["Brewed Bonding"] = new Configuration.TreeInfo.NodeInfo(true, 5, 2, 0.1f, new KeyValuePair<Buff, BuffType>(Buff.Tea_Share, BuffType.Percentage), "https://www.dropbox.com/scl/fi/ncgao45ozfx3vzxifwj17/TeaShare.v1.png?rlkey=ptdmj34xfszq7ifgzichia3h7&dl=1", 3215097253),
                        ["Feast Fellows"] = new Configuration.TreeInfo.NodeInfo(true, 5, 1, 0.2f, new KeyValuePair<Buff, BuffType>(Buff.Metabolism_Share, BuffType.Percentage), "https://www.dropbox.com/scl/fi/z987oj7ruyg9xczbnqx8z/MetabolismShare.v1.png?rlkey=z3bqgxl3oaavw5fs1d5f9f840&dl=1", 3215097568),
                        ["Craftman's Aura"] = new Configuration.TreeInfo.NodeInfo(true, 3, 3, 1f, new KeyValuePair<Buff, BuffType>(Buff.Human_Workbench, BuffType.Level), "https://www.dropbox.com/scl/fi/507mjkg53sptvpf3bqz7t/MobileWorkbench.v1.png?rlkey=o4whleu473331n691p3gb4vzn&dl=1", 3215097928),

                    }, true, 30),
                };
            }
        }

        Dictionary<AnimalBuff, float> DefaultAnimalBuffs
        {
            get
            {
                return new Dictionary<AnimalBuff, float>()
                {
                    [AnimalBuff.Bear] = 120f,
                    [AnimalBuff.Chicken] = 600f,
                    [AnimalBuff.Boar] = 1200f,
                    [AnimalBuff.Stag] = 300f,
                    [AnimalBuff.Wolf] = 600f,
                    [AnimalBuff.PolarBear] = 600f
                };
            }
        }

        HashSet<string> DefaultScavengerUltimateBlacklist
        {
            get
            {
                return new HashSet<string>()
                {
                    "lowgradefuel",
                    "targeting.computer",
                    "cctv.camera"
                };
            }
        }

        protected override void LoadConfig()
        {
            var path = Path.Combine(Manager.ConfigPath, Name + ".json");
            if (File.Exists(path))
            {
                var cfg = File.ReadAllText(path);
                var newCfg = cfg.Replace("Mixing_Speed", "Cooking_Speed");
                File.WriteAllText(path, newCfg);
            }
            
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
                SaveConfig();
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogException(ex);
                Interface.Oxide.UnloadPlugin(Name);
            }
        }

        protected override void SaveConfig()
        {
            PrintToConsole($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion

        #region Data

        PluginInfo pcdData;
        private DynamicConfigFile PCDDATA;

        const ulong MlrsSkin = 3329012898;
        readonly string FileName = "SkillTree.json";
        readonly string SharedXP = "Shared_XP";
        readonly string perm_admin = "skilltree.admin";
        readonly string perm_no_scoreboard = "skilltree.noscoreboard";
        readonly string perm_teaBonus = "skilltree.teabonus";
        readonly string perm_respec_bypass = "skilltree.respec.bypass";
        readonly string perm_toggle_bc = "skilltree.togglebc";
        readonly int maxRoll = 100;

        void Init()
        {
            Unsubscribe(nameof(OnPluginLoaded));
            Instance = this;
            PCDDATA = Interface.Oxide.DataFileSystem.GetFile(this.Name);
            permission.RegisterPermission("skilltree.noxploss", this);
            permission.RegisterPermission("skilltree.chat", this);
            permission.RegisterPermission("skilltree.xp", this);
            permission.RegisterPermission("skilltree.tree", this);
            permission.RegisterPermission(perm_admin, this);
            permission.RegisterPermission("skilltree.bag.keepondeath", this);
            permission.RegisterPermission("skilltree.notitles", this);
            permission.RegisterPermission("skilltree.roguelike", this);
            permission.RegisterPermission(perm_no_scoreboard, this);
            permission.RegisterPermission(perm_teaBonus, this);
            permission.RegisterPermission(perm_respec_bypass, this);
            permission.RegisterPermission(perm_toggle_bc, this);

            foreach (var perm in config.general_settings.points_per_level_override.Keys)
            {
                var permString = perm.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase) ? perm : "skilltree." + perm;
                if (!permission.PermissionExists(permString)) permission.RegisterPermission(permString, this);
            }

            foreach (var perm in config.general_settings.max_skill_points_override.Keys)
            {
                var permString = perm.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase) ? perm : "skilltree." + perm;
                if (!permission.PermissionExists(permString)) permission.RegisterPermission(permString, this);
            }
            foreach (var perm in config.general_settings.respec_cost_override.Keys)
            {
                var permString = perm.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase) ? perm : "skilltree." + perm;
                if (!permission.PermissionExists(permString)) permission.RegisterPermission(permString, this);
            }
            foreach (var perm in config.xp_settings.xp_perm_modifier.Keys)
            {
                var permString = perm.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase) ? perm : "skilltree." + perm;
                if (!permission.PermissionExists(permString)) permission.RegisterPermission(permString, this);
            }
            foreach (var perm in config.rested_xp_settings.rested_xp_modifier_perm_mod.Keys)
            {
                var permString = perm.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase) ? perm : "skilltree." + perm;
                if (!permission.PermissionExists(permString)) permission.RegisterPermission(permString, this);
            }
            foreach (var perm in config.wipe_update_settings.starting_skill_point_overrides.Keys)
            {
                var permString = perm.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase) ? perm : "skilltree." + perm;
                if (!permission.PermissionExists(permString)) permission.RegisterPermission(permString, this);
            }
            permission.RegisterPermission("skilltree.all", this);
            foreach (var tree in config.trees)
            {
                permission.RegisterPermission("skilltree." + tree.Key.ToString(), this);
            }

            if (config.xp_settings.xp_sources.Harbor_Event_Winner == 0) Unsubscribe("OnHarborEventWinner");
            if (config.xp_settings.xp_sources.Junkyard_Event_Winner == 0) Unsubscribe("OnJunkyardEventWinner");
            if (config.xp_settings.xp_sources.Satellite_Event_Winner == 0) Unsubscribe("OnSatDishEventWinner");
            if (config.xp_settings.xp_sources.Water_Event_Winner == 0) Unsubscribe("OnWaterEventWinner");
            if (config.xp_settings.xp_sources.Air_Event_Winner == 0) Unsubscribe("OnAirEventWinner");
            if (config.xp_settings.xp_sources.PowerPlant_Event_Winner == 0) Unsubscribe("OnPowerPlantEventWinner");
            if (config.xp_settings.xp_sources.Armored_Train_Winner == 0) Unsubscribe("OnArmoredTrainEventWin");
            if (config.xp_settings.xp_sources.Convoy_Winner == 0) Unsubscribe("OnConvoyEventWin");
            if (config.xp_settings.xp_sources.SurvivalArena_Winner == 0) Unsubscribe(nameof(OnSurvivalArenaWin));
            if (config.xp_settings.xp_sources.boss_monster == 0) Unsubscribe(nameof(OnBossKilled));
            Unsubscribe(nameof(OnNpcTarget));
            
        }

        void CheckForCapUpdate()
        {
            if (pcdData.nextXPCapReset < DateTime.Now) pcdData.nextXPCapReset = GetNextCapReset();
        }

        DateTime GetNextCapReset()
        {
            try
            {
                var now = DateTime.Now.Date;
                DateTime parsedTime = DateTime.ParseExact(config.xp_settings.xPCapSettings.resetTime, "hh:mm tt", CultureInfo.InvariantCulture);
                DateTime targetTime = DateTime.Now.Date.Add(parsedTime.TimeOfDay);
                if (DateTime.Now >= targetTime) return targetTime.AddDays(1);
                return targetTime;
            }
            catch (Exception ex)
            {
                Puts($"1770311030 GetNextCapReset Threw an error. The reset time string may not be formatted correctly. {ex.Message}");
                return DateTime.MinValue;
            }
        }

        bool Unloading = false;
        void Unload()
        {
            if (IsInvoking) ServerMgr.Instance.CancelInvoke(nameof(CheckforNightTime));
            Unloading = true;
            try
            {
                StopSavingPlayerData(true);
            }
            catch
            {
                Puts("Error: StopSavingPlayerData");
            }
            try
            {
                SaveNewNodesToConfig(true);
            }
            catch
            {
                Puts("Error: SaveNewNodesToConfig");
            }
            DeepSeaLooterLootTable?.Clear();
            SharkLootTable?.Clear();
            List<BasePlayer> players = Pool.Get<List<BasePlayer>>();
            players.AddRange(BasePlayer.activePlayerList);
            if (players.Count > 0)
            {
                foreach (var player in players)
                {
                    string failString = string.Empty;
                    try
                    {
                        CuiHelper.DestroyUi(player, "SkillTree");
                        CuiHelper.DestroyUi(player, "XP_Tick");
                        CuiHelper.DestroyUi(player, "respec_confirmation");
                        CuiHelper.DestroyUi(player, "SkillTreeXPBar");
                        CuiHelper.DestroyUi(player, "ui_mover");
                        CuiHelper.DestroyUi(player, "SkillTreeBackPanel");
                        CuiHelper.DestroyUi(player, "NavigationMenu");
                        CuiHelper.DestroyUi(player, "SkillTree_PlayerMenu");
                        CuiHelper.DestroyUi(player, "SkillTree_Buff_Settings");
                        CuiHelper.DestroyUi(player, "SkillTreePlayerSettingsBackPanel");
                        CuiHelper.DestroyUi(player, "ExtraPocketsButton");
                        CuiHelper.DestroyUi(player, "ScoreBoardPanel");
                        CuiHelper.DestroyUi(player, "ScoreboardBackPanel");
                        CuiHelper.DestroyUi(player, "SkillTree_UltimateMenu");
                        CuiHelper.DestroyUi(player, "SkillTree_MedicalUltimate_ResurrectionButton");
                        CuiHelper.DestroyUi(player, "SkillTree_MedicalUltimate_Failed");
                        CuiHelper.DestroyUi(player, "Plant_Gene_Select");
                        CuiHelper.DestroyUi(player, "Plant_Gene_Select_background");
                        CuiHelper.DestroyUi(player, "Overshield_main");
                        CuiHelper.DestroyUi(player, "StagDangerUI");
                        CuiHelper.DestroyUi(player, "UnderwaterBreathCounter");
                        CuiHelper.DestroyUi(player, "PrestigeConfirmation");
                        CuiHelper.DestroyUi(player, "AchievedRank");
                        CuiHelper.DestroyUi(player, "PresetBackpanel");
                        CuiHelper.DestroyUi(player, "PresetPanel");
                        CuiHelper.DestroyUi(player, "PresetAddSelectBackpanel");
                        CuiHelper.DestroyUi(player, "STAddSelectPresetPanel");
                        CuiHelper.DestroyUi(player, "MessagePanel");
                        CuiHelper.DestroyUi(player, "STPresetSkillPanel");
                        CuiHelper.DestroyUi(player, "PresetInfoBackground");
                        CuiHelper.DestroyUi(player, "VideoConfirmation");                        
                        failString = "DoClear";
                        DoClear(player, config.buff_settings.removePermissionsOnDisconnect);
                        failString = "EndLooting";
                        player.EndLooting();
                        failString = "LoggingOff";
                        LoggingOff(player, true);
                    }
                    catch { Puts($"Failed to update data for {player?.userID}. Fail reason: {failString}"); }
                }
            }
            Pool.FreeUnmanaged(ref players);
            List<BasePlayer> allPlayers = Pool.Get<List<BasePlayer>>();
            allPlayers.AddRange(BasePlayer.allPlayerList);
            foreach (var player in allPlayers)
            {
                try
                {
                    if (player == null) continue;
                    try { DestroyRegen(player); } catch { }
                    try { DestroyWaterBreathing(player); } catch { }
                    try { DestroyRaidBehaviour(player); } catch { }
                    try { DestroyInstantUntie(player); } catch { }
                    try { DestroyComfortSkill(player); } catch { }
                    try { DestroyMobileWorkbench(player); } catch { }
                    try { DestroyAwareness(player); } catch { }
                }
                catch { }
            }
            Pool.FreeUnmanaged(ref allPlayers);

            List<KeyValuePair<ulong, HorseInfo>> horses = Pool.Get<List<KeyValuePair<ulong, HorseInfo>>>();
            horses.AddRange(HorseStats);
            foreach (var horse in horses)
            {
                try
                {
                    if (horse.Value.horse != null && horse.Value.horse.IsAlive()) RestoreHorseStats(horse.Value.horse, false);
                }
                catch { }
            }
            Pool.FreeUnmanaged(ref horses);
            HorseStats.Clear();
            HorseStats = null;

            List<KeyValuePair<ulong, PlayerHelicopter>> helis = Pool.Get<List<KeyValuePair<ulong, PlayerHelicopter>>>();
            helis.AddRange(tracked_helis);
            foreach (var heli in helis)
            {
                try
                {
                    if (heli.Value != null && heli.Value.IsAlive()) heli.Value.fuelPerSec = default_heli_fuel_rate;
                }
                catch { }
            }
            Pool.FreeUnmanaged(ref helis);
            tracked_helis.Clear();
            tracked_helis = null;

            List<KeyValuePair<ulong, MiniInfo>> minis = Pool.Get<List<KeyValuePair<ulong, MiniInfo>>>();
            minis.AddRange(MiniStats);
            foreach (var heli in minis)
            {
                try
                {
                    if (heli.Value.mini == null || heli.Value.mini.IsDead()) continue;
                    RestoreMiniStats(heli.Value.mini, null, false);
                }
                catch { }
            }
            Pool.FreeUnmanaged(ref minis);
            MiniStats.Clear();
            MiniStats = null;

            List<KeyValuePair<ulong, BikeInfo>> bikes = Pool.Get<List<KeyValuePair<ulong, BikeInfo>>>();
            bikes.AddRange(BikeStats);
            foreach (var bike in bikes)
            {
                try
                {
                    if (bike.Value.bike == null || bike.Value.bike.IsDead()) continue;
                    RestoreBikeStats(bike.Value.bike, null, false);
                }
                catch { }
            }
            Pool.FreeUnmanaged(ref bikes);
            BikeStats.Clear();
            BikeStats = null;

            List<KeyValuePair<ulong, MotorRowboat>> boats = Pool.Get<List<KeyValuePair<ulong, MotorRowboat>>>();
            boats.AddRange(tracked_rhibs);
            foreach (var boat in boats)
            {
                try
                {
                    if (boat.Value != null && boat.Value.IsAlive()) boat.Value.fuelPerSec = default_rhib_fuel_rate;
                }
                catch { }
            }
            boats.Clear();
            tracked_rhibs.Clear();
            tracked_rhibs = null;

            boats.AddRange(tracked_rowboats);
            foreach (var boat in boats)
            {
                try
                {
                    if (boat.Value != null && boat.Value.IsAlive()) boat.Value.fuelPerSec = default_rowboat_fuel_rate;
                }
                catch { }
            }
            Pool.FreeUnmanaged(ref boats);
            tracked_rowboats.Clear();
            tracked_rowboats = null;

            List<KeyValuePair<ulong, BoatInfo>> boaties = Pool.Get<List<KeyValuePair<ulong, BoatInfo>>>();
            boaties.AddRange(Boats);
            foreach (var boat in Boats)
            {
                try
                {
                    if (boat.Value.boat == null || boat.Value.boat.IsDead()) continue;
                    ResetBoatSpeed(boat.Value.boat, boat.Value.player, false);
                }
                catch { }
            }
            Pool.FreeUnmanaged(ref boaties);
            Boats.Clear();
            Boats = null;

            foreach (var chatcommand in config.chat_commands.score_chat_cmd)
            {
                try
                {
                    cmd.RemoveChatCommand(chatcommand, this);
                    cmd.RemoveConsoleCommand(chatcommand, this);
                }
                catch { }
            }
            foreach (var chatcommand in config.chat_commands.chat_cmd)
            {
                try
                {
                    cmd.RemoveChatCommand(chatcommand, this);
                }
                catch { }
            }
            cmd.RemoveChatCommand(config.ultimate_settings.ultimate_raiding.command, this);
            cmd.RemoveChatCommand(config.ultimate_settings.ultimate_cooking.command, this);
            cmd.RemoveChatCommand(config.buff_settings.raid_perk_settings.Lock_Picker_settings.pick_command.Trim(), this);
            if (!config.buff_settings.boat_turbo_on_mount) cmd.RemoveChatCommand(config.chat_commands.turbo_cmd, this);

            SaveData(true);

            ScoreBoard?.Wipe();
            healers?.Clear();
            MiningUltimateCooldowns?.Clear();

            foreach (var entity in reduced_damage_entities)
            {
                try
                {
                    RestoreSkinToChildren(entity.Value);
                }
                catch { }
            }
            reduced_damage_entities?.Clear();

            cmd.RemoveChatCommand(config.ultimate_settings.ultimate_mining.find_node_cmd, this);
            cmd.RemoveChatCommand(config.ultimate_settings.ultimate_harvesting.gene_chat_command, this);
            cmd.RemoveChatCommand(config.chat_commands.track_animal_cmd, this);
            cmd.RemoveChatCommand(config.buff_settings.forager_settings.command, this);
            cmd.RemoveChatCommand(config.buff_settings.sonar_settings.command, this);
            cmd.RemoveConsoleCommand(config.buff_settings.forager_settings.command, this);
            cmd.RemoveConsoleCommand(config.buff_settings.sonar_settings.command, this);
            cmd.RemoveChatCommand(config.buff_settings.raid_perk_settings.Trap_Spotter_settings.command, this);
            cmd.RemoveChatCommand(config.buff_settings.raid_perk_settings.Loot_Spotter_settings.command, this);
            cmd.RemoveConsoleCommand(config.buff_settings.raid_perk_settings.Trap_Spotter_settings.command, this);
            cmd.RemoveConsoleCommand(config.buff_settings.raid_perk_settings.Loot_Spotter_settings.command, this);
            Duds?.Clear();
            ItemDefs?.Clear();

            List<KeyValuePair<ulong, ActivePickerClass>> pickers = Pool.Get<List<KeyValuePair<ulong, ActivePickerClass>>>();
            pickers.AddRange(ActivePickers);
            foreach (var p in pickers)
            {
                try
                {
                    DestroyPicker(p.Key, p.Value, false);
                }
                catch { }
            }
            Pool.FreeUnmanaged(ref pickers);
            ActivePickers.Clear();
            LockPickCooldowns.Clear();

            BaseYieldOverrides?.Clear();
            LastSwipe?.Clear();
            LastSwipe = null;

            try
            {
                ResetWeaponCapacities(false, config.buff_settings.force_unload_extended_mag_weapons_unload);
            }
            catch { }

            ModifiedWeapons.Clear();
            ModifiedWeapons = null;

            TrackedPermissionPerms?.Clear();
            TrackedPermissionPerms = null;

            InstanceDataPlayerQueue?.Clear();
            InstanceDataPlayerQueue = null;

            Researchers?.Clear();
            Researchers = null;

            MessageReceivers?.Clear();
            MessageReceivers = null;

            Vehicle_Mechanic_CooldownTimer?.Clear();
            Vehicle_Mechanic_CooldownTimer = null;

            List<KeyValuePair<ulong, BaseFishingRod>> rods = Pool.Get<List<KeyValuePair<ulong, BaseFishingRod>>>();
            rods.AddRange(TrackedRods);
            foreach (var rod in rods)
            {
                try
                {
                    ResetRod(rod.Value, false);
                }
                catch { }
            }

            Pool.FreeUnmanaged(ref rods);
            TrackedRods?.Clear();
            TrackedRods = null;

            try { AddLogs(); } catch { }

            List<KeyValuePair<ulong, Timer>> _timers = Pool.Get<List<KeyValuePair<ulong, Timer>>>();
            _timers.AddRange(timers);
            try
            {
                foreach (var kvp in timers)
                    if (kvp.Value != null && !kvp.Value.Destroyed) kvp.Value.Destroy();

                timers?.Clear();
                timers = null;
            }
            catch { }

            Pool.FreeUnmanaged(ref _timers);
            if (IsGivingOfflineXP) ServerMgr.Instance.StopCoroutine(OfflineXP_Routine);
            if (IsGivingOfflineSP) ServerMgr.Instance.StopCoroutine(OfflineSP_Routine);

            try
            {
                WorkbenchSkillUnload();
            }
            catch { }

            List<KeyValuePair<ulong, RecyclerEfficiency>> recyclers = Pool.Get<List<KeyValuePair<ulong, RecyclerEfficiency>>>();
            recyclers.AddRange(recyclers);
            foreach (var recycler in recyclers)
            {
                try
                {
                    ResetRecyclerEfficiency(recycler.Key, recycler.Value);
                }
                catch { }
                ModifiedRecyclers.Clear();
            }
            Pool.FreeUnmanaged(ref recyclers);

            SpamProtection?.Clear();
        }

        void ResetWeaponCapacities(bool clear = true, bool forceUnloadWeapons = true)
        {
            foreach (var weapon in ModifiedWeapons)
            {
                if (weapon.Value == null) continue;
                RemoveMods(weapon.Value, 0, clear, forceUnloadWeapons);
            }
        }

        Coroutine SaveRoutine;
        void SaveData(bool unloading = false)
        {
            PCDDATA.WriteObject(pcdData);
            if (unloading) return;

            StopSavingPlayerData(false);
            SaveRoutine = ServerMgr.Instance.StartCoroutine(HandlePlayerSaves());
        }

        void StopSavingPlayerData(bool unloading)
        {
            if (SaveRoutine != null) ServerMgr.Instance.StopCoroutine(SaveRoutine);
            if (unloading && Saving != null) Pool.FreeUnmanaged(ref Saving);
        }

        List<KeyValuePair<ulong, PlayerInfo>> Saving;
        IEnumerator HandlePlayerSaves()
        {
            if (Saving == null) yield break;
            if (config.misc_settings.enableDebug) Puts($"Saving player data for {pcdData.pEntity.Count} players.");
            var count = 0;
            Saving.Clear();
            Saving.AddRange(pcdData.pEntity);
            foreach (var kvp in Saving)
            {
                try
                {
                    File.WriteAllText(NewDirectory + $"{kvp.Key}.json", JsonConvert.SerializeObject(kvp.Value, Formatting.Indented));
                }
                catch { }
                count++;
                if (count >= 10)
                {
                    count = 0;
                    yield return CoroutineEx.waitForEndOfFrame;
                }
            }
            if (config.misc_settings.enableDebug) Puts($"Finished saving player data.");
        }

        void LoadData()
        {
            if (!Directory.Exists(NewDirectory)) Directory.CreateDirectory(NewDirectory);
            try
            {
                pcdData = Interface.Oxide.DataFileSystem.ReadObject<PluginInfo>(this.Name);
                if (pcdData == null) pcdData = new PluginInfo();
            }
            catch
            {
                if (config.misc_settings.enableDebug) Puts("Couldn't load player data, creating new Playerfile");
                pcdData = new PluginInfo();
            }
        }

        PlayerInfo LoadPlayerData(string userID, bool createNew = true)
        {
            if (!Directory.Exists(NewDirectory)) Directory.CreateDirectory(NewDirectory);
            if (!File.Exists(NewDirectory + userID + ".json"))
            {
                if (!createNew) return null;
                PlayerDataLogs += $"\nFound no data for {userID} [{NewDirectory + userID + ".json"} - File exists: {File.Exists(NewDirectory + userID + ".json")}], creating it.";
                return new PlayerInfo();
            }
            var json = File.ReadAllText(NewDirectory + userID + ".json");
            return JsonConvert.DeserializeObject<PlayerInfo>(json) ?? new PlayerInfo();
        }

        void SavePlayerData(BasePlayer player)
        {
            if (!Directory.Exists(NewDirectory)) Directory.CreateDirectory(NewDirectory);
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData))
            {
                PlayerDataLogs += $"\nData was was not found for {player.userID} during SavePlayerData. Creating new data.";
                playerData = new PlayerInfo();
            }

            var json = JsonConvert.SerializeObject(playerData);
            File.WriteAllText(NewDirectory + $"{player.userID}.json", json);
            //Puts($"Saved data for {player.userID}. PEntity count: {pcdData.pEntity.Count}");
        }

        void SavePlayerDataFile(ulong userid, PlayerInfo playerData)
        {
            if (!Directory.Exists(NewDirectory)) Directory.CreateDirectory(NewDirectory);
            var json = JsonConvert.SerializeObject(playerData);
            File.WriteAllText(NewDirectory + $"{userid}.json", json);
        }

#if CARBON
		string FileDirectory = Carbon.Core.Defines.GetDataFolder() + Path.DirectorySeparatorChar;
        string NewDirectory = Carbon.Core.Defines.GetDataFolder() + Path.DirectorySeparatorChar + "SkillTree" + Path.DirectorySeparatorChar;
#else
        string FileDirectory = Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar;
        string NewDirectory = Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + "SkillTree" + Path.DirectorySeparatorChar;
#endif


        class PluginInfo
        {
            public DateTime wipeTime = DateTime.MinValue;
            public ulong HighestPlayer;
            public DateTime nextXPCapReset = DateTime.MinValue;
            public bool updated = false;

            [NonSerialized]
            public Dictionary<ulong, PlayerInfo> pEntity = new Dictionary<ulong, PlayerInfo>();

            [JsonConstructor]
            public PluginInfo()
            {

            }

            public PluginInfo(DateTime _wipeTime, ulong highestPlayer, Dictionary<ulong, PlayerInfo> _pentity)
            {
                wipeTime = _wipeTime;
                HighestPlayer = highestPlayer;
                pEntity = _pentity;
            }
        }

        PlayerInfo GetOfflinePlayerInfo(string userid)
        {
            if (!File.Exists(NewDirectory + $"{userid}.json")) return null;
            return JsonConvert.DeserializeObject<PlayerInfo>(File.ReadAllText(NewDirectory + $"{userid}.json"));
        }

        bool GetOfflinePlayerinfo(string userid, out PlayerInfo data)
        {
            data = null;
            if (!File.Exists(NewDirectory + $"{userid}.json")) return false;
            data = JsonConvert.DeserializeObject<PlayerInfo>(File.ReadAllText(NewDirectory + $"{userid}.json"));
            return data != null;
        }

        PlayerInfo LoadOfflinePlayerInfo(string path, bool checkExists)
        {
            if (checkExists && !File.Exists(path)) return null;
            return JsonConvert.DeserializeObject<PlayerInfo>(File.ReadAllText(path));
        }

        void WriteJson(string userid, string json) => File.WriteAllText(NewDirectory + $"{userid}.json", json);

        class PlayerInfo
        {
            public string name;
            public double xp;
            public int prestige_level;

            [NonSerialized]
            public float prestige_xp_mod = 1;

            public int current_level;
            public int achieved_level;
            public int available_points;
            public int non_level_related_points_given;
            public Dictionary<string, int> buff_values = new Dictionary<string, int>();
            public bool xp_drops = true;
            public bool xp_hud = true;
            public bool better_chat_enabled = true;
            //public xp_bar_offset xp_hud_pos = new xp_bar_offset();
            public Vector2 xp_bar_offset = Vector2.zero;
            public List<ItemInfo> pouch_items = new List<ItemInfo>();
            public DateTime logged_off = DateTime.Now;
            public double xp_bonus_pool;
            public bool extra_pockets_button = true;
            public bool notifications = true;
            public Dictionary<Buff, UltimatePlayerSettings> ultimate_settings = new Dictionary<Buff, UltimatePlayerSettings>();
            public string plant_genes = "gggggg";
            public float respec_multiplier = 0;
            public DateTime raiding_ultimate_used_time = DateTime.MinValue;
            public DateTime cooking_ultimate_used_time = DateTime.MinValue;
            public DateTime Trap_Spotter_used_time = DateTime.MinValue;
            public DateTime Loot_Spotter_used_time = DateTime.MinValue;
            public double xp_debt;
            public DateTime last_xp_loss;
            public double pending_xp_with_bonus;
            public double pending_xp_without_bonus;
            public HashSet<Buff> DisabledBuffs = new HashSet<Buff>();
            public Presets presets;
            public bool ignoreWarning = false;
            public double gained_today = 0;
            public bool notifiedOfCap = false;
            public DateTime nextXPCapReset;
            public int GetTotalSkillPoints
            {
                get
                {
                    return available_points + buff_values.Sum(x => x.Value);
                }
            }
        }

        public class UltimatePlayerSettings
        {
            public bool enabled = true;

        }

        public class xp_bar_offset
        {
            public float min_x;
            public float min_y;
            public float max_x;
            public float max_y;
        }

        public class XP_Bar_Anchors
        {
            public string anchor_min = "1 0";
            public string anchor_max = "1 0";
        }

        public ScoreboardInfo ScoreBoard = new ScoreboardInfo();

        public class ScoreboardInfo
        {
            public float lastChecked;
            public Dictionary<ulong, ScoreInfo> data;
            public List<KeyValuePair<ulong, ScoreInfo>> orderedList = new List<KeyValuePair<ulong, ScoreInfo>>();

            public class ScoreInfo
            {
                public string name;
                public double xp;
                public int prestige;
                public ulong pres_skin;
                public ScoreInfo(string name, double xp, int prestige, ulong pres_skin)
                {
                    this.name = name;
                    this.xp = xp;
                    this.prestige = prestige;
                    this.pres_skin = pres_skin;
                }
            }

            public void UpdateScores()
            {
                orderedList.Clear();
                if (Instance.config.misc_settings.scoreBoardSettings.maxScores > 0)
                {
                    var count = 0;
                    foreach (var score in data.OrderByDescending(x => x.Value.prestige).ThenByDescending(x => x.Value.xp))
                    {
                        orderedList.Add(score);
                        count++;
                        if (count > Instance.config.misc_settings.scoreBoardSettings.maxScores)
                            break;
                    }
                }
                else orderedList.AddRange(data.OrderByDescending(x => x.Value.prestige).ThenByDescending(x => x.Value.xp));
            }

            public void Wipe()
            {
                data?.Clear();
                orderedList?.Clear();
            }
        }

        Dictionary<ulong, TreeInfo> TreeData = new Dictionary<ulong, TreeInfo>();

        class TreeInfo
        {
            public Dictionary<string, NodesInfo> trees = new Dictionary<string, NodesInfo>();
            public int total_points_spent;
        }

        class NodesInfo
        {
            public int min_level;
            public int min_points;
            public int points_spent;
            public int min_prestige;
            public Dictionary<int, int> point_requirements = new Dictionary<int, int>();
            public Dictionary<string, NodeInfo> nodes = new Dictionary<string, NodeInfo>();
        }

        class NodeInfo
        {
            public string description;
            public int level_current;
            public int level_max;
            public int tier;
            public float value_per_buff;
            public KeyValuePair<Buff, BuffType> buffInfo;
            public int min_prestige;
            public int min_level;
            public string required_skill;
            public string excluded_skill;
            public string permission_required;

            [NonSerialized]
            public HashSet<string> exclusions = new HashSet<string>();
        }

        Dictionary<ulong, HorseInfo> HorseStats = new Dictionary<ulong, HorseInfo>();
        public class HorseInfo
        {
            public RidableHorse horse;
            public BasePlayer player;
            public float mod;
            public HorseInfo(BasePlayer player, RidableHorse horse, float mod)
            {
                this.player = player;
                this.horse = horse;
                this.mod = mod;
            }
        }

        Dictionary<ulong, MiniInfo> MiniStats = new Dictionary<ulong, MiniInfo>();
        public class MiniInfo
        {
            public PlayerHelicopter mini;
            public float old_lift_fraction;
            public BasePlayer player;
            public float old_engineThrustMax;

            public MiniInfo(BasePlayer player, PlayerHelicopter mini, float old_lift_fraction, float old_engineThrustMax)
            {
                this.player = player;
                this.mini = mini;
                this.old_lift_fraction = old_lift_fraction;
                this.old_engineThrustMax = old_engineThrustMax;
            }
        }

        private FieldInfo Engine = typeof(Bike).GetField("engineKW", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        Dictionary<ulong, BikeInfo> BikeStats = new Dictionary<ulong, BikeInfo>();
        public class BikeInfo
        {
            public Bike bike;
            public int oldKW;
            public BasePlayer player;

            public BikeInfo(BasePlayer player, Bike bike, int oldKW)
            {
                this.player = player;
                this.bike = bike;
                this.oldKW = oldKW;
            }
        }

        [ConsoleCommand("sttogglebuffs")]
        void ToggleSkillTreeBuffs(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, perm_admin)) return;

            if (arg.Args == null || arg.Args.Length == 0 || !bool.TryParse(arg.Args[0], out var enable))
            {
                arg.ReplyWith("Usage: sttogglebuffs <true/false> - true: enables buffs globally. false: disables buffs globally");
                return;
            }
            if (enable)
            {
                if (BuffsDisabledGlobally)
                {
                    BuffsDisabledGlobally = false;
                    arg.ReplyWith("Enabled buffs globally.");
                }
                else arg.ReplyWith("Buffs are already enabled globally.");
            }
            else
            {
                if (!BuffsDisabledGlobally)
                {
                    BuffsDisabledGlobally = true;
                    arg.ReplyWith("Disabled buffs globally.");
                }
                else arg.ReplyWith("Buffs are already disabled globally.");
            }
        }

        public bool BuffsDisabledGlobally = false;
        public bool BuffsDisabled = false;
        public List<ulong> DisabledPlayers = new List<ulong>();
        public List<ulong> DisabledXP = new List<ulong>();
        public bool GetBuffDetails(ulong id, out BuffDetails buffData, bool bypassDisabled = false)
        {
            if ((BuffsDisabledGlobally || (BuffsDisabled && DisabledPlayers.Contains(id))) && !bypassDisabled)
            {
                buffData = null;
                return false;
            }
            return buffDetails.TryGetValue(id, out buffData);
        }

        [HookMethod("DisableBuffs")]
        public void DisableBuffs(ulong id)
        {
            if (!DisabledPlayers.Contains(id))
            {
                var player = BasePlayer.FindByID(id);
                if (player == null) return;
                SetRegenBlock(player, true);
                SetAwarenessBlock(player, true);
                SetWaterBreathingBlock(player, true);
                SetInstantUntieBlock(player, true);
                SetComfortBlock(player, true);
                SetMobileWorkbenchBlock(player, true);
            }
            DisabledPlayers.Add(id);
            if (!BuffsDisabled) BuffsDisabled = true;
        }

        [HookMethod("EnableBuffs")]
        public void EnableBuffs(ulong id)
        {
            DisabledPlayers.Remove(id);
            if (!DisabledPlayers.Contains(id))
            {
                var player = BasePlayer.FindByID(id);
                if (player != null)
                {
                    SetRegenBlock(player, false);
                    SetAwarenessBlock(player, false);
                    SetWaterBreathingBlock(player, false);
                    SetInstantUntieBlock(player, false);
                    SetComfortBlock(player, false);
                    SetMobileWorkbenchBlock(player, false);
                }
            }
            if (BuffsDisabled && DisabledPlayers.Count == 0) BuffsDisabled = false;
        }

        [HookMethod("DisableXP")]
        public void DisableXP(ulong id)
        {
            DisabledXP.Add(id);
        }

        [HookMethod("EnableXP")]
        public void EnableXP(ulong id)
        {
            DisabledXP.Remove(id);
        }

        [HookMethod("IsXPDisabled")]
        public bool IsXPDisabled(ulong id)
        {
            return DisabledXP.Contains(id);
        }

        public Dictionary<ulong, BuffDetails> buffDetails = new Dictionary<ulong, BuffDetails>();
        public class BuffDetails
        {
            public BasePlayer player;
            public BuffDetails(BasePlayer player)
            {
                this.player = player;
            }

            private Dictionary<Buff, BuffInfo> buff_values = new Dictionary<Buff, BuffInfo>();
            public Dictionary<Buff, TemporaryBuff> temp_buff_values = new Dictionary<Buff, TemporaryBuff>();

            public float cooldown_Woodcutting_Ultimate;
            public float cooldown_Double_Bandage_Heal;
            public float cooldown_Wounded_Resist;

            public Dictionary<Buff, BuffInfo> GetBuffs()
            {
                return buff_values;
            }

            public Dictionary<Buff, BuffInfo> GetAllBuffs()
            {
                if (temp_buff_values.Count == 0) return buff_values;
                Dictionary<Buff, BuffInfo> result = new Dictionary<Buff, BuffInfo>();
                foreach (var buff in buff_values)
                    result.Add(buff.Key, buff.Value);

                foreach (var buff in temp_buff_values)
                {
                    if (result.TryGetValue(buff.Key, out var buffData))
                        buffData.value += buff.Value.buffInfo.value;
                    else result.Add(buff.Key, buff.Value.buffInfo);
                }

                return result;
            }

            public bool GetBuff(Buff buff, out float result)
            {
                result = 0;
                if (temp_buff_values.TryGetValue(buff, out var tempData) && tempData.buffInfo.enabled) result += tempData.buffInfo.value;
                if (buff_values != null && buff_values.TryGetValue(buff, out var buffData) && buffData.enabled) result += buffData.value;
                return result > 0;
            }

            public bool GetBuffInfo(Buff buff, out BuffInfo buffData)
            {
                buffData = null;
                if (buff_values == null || !buff_values.TryGetValue(buff, out buffData)) return false;
                return true;
            }

            public bool ContainsBuff(Buff buff)
            {
                return buff_values.ContainsKey(buff) || temp_buff_values.ContainsKey(buff);
            }

            public float GetBuffValue(Buff buff)
            {
                float result = 0;
                if (buff_values.TryGetValue(buff, out var value)) result += value.value;
                if (temp_buff_values.TryGetValue(buff, out var tempData)) result += tempData.buffInfo.value;
                return result;
            }

            public void RemoveBuff(Buff buff, float amount)
            {
                if (!buff_values.TryGetValue(buff, out var data)) return;
                if (data.value <= amount)
                {
                    buff_values.Remove(buff);
                    return;
                }
                data.value -= amount;
            }

            public void AddBuff(Buff buff, float buffValue)
            {
                if (!buff_values.TryGetValue(buff, out var value)) buff_values.Add(buff, value = new BuffInfo(buffValue, true));
                else value.value += buffValue;
            }

            public void ClearBuffs()
            {
                buff_values.Clear();
            }            
        }

        // Do not use this hookmethod without written approval.
        [HookMethod("AddTempBuff")]
        public bool AddTempBuff(BasePlayer player, string plugin, string buffString, float value, bool allowStacking, bool allowOverride)
        {
            if (value <= 0) return false;
            if (!buffDetails.TryGetValue(player.userID, out var buffData)) return false;
            if (!Enum.TryParse<Buff>(buffString, out var buff)) return false;
            if (!buffData. temp_buff_values.TryGetValue(buff, out var tempData)) buffData.temp_buff_values.Add(buff, tempData = new TemporaryBuff());
            if (!tempData.AddBuff(plugin, value, allowStacking, allowOverride)) return false;

            if (IsBehaviourSkill(buff) && pcdData.pEntity.TryGetValue(player.userID, out var playerData))
            {
                SetupSkills(player, buffData, playerData);
            }
            return true;
        }

        // Do not use this hookmethod without written approval.
        [HookMethod("RemoveTempBuff")]
        public bool RemoveTempBuff(BasePlayer player, string plugin, string buffString, float value)
        {
            if (value <= 0) return false;
            if (!buffDetails.TryGetValue(player.userID, out var buffData)) return false;
            if (!Enum.TryParse<Buff>(buffString, out var buff)) return false;
            if (!buffData.temp_buff_values.TryGetValue(buff, out var tempData)) return true;
            tempData.RemoveBuff(plugin, value, out var shouldRemove);
            if (shouldRemove) buffData.temp_buff_values.Remove(buff);
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData)) return false;
            CheckRemoveBehaviour(player, buffData, playerData, buff);
            return true;
        }

        [HookMethod("RemoveAllTempBuffs")]
        public void RemoveAllTempBuffs(string plugin)
        {
            foreach (var buffData in buffDetails.Values)
            {                
                try
                {
                    if (!pcdData.pEntity.TryGetValue(buffData.player.userID, out var playerData)) continue;
                    for (int i = buffData.temp_buff_values.Count - 1; i >= 0; i--)
                    {
                        var buff = buffData.temp_buff_values.ElementAt(i);
                        if (buff.Value.GetSourceValue(plugin, out var value))
                        {
                            buff.Value.RemoveBuff(plugin, value, out var shouldDelete);
                            CheckRemoveBehaviour(buffData.player, buffData, playerData, buff.Key);
                            if (shouldDelete) buffData.temp_buff_values.Remove(buff.Key);
                        }
                    }
                }
                catch { }
            }
        }

        public class TemporaryBuff
        {
            public BuffInfo buffInfo = new BuffInfo(0);
            private Dictionary<string, float> sources = new Dictionary<string, float>();

            public bool AddBuff(string plugin, float amount, bool allowStacking, bool allowOverride)
            {
                if (sources.TryGetValue(plugin, out var currentValue))
                {
                    if (!allowStacking)
                    {
                        if (!allowOverride || currentValue > amount) return false;
                        sources[plugin] = amount;
                    }
                    else sources[plugin] += amount;
                }
                else sources.Add(plugin, amount);
                buffInfo.value += amount;

                return true;
            }

            public void RemoveBuff(string plugin, float amount, out bool shouldRemove)
            {
                shouldRemove = false;
                if (!sources.TryGetValue(plugin, out var value)) return;                
                if (amount >= value)
                {
                    buffInfo.value -= value;
                    sources.Remove(plugin);
                    shouldRemove = true;
                }
                else
                {
                    buffInfo.value -= amount;
                    sources[plugin] -= amount;                    
                }
            }

            public bool GetSourceValue(string plugin, out float value)
            {
                value = 0;
                return sources.TryGetValue(plugin, out value);
            }
        }

        public class BuffInfo
        {
            public float value;
            public bool enabled;
            public BuffInfo(float value, bool enabled = true)
            {
                this.value = value;
                this.enabled = enabled;
            }

            public float GetValue()
            {
                if (!enabled) return 0;
                return value;
            }

            public void SetEnabled(BasePlayer player, Buff buff, bool shouldEnable)
            {
                if (enabled)
                {
                    if (shouldEnable) return;
                    Instance.CheckRequirements(player, buff, value, shouldEnable);
                }
                else
                {
                    if (!shouldEnable) return;
                    Instance.CheckRequirements(player, buff, value, shouldEnable);
                }

                enabled = shouldEnable;
            }
        }

        Dictionary<string, Buff> BuffTypes = new Dictionary<string, Buff>();

        Dictionary<ulong, BoatInfo> Boats = new Dictionary<ulong, BoatInfo>();

        class BoatInfo
        {
            public float defaultSpeed;
            public MotorRowboat boat;
            public BasePlayer player;
            public BoatInfo(BasePlayer player, MotorRowboat boat, float defaultSpeed)
            {
                this.player = player;
                this.boat = boat;
                this.defaultSpeed = defaultSpeed;
            }
        }

        Dictionary<string, ItemBlueprint> item_BPs = new Dictionary<string, ItemBlueprint>();
        Dictionary<string, ItemDefinition> ItemDefs = new Dictionary<string, ItemDefinition>();

        List<ulong> notifiedPlayers = new List<ulong>();

        public float default_heli_fuel_rate = 0.5f;
        public float default_rowboat_fuel_rate = 0.1f;
        public float default_rhib_fuel_rate = 0.25f;

        #endregion

        #region Enums

        [JsonConverter(typeof(StringEnumConverter))]
        public enum XPLossType
        {
            PercentageOfCurrentLevel,
            PercentageOfTotalXp,
            XpValue
        }

        [JsonConverter(typeof(StringEnumConverter))]
        public enum BuffType
        {
            IO,
            Percentage,
            Seconds,
            PerSecond,
            Slots,
            Permission,
            Level,
            Distance
        }

        [JsonConverter(typeof(StringEnumConverter))]
        public enum Buff
        {
            None,
            Mining_Yield,
            Instant_Mine,
            Smelt_On_Mine,
            Mining_Luck,
            Mining_Tool_Durability,
            Woodcutting_Yield,
            Instant_Chop,
            Woodcutting_Luck,
            Woodcutting_Coal,
            Woodcutting_Tool_Durability,
            Skinning_Yield,
            Instant_Skin,
            Skinning_Tool_Durability,
            Skin_Cook,
            Harvest_Wild_Yield,
            Harvest_Grown_Yield,
            Extra_Fish,
            Double_Bandage_Heal,
            Radiation_Reduction,
            Extra_Food_Water,
            Fire_Damage_Reduction,
            Fall_Damage_Reduction,
            No_Cold_Damage,
            Wounded_Resist,
            Animal_Damage_Resist,
            Riding_Speed,
            Free_Bullet_Chance,
            Primitive_Expert,
            Upgrade_Refund,
            Craft_Speed,
            Research_Refund,
            Craft_Refund,
            Extra_Scrap_Barrel,
            Barrel_Smasher,
            Extra_Scrap_Crate,
            Component_Chest,
            Electronic_Chest,
            Component_Barrel,
            Electronic_Barrel,
            Melee_Resist,
            Iron_Stomach,
            Boat_Speed,
            Recycler_Speed,
            Smelt_Speed,
            Heli_Fuel_Rate,
            Boat_Fuel_Rate,
            Vehicle_Mechanic,
            Reviver,
            Rationer,
            PVP_Critical,
            PVP_Damage,
            PVP_Shield,
            Metabolism_Boost,
            Loot_Pickup,
            Node_Spawn_Chance,
            HealthRegen,
            Awareness,
            AnimalTracker,
            ExtraPockets,
            Human_NPC_Damage,
            Animal_NPC_Damage,
            Human_NPC_Defence,
            Craft_Duplicate,
            WaterBreathing,
            SharkResistance,
            SharkSkinner,
            DeepSeaLooter,
            InstantUntie,
            UnderwaterDamageBonus,
            Permission,
            MaxRepair,
            Durability,
            Regrowth,
            Skinning_Luck,
            Fishing_Luck,
            Extended_Mag,

            // Raid tree perks
            Trap_Damage_Reduction,
            Trap_Damage_Increase,
            Personal_Explosive_Reduction,
            Building_Damage_Increase,
            Double_Explosion_Chance,
            Lock_Picker,
            Explosion_Radius,
            Dudless_Explosive,

            Woodcutting_Hotspot,
            Mining_Hotspot,
            Extended_Tea_Duration,
            Tea_Looter,
            Bite_Speed,
            Heli_Speed,
            Forager,
            Trap_Spotter,
            Loot_Spotter,
            Rod_Tension_Bonus,
            Spawn_Health,
            Sonar,

            Comfort,
            Heal_Share,
            XP_Share,
            Tea_Share,
            Metabolism_Share,
            Human_Workbench,

            Recycler_Efficiency,
            Metal_Detector_Luck,
            Efficient_Digger,
            Magnetic_Digger,

            RadiationResistModifier,
            RadiationBaseValue,

            BikeEnginePower,
            DriverCollisionResistance,

            Harvesting_Luck,

            Cooking_Speed,
            Rocket_Velocity,
            Armor_Slots,
            Shield_Reflect,
            Free_Repairs,

            Bradley_Damage_Bonus,
            Heli_Damage_Bonus,

            Woodcutting_Ultimate = 991,
            Mining_Ultimate = 992,
            Combat_Ultimate = 993,
            Vehicle_Ultimate = 994,
            Harvester_Ultimate = 995,
            Medical_Ultimate = 996,
            Skinning_Ultimate = 997,
            Build_Craft_Ultimate = 998,
            Scavengers_Ultimate = 999,
            Raiding_Ultimate = 1000,
            Cooking_Ultimate = 1001
        }

        [JsonConverter(typeof(StringEnumConverter))]
        public enum YieldTypes
        {
            Wood,
            Stone,
            Metal,
            HQM,
            Sulfur,
            Corn,
            Potato,
            Pumpkin,
            Cloth,
            Diesel,
            AnimalFat,
            Bones,
            Leather,
            Fish,
            Seed,
            Mushroom,
            Berry,
            Meat,
            Wheat,
            Sunflower,
            Orchid,
            Rose
        }

        [JsonConverter(typeof(StringEnumConverter))]
        public enum RespecType
        {
            Disabled,
            All,
            Tree
        }

        [JsonConverter(typeof(StringEnumConverter))]
        public enum MessageType
        {
            None,
            Chat,
            CUISuccess,
            CUIWarn,
            CUINormal
        }

        //public string[] Trees = { "Mining", "Woodcutting", "Skinning", "Harvesting", "Combat", "Medical", "Build_Craft", "Scavenging", "Vehicles", "Cooking"};

        #endregion

        #region Localization

        void LoadMessages()
        {
            List<Buff> buffs = Pool.Get<List<Buff>>();
            buffs.AddRange(Enum.GetValues(typeof(Buff)).Cast<Buff>());
            Dictionary<string, string> buffMessages = new Dictionary<string, string>();
            foreach (var buff in buffs)
            {
                var str = buff.ToString();
                if (!buffMessages.ContainsKey("UI" + str)) buffMessages.Add("UI" + str, str.Replace("_", " "));
            }

            Pool.FreeUnmanaged(ref buffs);

            List<string> titles = Pool.Get<List<string>>();
            titles.AddRange(config.trees.Keys);
            Dictionary<string, string> TitleMessages = new Dictionary<string, string>();
            foreach (var title in titles)
            {
                if (!TitleMessages.ContainsKey(title)) TitleMessages.Add(title, title.Replace("_", " "));
            }
            Pool.FreeUnmanaged(ref titles);
            List<string> node_names = Pool.Get<List<string>>();
            Dictionary<string, string> permission_descriptions = new Dictionary<string, string>();
            foreach (var entry in config.trees)
            {
                foreach (var node in entry.Value.nodes)
                {
                    if (!node_names.Contains(node.Key)) node_names.Add(node.Key);
                    if (node.Value.permissions == null || string.IsNullOrEmpty(node.Value.permissions.description)) continue;
                    var perm = node.Key + ".permission";
                    if (permission_descriptions.ContainsKey(perm)) continue;
                    permission_descriptions.Add(perm, node.Value.permissions.description);
                }
            }
            foreach (var node in node_names)
            {
                if (!TitleMessages.ContainsKey(node)) TitleMessages.Add(node, node);
            }
            Pool.FreeUnmanaged(ref node_names);            

            Dictionary<string, string> DefaultMessages = new Dictionary<string, string>()
            {
                ["None"] = "This has no buffs.",
                ["Mining_Yield"] = "This skill increases your mining yield by <color=#42f105>{0}%</color> per level.",
                ["Instant_Mine"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to instantly mine out a node on hit.",
                ["Smelt_On_Mine"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to refine the mined ore.",
                ["Mining_Luck"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to receive a random item when you mine out a node.",
                ["Skinning_Luck"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to receive a random item when you skin out a corpse.",
                ["Harvesting_Luck"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to receive a random item when you collect items.",
                ["Fishing_Luck"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to receive a random item when you catch a fish.",
                ["Metal_Detector_Luck"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to receive a random item when you dig up a cache that has been found using a metal detector.",
                ["Mining_Tool_Durability"] = "This skill decreases the durability loss of your mining equipment by <color=#42f105>{0}%</color> per level.",
                ["Mining_Ultimate"] = "<color=#db03cb>ULTIMATE:</color> This skill allows you to locate nodes within a <color=#42f105>{0}m</color> radius.",
                ["Medical_Ultimate"] = "<color=#db03cb>ULTIMATE:</color> This skill gives you a <color=#42f105>{0}%</color> chance to resurrect at your last place of death.",
                ["Harvester_Ultimate"] = "<color=#db03cb>ULTIMATE:</color> This skill gives you the ability to set the genetic composition for plants you deploy{0}.",
                ["Woodcutting_Yield"] = "This skill increases your woodcutting yield by <color=#42f105>{0}%</color> per level.",
                ["Instant_Chop"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to instantly chop a tree down on hit.",
                ["Regrowth"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to respawn a chopped tree.",
                ["Woodcutting_Luck"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to receive a random item when you cut down a tree.",
                ["Woodcutting_Coal"] = "This skill gives you a <color=#42f105>{0}%</color> chance to receive some charcoal while woodcutting.",
                ["Woodcutting_Tool_Durability"] = "This skill decreases the durability loss of your woodcutting equipment by <color=#42f105>{0}%</color> per level.",
                ["Woodcutting_Ultimate"] = "<color=#db03cb>ULTIMATE:</color> This skill will harvest surrounding trees in a <color=#42f105>{0}m</color> radius when you cut a tree down.",
                ["Skinning_Ultimate"] = "<color=#db03cb>ULTIMATE:</color> Killing an animal while this skill is active will give you a temporary buff. <color=#42f105>{0}</color>",
                ["Combat_Ultimate"] = "<color=#db03cb>ULTIMATE:</color> This skill will heal you for <color=#42f105>{0}%</color> of the damage done to certain enemies. Enemies: {1}",
                ["Scavengers_Ultimate"] = "<color=#db03cb>ULTIMATE:</color> This skill automatically recycles components from barrels when broken.",
                ["Build_Craft_Ultimate"] = "<color=#db03cb>ULTIMATE:</color> This skill will allow you to use any coloured swipe card in any reader to access it{0}.",
                ["Skinning_Yield"] = "This skill increases your skinning yield by <color=#42f105>{0}%</color> per level.",
                ["Instant_Skin"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to instantly skin out the animal on hit.",
                ["Skinning_Tool_Durability"] = "This skill decreases the durability loss of your skinning equipment by <color=#42f105>{0}%</color> per level",
                ["Skin_Cook"] = "This skill gives you a <color=#42f105>{0}%</color> per level chance of receiving your meat cooked, rather than raw, while skinning.",
                ["Permission"] = "",
                ["Harvest_Wild_Yield"] = "This skill increases your harvesting yield by <color=#42f105>{0}%</color> per level while harvesting wild collectibles.",
                ["Harvest_Grown_Yield"] = "This skill increases your harvesting yield by <color=#42f105>{0}%</color> per level while harvesting grown plants.",
                ["Extra_Fish"] = "This skill gives you a <color=#42f105>{0}%</color> per level chance of receiving an extra fish when you catch a fish.",
                ["Double_Bandage_Heal"] = "This skill will double the amount of healing received from bandages.",
                ["Radiation_Reduction"] = "This skill will reduce radiation damage received by <color=#42f105>{0}%</color> per level.",
                ["Extra_Food_Water"] = "This skill will increase the amount of calories and hydration received by <color=#42f105>{0}%</color> per level when eating food.",

                ["WaterBreathing"] = "This skill will allow you to breath underwater for <color=#42f105>{0} seconds</color> per level.",
                ["SharkResistance"] = "This skill will reduce the damage received from sharks by <color=#42f105>{0}%</color> per level.",
                ["SharkSkinner"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level of finding a useful item when skinning a shark.",
                ["DeepSeaLooter"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level of finding a useful item when looting crates underwater.",
                ["InstantUntie"] = "This skill allows you to instantly untie underwater crates.",
                ["UnderwaterDamageBonus"] = "This skill increases the damage done while you are underwater by <color=#42f105>{0}%</color> per level.",

                ["Fire_Damage_Reduction"] = "This skill will reduce fire damage by <color=#42f105>{0}%</color> per level.",
                ["Fall_Damage_Reduction"] = "This skill will reduce fall damage by <color=#42f105>{0}%</color> per level.",
                ["No_Cold_Damage"] = "This skill prevents you from being damaged by the cold.",
                ["Wounded_Resist"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level of immediately getting up after being wounded.",
                ["Animal_Damage_Resist"] = "This skill reduces the damage taken by animals by <color=#42f105>{0}%</color> per level.",
                ["Riding_Speed"] = "This skill increases the speed of your mounted horse by <color=#42f105>{0}%</color> per level.",
                ["Free_Bullet_Chance"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level of not using a bullet while firing.",
                ["Primitive_Expert"] = "This skill makes primitive weapons lose no durability.",
                ["Upgrade_Refund"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level of receiving your building materials back when upgrading your building blocks.",
                ["Craft_Speed"] = "This skill increases your crafting speed by <color=#42f105>{0}%</color> per level.",
                ["MaxRepair"] = "This skill will reset the durability of items to max when repairing them.",
                ["Free_Repairs"] = "This skill will allow you to repair your items for free.",
                ["Durability"] = "This skill reduces durability loss by <color=#42f105>{0}%</color> per level.",
                ["Smelt_Speed"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to smelt ore when a log is burned, in addition to the normal smelt rate.",
                ["Research_Refund"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level of receiving your scrap back when researching.",
                ["Craft_Refund"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level of receiving your components back when crafting.",
                ["Craft_Duplicate"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level of duplicating an item while crafting.",
                ["Extra_Scrap_Barrel"] = "This skill gives you <color=#42f105>{0}%</color> chance per level to receive extra scrap when smashing a barrel.",
                ["Barrel_Smasher"] = "This skill allows you to smash a barrel in 1 hit with any weapon.",
                ["Loot_Pickup"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to add the loot straight into your inventory when destroying a barrel",
                ["Node_Spawn_Chance"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to spawn a new node after a node is destroyed.",
                ["HealthRegen"] = "This skill regenerates your health by <color=#42f105>{0}hp</color> per level per second.",
                ["Awareness"] = "This skill shows the location of certain objects within <color=#42f105>{0}m</color> per level.",
                ["Extra_Scrap_Crate"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level of finding extra scrap in a crate, the first time you loot it.",
                ["Component_Chest"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level of finding components in a crate, the first time you loot it.",
                ["Electronic_Chest"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level of finding electronics in a crate, the first time you loot it.",
                ["Component_Barrel"] = "This skill gives you <color=#42f105>{0}%</color> chance per level of finding extra components when destroying barrels.",
                ["Electronic_Barrel"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level of finding extra electronics when destroying barrels.",
                ["Melee_Resist"] = "This skill will reduce melee damage by <color=#42f105>{0}%</color> per level.",
                ["Iron_Stomach"] = "This skill will prevent you from being sick when consuming raw and spoiled food.",
                ["Recycler_Speed"] = "This skill will increase your recycling tick speed by {0} seconds per level",
                ["Recycler_Efficiency"] = "This skill will increase your recycling efficiency by <color=#42f105>{0}%</color> per level.",
                ["Efficient_Digger"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to automatically dig up detected caches when they are flagged.",
                ["Magnetic_Digger"] = "This skill gives you a <color=#42f105>{0}%</color> chance per level to automatically collect dug up items.",
                ["Boat_Speed"] = "This skill will allow you to toggle your speed while in a boat by pressing mouse 3 or typing the turbo command. Increases your speed by <color=#42f105>{0}%</color> per level.",
                ["BoatSpeedAuto"] = "This skill will increase the speed of your mounted boat by <color=#42f105>{0}%</color> per level.",
                ["Heli_Fuel_Rate"] = "This skill will reduce your fuel consumption when flying a helicopter by <color=#42f105>{0}%</color> per level.",
                ["Boat_Fuel_Rate"] = "This skill will reduce your fuel consumption when using a boat by <color=#42f105>{0}%</color> per level.",
                ["Vehicle_Mechanic"] = "This skill will allow you to instantly repair vehicles at no cost.",
                ["Vehicle_Ultimate_IO"] = "<color=#db03cb>ULTIMATE:</color> This skill reduces damage dealt to your mounted vehicle by <color=#42f105>{0}%</color>.",
                ["Vehicle_Ultimate_Percentage"] = "<color=#db03cb>ULTIMATE:</color> This skill reduces damage dealt to your mounted vehicle by <color=#42f105>{0}%</color> per level.",
                ["Raiding_Ultimate"] = "<color=#db03cb>ULTIMATE:</color> This skill allows you to call in a MLRS strike.",
                ["Reviver"] = "This skill will heal a downed player when revived for <color=#42f105>{0}%</color> of their health per level.",
                ["PVP_Shield"] = "Reduce the damage receive in PVP by <color=#42f105>{0}%</color> per level.",
                ["Extended_Mag"] = "Increases the maximum ammo capacity of your weapons by <color=#42f105>{0}%</color> per level.",
                ["Tea_Looter"] = "This skill gives you a <color=#42f105>{0}%</color> per level of finding tea in food crates and boxes.",
                ["Bite_Speed"] = "This skill increases the speed to hook a fish while fishing by <color=#42f105>{0}%</color> per level.",
                ["Heli_Speed"] = "This skill increases the lift fraction of helicopters <color=#42f105>{0}%</color> per level.",
                ["BikeEnginePower"] = "This skill increases the engine power of bikes by <color=#42f105>{0}%</color> per level.",
                ["DriverCollisionResistance"] = "This skill decreases the the amount of damage taken when crashing by <color=#42f105>{0}%</color> per level.",
                ["Cooking_Speed"] = "This skill reduces cooking time at a cooking & mixing station by <color=#42f105>{0}%</color> per level.",
                ["Rocket_Velocity"] = "This skill increases the velocity of all rockets by <color=#42f105>{0}%</color> per level.",
                ["Armor_Slots"] = "This skill increases the minimum amount of armor slots items are crafted with by <color=#42f105>{0} slot</color> per level.",
                ["Shield_Reflect"] = "This provides you with a <color=#42f105>{0}%</color> chance per level of reflecting damage back at attackers when shot.",
                ["Shield_Reflect_Info"] = "\n<color=#ffff00>Bullet mod:</color> {0}%\n<color=#ffff00>Arrow mod:</color> {1}%",
                ["Forager"] = "This skill allows you to locate collectibles within a <color=#42f105>{0}m</color> radius.",
                ["Sonar"] = "This skill allows you to locate underwater objects within a <color=#42f105>{0}m</color> radius.",
                ["PVP_Critical"] = "This skill will give you a <color=#42f105>{0}%</color> chance per level of critically damaging a player in PVP when hit.",
                ["PVP_Damage"] = "This skill will increase the amount of damage you do in PVP by <color=#42f105>{0}%</color> per level.",
                ["Metabolism_Boost"] = "Increases your calories and hydration by <color=#42f105>{0}%</color> per level.",
                ["Rationer"] = "This skill will provide you with a <color=#42f105>{0}%</color> chance per level chance to receive your consumed items back.",
                ["AnimalTracker"] = "This skill will allow you to track the closest animal to you using the <color=#42f105>/track</color> command.",
                ["ExtraPockets"] = "This skill will provide you pouch that can be accessed via the <color=#42f105>/pouch</color> command. Storage is increased by <color=#42f105>{0}</color> slots per level.",
                ["Human_NPC_Damage"] = "This skill increases the damage done to human NPCs by <color=#42f105>{0}%</color> per level.",
                ["Human_NPC_Defence"] = "This skill decreases the damage done from scientists by <color=#42f105>{0}%</color> per level.",
                ["Animal_NPC_Damage"] = "This skill increases the damage done to animals by <color=#42f105>{0}%</color> per level.",
                ["Bradley_Damage_Bonus"] = "This skill increases the damage done to the Bradley Tank by <color=#42f105>{0}%</color> per level.",
                ["Heli_Damage_Bonus"] = "This skill increases the damage done to the Patrol Heli by <color=#42f105>{0}%</color> per level.",

                ["Trap_Damage_Reduction"] = "This skill reduces the damage taken from traps by <color=#42f105>{0}%</color> per level.",
                ["Trap_Damage_Increase"] = "This skill increases the damage against traps by <color=#42f105>{0}%</color> per level.",
                ["Personal_Explosive_Reduction"] = "This skill reduces the damage taken from your own explosives by <color=#42f105>{0}%</color> per level.",
                ["Double_Explosion_Chance"] = "This skill provides you with a <color=#42f105>{0}%</color> chance per level to have an explosive trigger twice.",
                ["Explosion_Radius"] = "Increases the radius of your explosives by <color=#42f105>{0}%</color> per level.",
                ["Lock_Picker"] = "Provides the player with a <color=#42f105>{0}%</color> chance per level to open a locked entity.",
                ["Dudless_Explosive"] = "Provides a <color=#42f105>{0}%</color> chance per level for a dud explosive to explode anyway.",
                ["Trap_Spotter"] = "Provides a <color=#42f105>{0}%</color> chance per level to see nearby traps.",
                ["Loot_Spotter"] = "Shows box storage containers within <color=#42f105>{0}m</color> per level.",
                ["Rod_Tension_Bonus"] = "Provides a <color=#42f105>{0}%</color> reduction per level to the rod tension when catching fish.",
                ["Spawn_Health"] = "This skill changes your starting health to <color=#42f105>{0}hp</color> when respawning.",
                ["Woodcutting_Hotspot_IO"] = "This skill will treat all hits on a tree as hotspot hits.",
                ["Woodcutting_Hotspot_Percentage"] = "This skill will provide you with a <color=#42f105>{0}%</color> chance per level for a hit on a tree to automatically hit the hotspot.",
                ["Mining_Hotspot_IO"] = "This skill will treat all hits on ore as hotspot hits.",
                ["Mining_Hotspot_Percentage"] = "This skill will provide you with a <color=#42f105>{0}%</color> chance per level for a hit on a node to automatically hit the hotspot.",
                ["Extended_Tea_Duration"] = "This skill will extend the duration of tea effects by <color=#42f105>{0}%</color> per level.",

                ["Comfort"] = "Provides you and surrounding team members with <color=#42f105>{0}%</color> of comfort per level.",
                ["Heal_Share"] = "Provides surrounding team members with <color=#42f105>{0}%</color> of healing you receive per level.",
                ["XP_Share"] = "Provides surrounding team members with <color=#42f105>{0}%</color> of the XP you gain per level.",
                ["Tea_Share"] = "Provides surrounding team members with <color=#42f105>{0}%</color> per level of bonuses that you receive when drinking tea.",
                ["Metabolism_Share"] = "Provides surrounding team members with <color=#42f105>{0}%</color> per level of calories and hydration that you receive when eating and drinking.",
                ["Human_Workbench"] = "Turns your character into a portable workbench for you and your team members. Workbench level scales based on skill level",

                ["RadiationBaseValue"] = "Provides you with a base radiation resistance of <color=#42f105>{0}%</color> per level, even when naked.",
                ["RadiationResistModifier"] = "Increases the effectiveness of your clothings radiation resistance by <color=#42f105>{0}%</color> per level.",

                ["ItemFound"] = "You found {0}x {1} hiding in the {2}.",
                ["ItemFoundOnly"] = "You found {0}x {1}.",
                ["ExtraFish"] = "You received {0} extra {1}!",
                ["CraftRefund"] = "You received a refund on your last craft.",
                ["DuplicateProc"] = "You received an additional <color=#42f105>[{0}]</color> while crafting.",
                ["IronTummy"] = "You eat the {0} and feel ok.",
                ["WoundSave"] = "Your ability prevent you from being wounded.",
                ["LostXP"] = "You lost {0} for dying.",
                ["FreeUpgrade"] = "You received a free upgrade!",
                ["ScrapRefund"] = "You received a scrap refund on your research.",
                ["LevelEarn"] = "You gained a level and earned {0} skill point.\nNew level: {1}",
                ["LevelEarnDiscord"] = "{0}[{1}] achieved level {2}.",
                ["PrestigeEarnDiscord"] = "{0}[{1}] achieved prestige rank {2}.",
                ["MorePlayersFound"] = "More than one player found: {0}",
                ["NoMatch"] = "No player was found that matched: {0}",
                ["MaxSP"] = "You have spent the maximum number of skill points allowed.",
                ["MaxedNode"] = "You have already maxed out this node.",
                ["NotEnoughPointsSpent"] = "You do not have enough points spent to unlock this tier.\nYou need {0} points to unlock this row.",
                ["MaxedSkillPoints"] = "You do not have enough skill points left to level this node.",
                ["AssignedMaxedSkillPoints"] = "You have already assigned the maximum skill points allowed.",
                ["UnlockedFirstNode"] = "You unlocked the {0} node [1/{1}]",
                ["UnlockedNode"] = "You gained a level in the {0} node [{1}/{2}]",
                ["NoPermsTree"] = "You do not have permission to access to the Skill Tree.",
                ["RespecNoScrap"] = "You do not have enough scrap to respec your skill tree.",
                ["EconNotLoaded"] = "Economics is not loaded. Contact your administrator.",
                ["EconNoCash"] = "You do not have enough cash to respec your skill tree.",
                ["EconErrorCash"] = "Error taking cash from your account.",
                ["SRNotLoaded"] = "ServerRewards is not loaded. Contact your administrator.",
                ["shoppystockNotLoaded"] = "ShoppyStock is not loaded. Contact your administrator.",
                ["SRNoPoints"] = "You do not have enough points to respec your skill tree.",
                ["shoppystockNotEnough"] = "You do not have enough currency to respec your skill tree.",
                ["SRPointError"] = "Error taking points from your account.",
                ["shoppystockCurrencyError"] = "Error taking currency from your account.",
                ["PaidRespec"] = "You paid {0} to respec.",
                ["RespecTree"] = "You paid {0} to respec the {1} tree.",
                ["NoPermsChat"] = "You do not permissions to use the skill tree chat command.",
                ["GiveXPUsage"] = "Usage: givexp <player> <amount>",
                ["GiveXPUsageConsole"] = "Usage: givexp <player> <amount> <optional: ignore modifiers [default: false]>",
                ["GiveXPDebtUsageConsole"] = "Usage: givexpdebt <player> <amount>",
                ["ResetXPUsage"] = "Usage: /resetdata <player>",
                ["ResetXPDebtUsage"] = "Usage: stresetxpdebt <id>",
                ["XPLastArg"] = "XP amount required as the last argument.",
                ["GaveXP"] = "You were given {0} xp by {1}",
                ["ReceivedXP"] = "You gave {0} {1} xp.",
                ["NoPermsXP"] = "You do not have permission to gain xp on this server.",
                ["PrintXPNone"] = "You are level {0} and have {1}/{2} xp.",
                ["Mining"] = "Mining",
                ["Woodcutting"] = "Woodcutting",
                ["Skinning"] = "Skinning",
                ["Harvesting"] = "Harvesting",
                ["Combat"] = "Combat",
                ["Medical"] = "Medical",
                ["Build_Craft"] = "Build Craft",
                ["Scavenging"] = "Scavenging",
                ["AccessReminder"] = "You can access the Skill Tree menu by typing: <color=#42f105>/{0}</color>",
                ["TurboToggleOn"] = "Toggled boat turbo on.",
                ["TurboToggleOff"] = "Toggled boat turbo off.",
                ["TurboInUse"] = "This boat is already being boosted.",
                ["RespecCost"] = "Respec Cost: <color=#ffb600>{0}</color>",
                ["RespecButton"] = "<color=#ffb600>Respec</color>",
                ["ResetData"] = "Reset the data for {0}.",
                ["ReceivedSP"] = "You received {0} skill points.\nNew available balance: {1}",
                ["GaveSP"] = "You gave {0} skill points to {1}.",
                ["GiveSPUsage"] = "Usage: givesp <player> <amount>",
                ["Rationed"] = "You managed to ration the <color=#ffb600>{0}</color> you just consumed.",
                ["PointsRefunded"] = "Your skill points have been refunded.",
                ["PointsRefundedAll"] = "Refunded all skill points.",
                ["NoPlayersSetup"] = "There are no players setup.",
                ["NodeSpawned"] = "A new node spawned in place of your old one thanks to your buff!",
                ["RespecNoCustom"] = "You do not have enough {0} for this.",
                ["UIToggleXP"] = "Toggle the xp indicator that is displayed when gaining xp.",
                ["ON"] = "ON",
                ["OFF"] = "OFF",
                ["UIToggleXPBar"] = "Toggle the xp pump bar.",
                ["RepositionBar"] = "Reposition the xp pump bar.",
                ["ToggleBagButton"] = "Toggle the ExtraPockets hud button.",
                ["UIClose"] = "CLOSE",
                ["UIChange"] = "CHANGE",
                ["UIResurrect"] = "RESURRECT",
                ["UIFailed"] = "FAILED",
                ["UIPlayerSettings"] = "Player Settings",
                ["TrackWait"] = "You must wait {0} seconds before your next tracking attempt.",
                ["NoAnimals"] = "No animals were found!",
                ["TrackFresh"] = "You see fresh animal tracks leading {0}.",
                ["TrackOlder"] = "You see slightly older animal tracks leading {0}.",
                ["TrackOldest"] = "You see old animal tracks leading {0}.",
                ["LevelReward"] = "You received {0} {1} for reaching level {2}.",
                ["UISkillTree"] = "Skill Tree",
                ["UIBuffInformation"] = "Buff Information",
                ["UITreePointsSpent"] = "Tree Points Spent:",
                ["UITotalPointsSpent"] = "Total Points Spent:",
                ["UIAvailablePoints"] = "Available Points:",
                ["UIPrestigeLevel"] = "Prestige Level:",
                ["UIRestedXPPool"] = "Rested XP Pool:",
                ["UICurrentLevel"] = "Current Level:",
                ["UIXP"] = "XP:",
                ["ButtonPlayerSettings"] = "Player Settings",
                ["ButtonBuffSettings"] = "Buff Settings",
                ["ButtonPresetSettings"] = "Preset Settings",
                ["UICost"] = "<color=#ffb600>COST:</color> {0}",
                ["UIScrap"] = "scrap",
                ["UIPoints"] = "points",
                ["UIShoppyStock"] = "currency",
                ["UIDollars"] = "$",
                ["UIDollarsWord"] = "dollars",
                ["UIAreYouSure"] = "Are you sure you want to respec your skills?",
                ["ButtonYes"] = "<color=#ffb600>YES</color>",
                ["ButtonNo"] = "<color=#ffb600>NO</color>",
                ["ToggleNotifications"] = "Receive notifications from the Skill Tree plugin when a buff triggers.",
                ["notificationsOff"] = "You will no longer receive notifications from buff triggers.",
                ["notificationsOn"] = "You will now receive notifications for buff triggers.",
                ["DisabledRegen"] = "Your regen has been disabled for <color=#ff8000>{0} seconds</color> after taking damage.",
                ["UIMaxLevel"] = "Maximum Level: <color=#ffb600>{0}</color>",
                ["UISelectedNode"] = "<color=#f481fa>{0}</color>",
                ["RestedNotification"] = "You feel rested and have a bonus xp rate of <color=#00b2ff>{0}%</color> for <color=#00b2ff>{1}</color> xp.",
                ["SharkStomachFound"] = "You find {0} <color=#42f105>{1}</color> in the sharks stomach.",
                ["some"] = "some",
                ["a"] = "a",
                ["HarvestUltiCDNotification"] = "Your harvesting ultimate is now on cooldown for {0} seconds.",
                ["BuildCraftFailNotify"] = "Your BuildCraft ultimate failed to unlock the door.",
                ["Build_Craft_Ultimate_DescriptionAddition"] = ".\n<color=#db03cb>Success chance per swipe:</color> {0}%",
                ["Harvesting_Ultimate_DescriptionAddition"] = ".\n<color=#db03cb>Cooldown:</color> {0} seconds",
                ["UltimateSettingsUIDescription"] = "Toggle your {0} Ultimate buff on or off",
                ["Build_Craft_formatted"] = "Build & Craft",
                ["UltimateToggleOnMining"] = "You can locate nodes within <color=#DFF008>{0}m</color> using the chat command: <color=#DFF008>{1}</color> once every <color=#DFF008>{2}</color> seconds.",
                ["UltimateToggleOnVehicle"] = "Your mounted vehicle will take <color=#DFF008>{0}%</color> less damage from all sources.",
                ["UltimateToggleOnMedical"] = "You will now have a <color=#DFF008>{0}%</color> chance of resurrecting at your place of death when you click the RESURRECT button on the death screen.",
                ["UltimateToggleOnHarvester"] = "Your plants will now be deployed with your desired gene set. Type <color=#DFF008>/{0}</color> to set your desired genes. Cooldown: <color=#DFF008>{1} seconds</color>.",
                ["UltimateToggleOnBuildCraft"] = "You can now use any coloured key card on a swipe card reader to access a door. Power is still required. Success chance: <color=#DFF008>{0}%</color>",
                ["UltimateToggleOnWoodcutting"] = "You will now cut down any tree in a <color=#DFF008>{0}m</color> radius.",
                ["UltimateToggleOnRaiding"] = "You can now use the <color=#DFF008>/{0}</color> command to call in an MLRS strike. Cooldown: <color=#DFF008>{1} minutes</color>.",
                ["UltimateToggleOnCooking"] = "You can now use the <color=#DFF008>/{0}</color> command to apply temporary tea buffs to yourself. Cooldown: <color=#DFF008>{1} minutes</color>.",
                ["UltimateToggleOnScavengers"] = "You will now receive recycled components whenever you destroy a barrel.",
                ["UltimateSettings"] = "<color=#ffb600>Ultimate Settings</color>",
                ["BlacklistedItemsFound"] = "Dropped black listed items to the floor: \n{0}",
                ["WhitelistedItemsNotFound"] = "Dropped non-white listed items to the floor: \n{0}",
                ["PumpBarLevelText"] = "<color=#fbff00>Lv.{0}:</color>",
                ["PumpBarDebtTitleText"] = "<color=#fbff00>DEBT:</color>",
                ["PumpBarXPText"] = "<color=#FFFFFF>{0} / {1}</color>",
                ["PumpBarXPTextDebt"] = "<color=#FFFFFF>{0}</color>",
                ["UINextArrow"] = "> >",
                ["UIBackArrow"] = "< <",
                ["FailReload"] = "SkillTree failed to find your player data. Please reconnect to the server...",
                ["TargetFailReload"] = "SkillTree failed to find the target players data. They will need to reconnect to the server for this command to work...",
                ["stgiveitemUsage"] = "Usage: /stgiveitem <target player id> <shortname> <quantity> <skin ID> <Optional: displayName>",
                ["stgiveitemInvalidID"] = "ID: {0} is invalid.",
                ["stgiveitemNoPlayerFound"] = "No player found that matched ID: {0}",
                ["stgiveitemInvalidShortname"] = "Shortname: {0} is invalid.",
                ["stgiveitemQuantityInvalid"] = "Quantity: {0} is invalid.",
                ["stgiveitemSkinInvalid"] = "Skin ID: {0} is invalid.",
                ["popupxpstring"] = "<color=#{0}>+{1} XP</color>",
                ["RegrowthProc"] = "You finish cutting the tree down and it instantly grows back!",
                ["NotifyLevelGained"] = "You have reached level: {0}. Available points: {1}.",
                ["RespecMultiplierMsg"] = "\n<size=10><color=#FF0000>This will make future respecs {0}% more expensive</color></size>",
                ["Buff.Durability_Extended.Description"] = "\nExcludes: {0}",
                ["Buff.Raiding_Ultimate_Extended.Description"] = "\n<color=#db03cb>Command:</color> /{0}\n<color=#db03cb>Cooldown:</color> {1} minutes",
                ["Buff.Raiding_Ultimate_Ammo_Extended.Description"] = "\n<color=#db03cb>Requires:</color> {0}x MLRS rockets",
                ["OnlyWorksWithRaidableBases"] = "\n<color=#ff7400>Only works with raidable bases.</color>",

                ["Buff.Personal_Explosive_Reduction_Extended.Description.ReducesFireDamage"] = "\n<color=#ffff00>Reduces damage from fire:</color> {0}",
                ["UIExcludesList"] = "\n<color=#ffff00>Exludes:</color> {0}",


                ["Buff.Double_Explosion_Chance_Extended.Description"] = "\n<size=10><color=#ff7400>Excludes munitions from the MLRS ultimate.</color></size>",

                ["Buff.Lock_Picker_Extended.Description.Command"] = "\n<color=#ffff00>Command:</color> /{0}",
                ["Buff.Lock_Picker_Extended.Description.Cooldown"] = "\n<color=#ffff00>Cooldown:</color> {0} seconds",


                ["Buff.Mining_Yield_Extended.Description"] = "\n<size=10><color=#ffff00>Jackhammer bonus yield modifier:</color> {0}{1}%</size>",
                ["Buff.Woodcutting_Yield.Description"] = "\n<size=10><color=#ffff00>Chainsaw bonus yield modifier:</color> {0}{1}%</size>",
                ["Buff.Skinning_Yield_Extended.Description"] = "\n<size=10><color=#ffff00>Powertool bonus yield modifier:</color> {0}{1}%</size>",
                ["Buff.Forager.Description"] = "\n<color=#ffff00>Command:</color> /{0}\n<color=#ffff00>Cooldown:</color> {1} seconds",
                ["Buff.Sonar.Description"] = "<size=10>\n<color=#ffff00>Command:</color> /{0}\n<color=#ffff00>Cooldown:</color> {1} seconds\n<color=#ffff00>Underwater Objects: </color>{2}</size>",
                ["Buff.Trap_Spotter.Description"] = "\n<color=#ffff00>Command:</color> /{0}\n<color=#ffff00>Cooldown:</color> {1} seconds",
                ["Buff.Loot_Spotter.Description"] = "\n<color=#ffff00>Command:</color> /{0}\n<color=#ffff00>Cooldown:</color> {1} seconds",

                ["MiningLuckModifierDescription"] = "\n<size=10><color=#ffff00>Jackhammer luck modifier:</color> {0}{1}%</size>",
                ["WoodcuttingLuckModifierDescription"] = "\n<size=10><color=#ffff00>Chainsaw luck modifier:</color> {0}{1}%</size>",
                ["SkinningLuckModifierDescription"] = "\n<size=10><color=#ffff00>Power tool luck modifier:</color> {0}{1}%</size>",

                ["Buff.Cooldown"] = "\n<color=#ffff00>Cooldown:</color> {0} {1}",
                ["GrownEnabled"] = "\n<color=#ffff00>Does not work on grown entities.</color>",
                ["Craft_Refund_Blacklist"] = "\n<color=#ffff00>Excluded: {0}</color>",
                ["Seconds"] = "seconds",
                ["Buff.HealthRegen.Delay"] = "\n<color=#ffff00>Damage activation delay:</color> {0} seconds",
                ["Buff.PVP_Critical.Amount"] = "\n<color=#ffff00>Critical damage bonus:</color> {0}%",
                ["Buff.Loot_Pickup.MeleeOnly"] = "\n<color=#ffff00>Melee Only:</color> True",
                ["Buff.Loot_Pickup.Distance"] = "\n<color=#ffff00>Melee Only:</color> {0}m",
                ["Buff.Animal_Damage_Resist.Animals"] = "\n<color=#ffff00>Animals:</color> {0}",
                ["Buff.Excluded"] = "\n<color=#ffff00>Excludes: </color> {0}",
                ["RaidBehaviourExpiredMessage"] = "Your ultimate timer has expired.",
                ["RaidBehaviourSuccessMessage"] = "You have successfully acquired your target. Launch in progress...",
                ["Harvesting_Ultimate_Command"] = "\n<color=#db03cb>Command:</color> /{0}",
                ["Mining_Ultimate_Command"] = "\n<color=#db03cb>Command:</color> /{0}",
                ["DetectionText"] = "<size=10>Detection</size>",
                ["AccumulatedXPDebt"] = "You have accumulated <color=#fb2a00>{0}</color> of xp debt. Current Debt: <color=#fb2a00>{1}</color>.",
                ["UIDebtText"] = " [<color=#fb2a00>{0}</color>]",
                ["MoveXPDisabled"] = "Moving the xp bar has been disabled on this server.",
                ["CardSwipeCooldownMessage"] = "You were not awarded xp for swiping as you still have {0} seconds left on your cooldown.",
                ["LockPickStillActive"] = "You still have your Lock Pick ability active. Attempt to open a locked door that you are not authorized on before the timer runs out.",
                ["LockPickCooldown"] = "Your lock pick ability is still on cooldown.",
                ["LockPickActivated"] = "You have activated your Lock Pick ability. It will remain active for {0} seconds or until you attempt to open a locked entity that you do not have access to.",
                ["LockPickSuccess"] = "You manage to pick the lock and break into the door. Ability is on cooldown for {0} seconds.",
                ["LockPickFailed"] = "You failed to pick the lock. You can attempt another lock pick in {0} seconds.",
                ["ExtendedTeaDurationMessage"] = "Your buff increased the duration of the tea's effects:",
                ["ExtendedTeaDurationMessageBody"] = "\n- <color=#42f105>{0}</color>: {1} minutes.",
                ["TeaFound"] = "You found {0}x {1} in the crate.",
                ["MinLevelColHasLevel"] = "<color=#76de07>",
                ["MinLevelColUnderLevel"] = "<color=#de3807>",
                ["MinPointString"] = "Requires Total Points Spent: {0}</color>",
                ["MinPlayerLevelString"] = "Requires Player Level: {0}</color>",
                ["MinPrestigeString"] = "Requires Prestige Level: {0}</color>",
                ["TimeLeftPicklock"] = "<color=#ffb600>Pick time remaining: {0}</color>",
                ["MLRSTimeLeft"] = "<color=#ffb600>Strike time remaining: {0}</color>",
                ["FailMinLevel"] = "You must be level at least {0} to unlock nodes on this tree.",
                ["FailMinPointsSpent"] = "You must have spent at least {0} to unlock nodes on this tree.",
                ["FailMinPrestige"] = "You must have prestige level {0} to unlock nodes on this tree.",
                ["FailMinPrestigeNode"] = "You must have prestige level {0} to unlock this node.",
                ["FailMinLevelNode"] = "You must at least level {0} to unlock this node.",
                ["FailPermission"] = "You must have the permission {0} to unlock this node.",
                ["FailPreReqNode"] = "You must have max level in the {0} node to unlock this node.",
                ["MiningUltimateCooldownMessage"] = "You are still on cooldown from the last time you used this ability. Please wait {0} seconds before trying again.",
                ["hemp-collectable"] = "Hemp",
                ["corn-collectable"] = "Corn",
                ["pumpkin-collectable"] = "Pumpkin",
                ["potato-collectable"] = "Potato",
                ["berry-blue-collectable"] = "Blue Berry",
                ["berry-green-collectable"] = "Green Berry",
                ["berry-yellow-collectable"] = "Yellow Berry",
                ["berry-red-collectable"] = "Red Berry",
                ["berry-white-collectable"] = "White Berry",
                ["diesel_collectable"] = "Diesel",
                ["mushroom-cluster-5"] = "Mushroom",
                ["mushroom-cluster-6"] = "Mushroom",
                ["sulfur-collectable"] = "Sulfur",
                ["metal-collectable"] = "Metal",
                ["stone-collectable"] = "Stone",
                ["wood-collectable"] = "Wood",
                ["Wood_Yield"] = "Wood Yield",
                ["Ore_Yield"] = "Ore Yield",
                ["Radiation_Resistance"] = "Radiation Resistance",
                ["Radiation_Exposure_Resistance"] = "Radiation Exposure Resistance",
                ["Max_Health"] = "Max Health",
                ["Scrap_Yield"] = "Scrap Yield",
                ["Cooking_Ultimate_Description"] = "<size=10><color=#db03cb>ULTIMATE:</color> Provides you with the following mods when used:\n</size>",
                ["CookingUltimateToggleOffCooldownFail"] = "Your buff is off cooldown, so you cannot toggle off your tea buffs.",
                ["CookingUltimateCooldownReminder"] = "You cannot use this ultimate again for another <color=#ffae00>{0}</color>.",
                ["CookingUltimateNotUnlocked"] = "This abilitiy requires the cooking ultimate to be unlocked.",
                ["CookingUltimateNotEnabled"] = "This ultimate is disabled. Enable it through the skill tree menu, under {0}.",
                ["CookingUltimateMod"] = "- {0}: <color=#61e500>+{1}%</color>\n",
                ["CombatUltimateScientists"] = "<color=#42f105>Scientists</color>",
                ["CombatUltimateAnimals"] = "<color=#42f105>Animals</color>",
                ["CombatUltimatePlayers"] = "<color=#42f105>Players</color>",
                ["CookingUltimateDescriptionSize"] = "<size=7>",
                ["CookingUltimateDescriptionBottom"] = "</size><size=10><color=#db03cb>Command:</color> /{0}\n<color=#db03cb>Cooldown:</color> {1} minutes</size>",
                ["UltimateSettingsButton"] = "Ultimate Settings",
                ["AppliedTeaMessage"] = "Applied the following tea mods:\n",
                ["AppliedTeaMessageModString"] = "<color=#db03cb>Mod:</color> <color=#aaad0d>{0} [<color=#42f105>{1}%</color>]</color> - <color=#db03cb>Duration:</color> <color=#aaad0d>{2} minutes.</color>\n",
                ["TrapSpotterNotUnlocked"] = "You must have the Trap Spotter buff to use this command.",
                ["LootSpotterNotUnlocked"] = "You must have the Loot Spotter buff to use this command.",
                ["TrapSpotterCooldownReminder"] = "You cannot use this ability again for another <color=#ffae00>{0}</color>.",
                ["flameturret.deployed"] = "Flame Turret",
                ["autoturret_deployed"] = "Auto Turret",
                ["spikes.floor"] = "Floor Spikes",
                ["teslacoil.deployed"] = "Teslacoil",
                ["beartrap"] = "Bear Trap",
                ["landmine"] = "Landmine",
                ["guntrap.deployed"] = "Shotgun Trap",
                ["Trap"] = "Trap",
                ["Container"] = "Container",
                ["UnderwaterDamageBonusPVP"] = "<color=#efda0a>PVP enabled:</color> {0}",
                ["PermUpdateDelay"] = "<color=#ff8700>Your Skill Tree permissions were recently changed. This may take up to 10 seconds to reflect.</color>",
                ["UINoUltimatesUnlocked"] = "you do not have any ultimate abilities unlocked",
                //"boar", "horse", "stag", "chicken", "wolf", "bear", "scarecrow", "polarbear"
                ["boar"] = "Boar",
                ["horse"] = "Horse",
                ["stag"] = "Stag",
                ["chicken"] = "Chicken",
                ["wolf"] = "Wolf",
                ["wolf2"] = "Wolf",
                ["bear"] = "Bear",
                ["snake.entity"] = "Snake",
                ["scarecrow"] = "Scarecrow",
                ["polarbear"] = "Polar Bear",
                ["SkinningUltimateToggleText"] = "You will now receive perks when killing a: <color=#DFF008>{0}.</color>",
                ["CombatUltimateAnd"] = " and ",
                ["CombatUltimateToggleOnMessage"] = "You will now receive <color=#DFF008>{0}%</color> of the damage as health when damaging {1}.",
                ["RaidingUltimateNoFreeSlot"] = "You must have 1 free inventory slot available in your belt.",
                ["RaidingUltimateNotUnlocked"] = "This command requires the Raiding Ultimate to be unlocked.",
                ["RaidingUltimateAlreadyActive"] = "This ability is already active.",
                ["RaidingMissingAmmo"] = "You do not have enough MLRS rockets in your inventory. Requires: {0}",
                ["RaidingUltimateCooldown"] = "You cannot use this ultimate again for another <color=#ffae00>{0}</color>.",
                ["minutes"] = "minutes",
                ["seconds"] = "seconds",
                ["UIBinocularsMessage"] = "LOOK THROUGH YOUR <color=#ffb600>BINOCULARS</color> AND HOLD <color=#ffb600>E</color> TO SET YOUR TARGET",
                ["RaidingUltimateResetTimeout"] = "Your strike cooldown has been reset as it timed out.",
                ["RaidingUltimateChatInstructions"] = "You have received some binoculars. Use them to set your target.",
                ["UIUnlocksIn"] = "<color=#f5d800>Unlocks in:</color>",
                ["UILevelUpButton"] = "<color=#ffb600>Level Up</color>",
                ["UIPrestigeUpButton"] = "<color=#ffb600>Gain Prestige</color>",
                ["UIPrestigeUpButtonHasLevel"] = "<color=#3fa112>Gain Prestige</color>",
                ["UIEnabled"] = "Enabled",
                ["metal"] = "metal",
                ["stone"] = "stone",
                ["sulfur"] = "sulfur",

                ["ForageBuffCooldown"] = "You are still on cooldown for another {0} seconds.",
                ["SonarBuffCooldown"] = "You are still on cooldown for another {0} seconds.",
                ["BagCooldownMsg"] = "You must wait {0} seconds before attempting to open your bag again.",
                ["NeedBagBuff"] = "You need to have the Extra Pockets buff in order to access this pouch.",
                ["DudExplodedAnyway"] = "You explosive was a dud, but it exploded anyway!",
                ["UltimateDisabledMessage"] = "Ultimate: {0} has been disabled.",
                ["DisableNoclipCommand"] = "You cannot use this command while in noclip.",
                ["RequireHarvestingUltimateMsg"] = "You need to have unlocked the Harvesting ultimate in order to use this command.",
                ["AnimalBuffDescription_Chicken"] = "You feel the power of the chicken flow through you. You can no longer receive fall damage.",
                ["AnimalBuffDescription_Bear"] = "You feel the power of the bear flow through you. Scientists cower in fear and will not engage unless engaged.",
                ["AnimalBuffDescription_Wolf"] = "You feel the power of the wolf flow through you. Healing feels more potent with friends around.",
                ["AnimalBuffDescription_Boar"] = "You feel the power of the boar flow through you. You may find some useful stuff when collecting wild berries and mushrooms.",
                ["AnimalBuffDescription_Stag"] = "You feel the power of the stag flow through you. You feel incredibly alert to nearby player threats.",
                ["AnimalBuffDescription_PolarBear"] = "You feel the power of the polar bear flow through you. It has wrapped you in a thick, damage absorbing skin.",
                ["AnimalBuffFinishedMsgNew"] = "You feel the power of the {0} leave you...",
                ["BoarLootMsg"] = "You find something burried under the {0}...",
                ["Mushroom"] = "mushroom",
                ["BerryBush"] = "berry bush",
                ["RocketStrikeCooldownMsg"] = "The server does not allow the MLRS strike to be used so close to wipe. This ability will be available in {0}",
                ["Hours"] = "hours",
                ["Minutes"] = "minutes",
                ["Seconds"] = "seconds",
                ["BinocularGiveFail"] = "Failed to give binoculars due to stacking issues.",
                ["StrikeCancelledDueToPreviousStrike"] = "Strike cancelled - location too closed to a previous strike zone. Available in: {0} minutes.",
                ["PouchItemsRemoved"] = "Your items were removed from your pouch and returned to you.",
                ["BCToggleOff"] = "Toggled better chat titles off.",
                ["BCToggleOn"] = "Toggled better chat titles on.",
                ["Player"] = "Player",
                ["DiveSite"] = "Dive Site",
                ["Scientist"] = "Scientist",
                ["Shark"] = "Shark",
                ["Tugboat"] = "Tugboat",
                ["RoguelikeDeathMessage"] = "You have fallen in glorious battle. Your progress has been reset.",
                ["ShowDist"] = " - {0}m",
                ["OfflineXPReceived"] = "{0} xp that you received while offline has been applied.",
                ["Buff_Distance"] = "<color=#ffff00>Distance:</color> {0}m",
                ["Buff_Cooldown_seconds"] = "<color=#ffff00>Cooldown:</color> {0} seconds",
                ["SetRecyclerEfficiency"] = "Your skill set the recycler efficiency to {0}%.",
                ["TeaSharePlayerMsg"] = "You shared {0}% of your tea with {1}",
                ["TeaShareTargetMsg"] = "{0} shared {1}% of their tea with you",
                ["MetabolismSharePlayerMsg"] = "You shared some of your calories with {0}",
                ["MetabolismShareTargetMsg"] = "You received some calories from {0}",
                ["Metal_Detector_Luck_Found_Item"] = "You found <color=#f4ed03>{0}</color>x <color=#8ecd2d>{1}</color> while digging up the site.",
                ["UIPrestigeExplain"] = "The prestige system will allow you to reset your Skill Tree progress and start from the beginning, but with additional benefits. <color=#ec3209>This process cannot be undone!</color>\n\n<b>You will be provided with the following benefits:</b>\n",
                ["UIPrestigeXPMod"] = "\n\nXP modifier: <color=#ec3209>{0}%</color>",
                ["UICONFIRM"] = "CONFIRM",
                ["UICANCEL"] = "CANCEL",
                ["BuffUIFormat"] = "{0}: <color=#42f105>{1}</color>\n",
                ["BuffUIFormatWithTempBuff"] = "{0}: <color=#42f105>{1}</color> [<color=#C061C2>{2}</color>]\n",
                ["BuffUIFormatOnlyTempBuff"] = "{0}: [<color=#C061C2>{1}</color>]\n",
                ["PermUIFormat"] = "Perm - <color=#42f105>{0}</color>\n",
                ["CooldownNotify"] = "The <color=#258089>{0}</color> buff is on cooldown for <color=#eca90d>{1} seconds </color>.",
                ["UIReqPresLvl"] = "<color=#f74a04>Requires Prestige {0}</color>",
                ["UIReqPlayerLvl"] = "<color=#f74a04>Requires level {0}</color>",
                ["UIReqPermission"] = "<color=#f74a04>Requires permission {0}</color>",
                ["ExcludedNode"] = "You cannot unlock this skill because you have unlocked the {0} skill.",
                ["UIExcludeDescription"] = "\n<size=8><color=#f3740a>Unlocking <color=#15d8cd>{0}</color> will lock this skill.</color></size>",
                ["UIRequiredDescription"] = "\n<size=8><color=#15d8cd>{0}</color> <color=#f3740a>is required to unlock this skill.</color></size>",
                ["UINodeLocked"] = "<color=#f74a04>LOCKED</color>",

                ["AwarenessCorpse"] = "<color=#ffdc00>Corpse</color>",
                ["AwarenessBag"] = "<color=#ffdc00>Bag</color>",
                ["AwarenessAnimal"] = "<color=#ffdc00>Animal</color>",
                ["AwarenessHumannpc"] = "<color=#ffdc00>Human npc</color>",
                ["AwarenessItem"] = "<color=#ffdc00>Item</color>",
                ["AwarenessText"] = "<size=12>{0}</size>",
                ["AwarenessDescription"] = "<color=#ffff00>Tracked:</color> <color=#ffffff>{0}</color>",

                ["UIScoresTitle"] = "SCORES",
                ["UIRank"] = "RANK",
                ["UIName"] = "NAME",
                ["UITotalXP"] = "TOTAL XP",
                ["BuffSettingDisplayFormat"] = "{0}",
                ["PresetSaved"] = "Saved preset: {0}. Skills: {1}. Points: {2}",
                ["PresetNotEnoughEcon"] = "You do not enough economic dollars to add a new profile.",
                ["PresetNotEnoughSR"] = "You do not enough points to add a new profile.",
                ["PresetNotEnoughShoppyStock"] = "You do not enough currency to add a new profile.",
                ["PresetMissingItem"] = "You do not have enough {0} to add a new profile.",
                ["PresetNotEnoughSkillPoints"] = "You do not have enough skill points for this preset. It requires: {0}",
                ["PresetCannotAffordRespec"] = "You cannot afford the respec cost.",
                ["PresetNotEnoughEconSwap"] = "You do not have enough economic dollars to cover the cost of this swap.",
                ["PresetNotEnoughSRSwap"] = "You do not have enough points to cover the cost of this swap.",
                ["PresetNotEnoughShoppyStockSwap"] = "You do not have enough currency to cover the cost of this swap.",
                ["PresetNotEnoughItemsSwap"] = "You do not have enough {0} to cover the cost of this swap - Found: {1}. Need: {2}.",
                ["PresetSwappedTo"] = "Swapped preset to: {0}",
                ["UIPresetTreePresetTitle"] = "TREE PRESETS",
                ["UIPresetAddButton"] = "<color=#f7e406>ADD</color>",
                ["UIPresetAddNewPresetTitle"] = "ADD NEW PRESET",
                ["UIPresetSwapToPresetTitle"] = "SWAP TO PRESET",
                ["UIPresetSwapRespecNoticee"] = "<color=#f7bd06>Costs are in addition to your standard [{0}x {1}] respec cost.</color>",
                ["UIPresetSwapRespecNoAdditionalCost"] = "<color=#f7bd06>Creating this preset will cost your standard respec cost [{0}x {1}].</color>",
                ["UIPresetEconCost"] = "Economic cost:",
                ["UIPresetEconValue"] = "${0}",
                ["UIPresetSRCost"] = "Points cost:",
                ["UIPresetShoppyStockCost"] = "Currency cost:",
                ["UIPresetSRValue"] = "{0} points",
                ["UIPresetShoppyStockValue"] = "{0} currency",
                ["UIPresetInputName"] = "Name:",
                ["UIBack"] = "Back",
                ["PresetAlreadyActive"] = "This preset is already active.",
                ["PresetAlreadyExists"] = "There is already a preset with the name {0}.",
                ["FailSafeTC"] = "You must be in a safe zone or tc range to swap between presets.",
                ["FailSafe"] = "You must be in a safe zone to swap between presets.",
                ["FailTC"] = "You must be in tc range to swap between presets.",
                ["BuffType.Percentage"] = "+{0}%",
                ["BuffType.Seconds"] = "-{0} seconds",
                ["BuffType.PerSecond"] = "+{0} / second",
                ["BuffType.Slots"] = "+{0} slots",
                ["BuffType.Level"] = "Level {0}",
                ["BuffType.Distance"] = "+{0}m",
                ["LoadingVideoMsg"] = "Loading video... This may take a moment...",
                ["UIPlayVideoConfirmationMsg"] = "This video may take some time to play and cannot be skipped or cancelled.\n<color=#fff000>Are you sure you want to play it?</color>",
                ["UIBuffSettings"] = "Buff Settings",
                ["UINoSupportedBuffs"] = "No supported buffs have been unlocked",
                ["HitXPCapNotification"] = "You have gained the maximum amount of xp today. The xp cap will reset at: <color=#20e1f4>{0}</color>",
                ["RequiresSkill"] = "<color=#f74a04>Requires skill {0}</color>",
                ["NightXPStartAnnounce"] = "<color=#f74a04>Night time xp bonuses have started</color>",
                ["NightXPStopAnnounce"] = "<color=#f74a04>Night time xp bonuses have ended</color>",

                ["NSLevelUpTitle"] = "You have reached level: {0}",
                ["NSLevelUpBody"] = "You have reached level: {0} and have been awarded {1} points.\nAvailable points: {2}.",

                ["NSLevelUpTitleMax"] = "Level cap reached: <color=#41E310>level {0}</color>!",
                ["NSLevelUpBodyMax"] = "You have reached the highest possible level: <color=#41E310>level {0}</color> and have been awarded {1} points.\nAvailable points: {2}.",
                ["NSPrestigeUnlocked"] = "\nYou can now increase up your prestige rank through the Skill Tree menu.",

                ["NSPrestigeBody"] = "You have achieved <color=#41E310>prestige rank {0}</color>!\nThis prestige level unlocks:\n{1}",
                ["NSPrestigeTitle"] = "You reached <color=#41E310>prestige rank {0}</color>",

                ["MoveBarInstructions"] = "Click and drag the xp bar to move it. Click the x on the bar to exit.",

                ["UIGeneHeading"] = "PLANT GENE STRUCTURE",
                ["UIOvershield"] = "Overshield",
                ["UIProgress"] = "PROGRESS...",
                ["UIPrestige"] = "PRESTIGE",
                ["UIInfo"] = "INFO",
                ["UIDelete"] = "<color=#f73206>DELETE</color>",
                ["UIAreSure"] = "ARE YOU SURE?",
                ["UIYes"] = "YES",
                ["UINo"] = "NO",
                ["UIDontAsk"] = "Don't ask again",
                ["UIPlayerSettingsButton"] = "<color=#ffb600>Player Settings</color>",
                ["UIUltimateSettingsButton"] = "<color=#ffb600>Ultimate Settings</color>",
                ["UINextRowUnlocks"] = "<color=#f5d800>Next row unlocks in: <color=#0AC406>{0}</color> points</color>"
            };

            Dictionary<string, string> langMessages = new Dictionary<string, string>();
            foreach (var kvp in DefaultMessages)
            {
                if (!langMessages.ContainsKey(kvp.Key)) langMessages.Add(kvp.Key, kvp.Value);
            }
            foreach (var kvp in buffMessages)
            {
                if (!langMessages.ContainsKey(kvp.Key)) langMessages.Add(kvp.Key, kvp.Value);
            }
            foreach (var kvp in TitleMessages)
            {
                if (!langMessages.ContainsKey(kvp.Key)) langMessages.Add(kvp.Key, kvp.Value);
            }
            foreach (var animal in config.ultimate_settings.ultimate_skinning.enabled_buffs?.Keys ?? DefaultAnimalBuffs.Keys)
            {
                var animalStr = animal.ToString();
                if (!langMessages.ContainsKey(animalStr)) langMessages.Add(animalStr, animalStr);
            }
            foreach (var perm in permission_descriptions)
            {
                if (!langMessages.ContainsKey(perm.Key)) langMessages.Add(perm.Key, perm.Value);
            }
            foreach (var level in config.prestige_settings.levels)
            {
                foreach (var benefit in level.Value.additionalBenfitsDescription)
                    if (!langMessages.ContainsKey(benefit)) langMessages.Add(benefit, benefit);

                if (!string.IsNullOrEmpty(level.Value.rankTitle) && !langMessages.ContainsKey(level.Value.rankTitle)) langMessages.Add(level.Value.rankTitle, level.Value.rankTitle);

                if (level.Value.perms != null)
                {
                    foreach (var perm in level.Value.perms)
                        if (!langMessages.ContainsKey(perm.Key)) langMessages.Add(perm.Key, perm.Key);
                }
                if (level.Value.commands != null)
                {
                    foreach (var _command in level.Value.commands)
                        if (!langMessages.ContainsKey(_command.Key)) langMessages.Add(_command.Key, _command.Key);
                }
            }

            foreach (var prefab in GameManifest.Current.entities)
            {
                var go = GameManager.server.FindPrefab(prefab);
                if (go == null) continue;

                var entity = go.GetComponent<BoxStorage>();
                if (entity == null || entity.GetType() != typeof(BoxStorage)) continue;

                if (!langMessages.ContainsKey(entity.ShortPrefabName)) langMessages.Add(entity.ShortPrefabName, entity.ShortPrefabName.TitleCase());
            }

            lang.RegisterMessages(langMessages, this);
            DefaultMessages.Clear();
            buffMessages.Clear();
            TitleMessages.Clear();
            permission_descriptions.Clear();
        }

        #endregion

        #region Hooks

        void OnMixingTableToggle(MixingTable instance, BasePlayer player)
        {
            if (instance.IsOn()) return;
            if (!GetBuffDetails(player.userID, out var buffData)) return;

            if (buffData.GetBuff(Buff.Cooking_Speed, out var value)) HandleMixingSpeedAdjustment(instance, value);            
        }

        void HandleMixingSpeedAdjustment(MixingTable instance, float modifier)
        {
            NextTick(() =>
            {
                if (instance == null) return;
                if (!instance.IsOn()) return;
                instance.RemainingMixTime = instance.RemainingMixTime * (Mathf.Clamp(1 - modifier, 0.1f, 1));
                instance.SendNetworkUpdateImmediate();
            });
        }

        void OnUserPermissionGranted(string id, string permName) => UpdatePlayerPerms(id, permName, true);
        void OnUserPermissionRevoked(string id, string permName) => UpdatePlayerPerms(id, permName, false);
        void OnGroupPermissionGranted(string name, string permName) => UpdatePlayersInGroup(name, permName);
        void OnGroupPermissionRevoked(string name, string permName) => UpdatePlayersInGroup(name, permName);

        void OnUserGroupAdded(string id, string groupName) => UpdatePlayerPermsOnGroupMove(id, groupName);
        void OnUserGroupRemoved(string id, string groupName) => UpdatePlayerPermsOnGroupMove(id, groupName);

        bool IsStartPointPermission(string permName)
        {
            foreach (var perm in config.wipe_update_settings.starting_skill_point_overrides.Keys)
            {
                if (permName.Contains(perm)) return true;
            }

            return false;
        }

        void UpdatePlayerPermsOnGroupMove(string id, string groupName)
        {
            foreach (var permName in permission.GetGroupPermissions(groupName))
            {
                if (!permName.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase)) continue;
                if (IsStartPointPermission(permName))
                {
                    AddStartingSkillPoints(id, null);
                }
                foreach (var perm in config.trees.Keys)
                {
                    if (permName.Equals("skilltree." + perm.ToString(), StringComparison.OrdinalIgnoreCase))
                    {
                        var player = BasePlayer.Find(id);
                        if (player != null) Player.Message(player, lang.GetMessage("PermUpdateDelay", this, player.UserIDString), config.misc_settings.ChatID);
                        QueueInstanceDataUpdate(id);
                        return;
                    }
                }
            }
        }

        void UpdatePlayerPerms(string id, string permName, bool granted)
        {
            if (!permName.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase)) return;
            if (granted && IsStartPointPermission(permName))
            {
                AddStartingSkillPoints(id, null);
            }
            foreach (var perm in config.trees.Keys)
            {
                if (permName.Equals("skilltree." + perm.ToString(), StringComparison.OrdinalIgnoreCase))
                {
                    var player = BasePlayer.Find(id);
                    if (player != null) Player.Message(player, lang.GetMessage("PermUpdateDelay", this, player.UserIDString), config.misc_settings.ChatID);
                    QueueInstanceDataUpdate(id);
                    return;
                }
            }
            if (permName.Equals("skilltree.all", StringComparison.OrdinalIgnoreCase)) QueueInstanceDataUpdate(id);
            //else if (TrackedPermissionPerms.Contains(permName)) QueueInstanceDataUpdate(id);
        }

        void UpdatePlayersInGroup(string name, string permName)
        {
            if (!permName.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase)) return;

            if (IsStartPointPermission(permName))
            {
                foreach (var user in permission.GetUsersInGroup(name))
                    AddStartingSkillPoints(user.Split(' ')[0], null);
            }

            foreach (var perm in config.trees.Keys)
            {
                if (permName.Equals("skilltree." + perm.ToString(), StringComparison.OrdinalIgnoreCase))
                {
                    foreach (var user in permission.GetUsersInGroup(name))
                    {
                        var id = user.Split(' ')[0];
                        var player = BasePlayer.Find(id);
                        if (player != null) Player.Message(player, lang.GetMessage("PermUpdateDelay", this, player.UserIDString), config.misc_settings.ChatID);
                        QueueInstanceDataUpdate(id);
                    }
                    return;
                }
            }
            if (permName.Equals("skilltree.all", StringComparison.OrdinalIgnoreCase))
            {
                foreach (var user in permission.GetUsersInGroup(name))
                {
                    QueueInstanceDataUpdate(user.Split(' ')[0]);
                }
                return;
            }
            else if (TrackedPermissionPerms.Contains(permName))
            {
                foreach (var user in permission.GetUsersInGroup(name))
                {
                    QueueInstanceDataUpdate(user.Split(' ')[0]);
                }
                return;
            }
        }

        void UpdatePlayerPerms(string id)
        {
            var player = BasePlayer.Find(id);
            if (player != null)
            {
                CuiHelper.DestroyUi(player, "SkillTree");
                CuiHelper.DestroyUi(player, "respec_confirmation");
                CuiHelper.DestroyUi(player, "SkillTreeBackPanel");
                CuiHelper.DestroyUi(player, "NavigationMenu");
                CuiHelper.DestroyUi(player, "PrestigeConfirmation");
                DoClear(player, config.buff_settings.removePermissionsOnDisconnect);
                LoggingOff(player, true);
                HandleNewConnection(player);
            }
        }

        Timer InstanceDataUpdateTimer;
        List<string> InstanceDataPlayerQueue = new List<string>();

        void QueueInstanceDataUpdate(string playerID)
        {
            if (!InstanceDataPlayerQueue.Contains(playerID)) InstanceDataPlayerQueue.Add(playerID);
            if (InstanceDataUpdateTimer == null || InstanceDataUpdateTimer.Destroyed)
            {
                if (config.misc_settings.enableDebug) Puts("Initializing timer to update node permissions. Permissions will update in 10 seconds.");
                InstanceDataUpdateTimer = timer.Once(10f, () =>
                {
                    foreach (var id in InstanceDataPlayerQueue)
                        try
                        {
                            UpdatePlayerPerms(id);
                        }
                        catch (Exception ex)
                        {
                            Puts($"Failed to update data for {id}. Exception: {ex.Message}");
                        }

                    InstanceDataPlayerQueue.Clear();
                });
            }
        }

        void OnMetalDetectorFlagRequest(BaseMetalDetector detector, Vector3 pos, BasePlayer player)
        {
            AwardXP(player, config.xp_settings.xp_sources.detect_diggable, detector, false, false, nameof(config.xp_settings.xp_sources.detect_diggable));
        }

        Dictionary<ulong, BaseProjectile> ModifiedWeapons = new Dictionary<ulong, BaseProjectile>();

        bool CanModifyMagazine(BaseProjectile weapon)
        {
            if (config.tools_black_white_list_settings.extendedMag_weapon_blacklist.Contains(weapon.ShortPrefabName)) return false;
            if (weapon.primaryMagazine != null && config.tools_black_white_list_settings.extendedMag_ammotype_blacklist.Contains(weapon.primaryMagazine.ammoType.shortname)) return false;

            return true;
        }

        object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (type != AntiHackType.FlyHack) return null;
            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd) || !bd.ContainsBuff(Buff.Fall_Damage_Reduction)) return null;
            return true;
        }

        object OnWeaponReload(BaseProjectile weapon, BasePlayer player)
        {
            if (player == null || player.IsNpc || !player.userID.IsSteamId()) return null;

            if (!GetBuffDetails(player.userID, out var bd))
            {
                RemoveMods(weapon, 0);
                return null;
            }

            if (!CanModifyMagazine(weapon))
            {
                RemoveMods(weapon, 0);
                return null;
            }

            if (!bd.GetBuff(Buff.Extended_Mag, out var value))
            {
                if (ModifiedWeapons.ContainsKey(weapon.net.ID.Value))
                {
                    RemoveMods(weapon, 0);
                }
                return null;
            }
            if (!ModifiedWeapons.ContainsKey(weapon.net.ID.Value)) ModifiedWeapons.Add(weapon.net.ID.Value, weapon);
            int num = Mathf.CeilToInt(ProjectileWeaponMod.Mult(weapon, (ProjectileWeaponMod x) => x.magazineCapacity, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f) * (float)weapon.primaryMagazine.definition.builtInSize);
            var totalAmmoCapacity = num + Convert.ToInt32(weapon.primaryMagazine.definition.builtInSize * value);
            weapon.primaryMagazine.capacity = totalAmmoCapacity;

            return null;
        }

        object OnWeaponModChange(BaseProjectile weapon, BasePlayer player)
        {
            if (player == null || player.IsNpc || !player.userID.IsSteamId() || weapon == null) return null;

            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd)) return null;

            if (!CanModifyMagazine(weapon))
            {
                RemoveMods(weapon, 0);
                return null;
            }

            float value;
            if (!bd.GetBuff(Buff.Extended_Mag, out value))
            {
                RemoveMods(weapon, 0);
                return null;
            }

            int num = Mathf.CeilToInt(ProjectileWeaponMod.Mult(weapon, (ProjectileWeaponMod x) => x.magazineCapacity, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f) * (float)weapon.primaryMagazine.definition.builtInSize);

            var totalAmmoCapacity = num + Convert.ToInt32(weapon.primaryMagazine.definition.builtInSize * value);


            var oldMagCapacity = weapon.primaryMagazine.capacity;

            weapon.primaryMagazine.capacity = totalAmmoCapacity;

            if (oldMagCapacity > weapon.primaryMagazine.capacity)
            {
                weapon.SendNetworkUpdateImmediate();
                RemoveMods(weapon, weapon.primaryMagazine.capacity - num, false);
            }
            else if (oldMagCapacity != weapon.primaryMagazine.capacity)
                weapon.SendNetworkUpdateImmediate();

            return true;
        }

        void RemoveMods(BaseProjectile weapon, int extraAmmo, bool removeFromDic = true, bool forceUnload = true)
        {
            DelayedModsChanged(weapon, extraAmmo, forceUnload);
            if (removeFromDic) ModifiedWeapons.Remove(weapon.net.ID.Value);
        }

        public void DelayedModsChanged(BaseProjectile weapon, int extraAmmoCapacity = 0, bool unloadModifiedWeapons = true)
        {
            int num = Mathf.CeilToInt(ProjectileWeaponMod.Mult(weapon, (ProjectileWeaponMod x) => x.magazineCapacity, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f) * (float)weapon.primaryMagazine.definition.builtInSize) + extraAmmoCapacity;
            if (num == weapon.primaryMagazine.capacity && weapon.primaryMagazine.contents <= num)
            {
                return;
            }
            if (weapon.primaryMagazine.contents > 0 && weapon.primaryMagazine.contents > num && unloadModifiedWeapons)
            {
                int contents = weapon.primaryMagazine.contents;
                BasePlayer player = weapon.GetOwnerPlayer();
                ItemContainer itemContainer = null;
                if (player != null)
                {
                    itemContainer = player.inventory.containerMain;
                }
                else if (weapon.GetCachedItem() != null)
                {
                    itemContainer = weapon.GetCachedItem().parent;
                }

                weapon.primaryMagazine.contents = 0;
                if (itemContainer != null)
                {
                    Item item = ItemManager.Create(weapon.primaryMagazine.ammoType, contents, 0uL);
                    if (!item.MoveToContainer(itemContainer))
                    {
                        Vector3 vPos = weapon.transform.position;
                        if (itemContainer.entityOwner != null)
                        {
                            vPos = itemContainer.entityOwner.transform.position + Vector3.up * 0.25f;
                        }

                        item.Drop(vPos, Vector3.up * 5f);
                    }
                }
            }
            weapon.primaryMagazine.capacity = num;
            weapon.SendNetworkUpdate();
        }

        object CanTakeCutting(BasePlayer player, GrowableEntity plant)
        {
            BuffDetails bd;
            float value;
            if (!GetBuffDetails(player.userID, out bd) || !bd.GetBuff(Buff.Harvest_Grown_Yield, out value) || Interface.CallHook("STCanReceiveYield", player, plant) != null) return null;

            var num = (plant.Properties.BaseCloneCount + plant.Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) / 2) * value;

            var guaranteedYield = Convert.ToInt32(Math.Truncate(num));
            var rolledYield = Convert.ToSingle(num - guaranteedYield);
            if (rolledYield > 0 && UnityEngine.Random.Range(0f, 1f) >= 1 - rolledYield) guaranteedYield++;

            if (guaranteedYield <= 0) return null;
            var item = ItemManager.Create(plant.Properties.CloneItem, guaranteedYield);
            GrowableGeneEncoding.EncodeGenesToItem(plant, item);

            player.GiveItem(item);
            return null;
        }

        object OnTreeMarkerHit(TreeEntity tree, HitInfo info)
        {
            if (info == null || info.InitiatorPlayer == null || info.InitiatorPlayer.IsNpc || !info.InitiatorPlayer.userID.IsSteamId()) return null;

            BuffDetails bd;
            if (!GetBuffDetails(info.InitiatorPlayer.userID, out bd)) return null;

            float value;
            if (!bd.GetBuff(Buff.Woodcutting_Hotspot, out value)) return null;

            if (value < 1 && !RollSuccessful(value)) return null;

            return true;
        }

        // Credit to Nivex
        void OnMeleeAttack(BasePlayer player, HitInfo info)
        {
            if (info == null || player == null || !player.userID.IsSteamId() || !(info.HitEntity is OreResourceEntity)) return;

            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd)) return;

            float value;
            if (!bd.GetBuff(Buff.Mining_Hotspot, out value)) return;

            if (value < 1 && !RollSuccessful(value)) return;

            var ore = info.HitEntity as OreResourceEntity;
            if (ore._hotSpot != null)
            {
                ore._hotSpot.transform.position = info.HitPositionWorld;
                ore._hotSpot.SendNetworkUpdateImmediate();
            }
            else ore._hotSpot = ore.SpawnBonusSpot(info.HitPositionWorld);
        }

        void SetPicker(BasePlayer player)
        {
            if (ActivePickers.ContainsKey(player.userID))
            {
                //Player.Message(player, lang.GetMessage("LockPickStillActive", this, player.UserIDString));
                Player.Message(player, lang.GetMessage("LockPickStillActive", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }

            float value;
            BuffDetails bd;
            if (GetBuffDetails(player.userID, out bd) && bd.GetBuff(Buff.Lock_Picker, out value))
            {
                if (LockPickCooldowns.ContainsKey(player.userID))
                {
                    if (LockPickCooldowns[player.userID] > Time.time)
                    {
                        Player.Message(player, lang.GetMessage("LockPickCooldown", this, player.UserIDString), config.misc_settings.ChatID);
                        return;
                    }
                    LockPickCooldowns[player.userID] = Time.time + config.buff_settings.raid_perk_settings.Lock_Picker_settings.use_delay;
                }
                else LockPickCooldowns.Add(player.userID, Time.time + config.buff_settings.raid_perk_settings.Lock_Picker_settings.use_delay);

                ActivePickerClass pickerData;
                if (!ActivePickers.TryGetValue(player.userID, out pickerData)) ActivePickers.Add(player.userID, pickerData = new ActivePickerClass(value));
                else pickerData.chance = value;

                Player.Message(player, string.Format(lang.GetMessage("LockPickActivated", this, player.UserIDString), config.buff_settings.raid_perk_settings.Lock_Picker_settings.time), config.misc_settings.ChatID);

                var timeLeft = Convert.ToInt32(config.buff_settings.raid_perk_settings.Lock_Picker_settings.time);
                pickerData.timer = timer.Every(config.buff_settings.raid_perk_settings.Lock_Picker_settings.timer_tick_rate, () =>
                {
                    timeLeft -= config.buff_settings.raid_perk_settings.Lock_Picker_settings.timer_tick_rate;
                    if (timeLeft <= 0) DestroyPicker(player.userID, pickerData);
                    else if (config.buff_settings.raid_perk_settings.Lock_Picker_settings.show_timer) PendingTimer(player, string.Format(lang.GetMessage("TimeLeftPicklock", this, player.UserIDString), timeLeft));
                });
            }
        }

        public class ActivePickerClass
        {
            public BasePlayer player;
            public float chance;
            public Timer timer;

            public ActivePickerClass(float chance)
            {
                this.chance = chance;
            }
        }

        private void PendingTimer(BasePlayer player, string text)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "PendingTimer",
                Parent = "Hud",
                Components = {
                    new CuiTextComponent { Text = text, Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = config.misc_settings.timeLeft_anchor.anchorMin, AnchorMax = config.misc_settings.timeLeft_anchor.anchorMax, OffsetMin = config.misc_settings.timeLeft_anchor.offsetMin, OffsetMax = config.misc_settings.timeLeft_anchor.offsetMax }
                }
            });

            CuiHelper.DestroyUi(player, "PendingTimer");
            CuiHelper.AddUi(player, container);
        }

        void DestroyPicker(ulong userid, ActivePickerClass pickerData, bool remove = true)
        {
            if (pickerData == null && !ActivePickers.TryGetValue(userid, out pickerData)) return;

            if (pickerData.timer != null && !pickerData.timer.Destroyed) pickerData.timer.Destroy();
            if (remove) ActivePickers.Remove(userid);
            CuiHelper.DestroyUi(pickerData.player, "PendingTimer");
        }

        Dictionary<ulong, ActivePickerClass> ActivePickers = new Dictionary<ulong, ActivePickerClass>();
        Dictionary<ulong, float> LockPickCooldowns = new Dictionary<ulong, float>();
        object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            if (baseLock == null || player == null) return null;
            var ownerEntity = baseLock.GetParentEntity();
            if (ownerEntity == null) return null;
            if (!PassRaidableBasesCheck(ownerEntity, Buff.Lock_Picker)) return null;
            var hasAccess = baseLock is CodeLock ? (baseLock as CodeLock).whitelistPlayers.Contains(player.userID) : baseLock.HasLockPermission(player);
            ActivePickerClass pickerData;
            if (hasAccess || !baseLock.IsLocked() || !ActivePickers.TryGetValue(player.userID, out pickerData)) return null;

            if (Interface.CallHook("STOnLockpickAttempt", player, baseLock) != null) return null;

            ActivePickers.Remove(player.userID);
            if (RollSuccessful(pickerData.chance))
            {
                if (!string.IsNullOrEmpty(config.effect_settings.lockpick_success_effect)) EffectNetwork.Send(new Effect(config.effect_settings.lockpick_fail_effect, player.transform.position, player.transform.position), player.net.connection);
                Player.Message(player, string.Format(lang.GetMessage("LockPickSuccess", this, player.UserIDString), config.buff_settings.raid_perk_settings.Lock_Picker_settings.use_delay), config.misc_settings.ChatID);
                DestroyPicker(player.userID, pickerData);
                if (config.buff_settings.raid_perk_settings.Lock_Picker_settings.unlock_entity) NextTick(() => baseLock.SetFlag(BaseEntity.Flags.Locked, false));
                return true;
            }
            Player.Message(player, string.Format(lang.GetMessage("LockPickFailed", this, player.UserIDString), config.buff_settings.raid_perk_settings.Lock_Picker_settings.use_delay), config.misc_settings.ChatID);
            if (!string.IsNullOrEmpty(config.effect_settings.lockpick_fail_effect)) EffectNetwork.Send(new Effect(config.effect_settings.lockpick_fail_effect, player.transform.position, player.transform.position), player.net.connection);
            if (config.buff_settings.raid_perk_settings.Lock_Picker_settings.damage_per_fail > 0)
            {
                player.Hurt(config.buff_settings.raid_perk_settings.Lock_Picker_settings.damage_per_fail);
            }
            DestroyPicker(player.userID, pickerData);
            return null;
        }

        #region OnEntityTakeDamage

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (info == null || info.damageTypes == null || entity == null || info.damageTypes.GetMajorityDamageType() == Rust.DamageType.Decay) return null;
                var AttackerIsRealPlayer = info.InitiatorPlayer != null && !info.InitiatorPlayer.IsNpc && info.InitiatorPlayer.userID.IsSteamId();
                BuffDetails bd;

                #region Trap

                if (IsTrap(entity) && AttackerIsRealPlayer)
                {
                    float value;
                    if (!GetBuffDetails(info.InitiatorPlayer.userID, out bd) || !bd.GetBuff(Buff.Trap_Damage_Increase, out value) || config.buff_settings.raid_perk_settings.trap_damage_increase_settings.blacklist.Contains(entity.ShortPrefabName) || !PassRaidableBasesCheck(entity, Buff.Trap_Damage_Increase)) return null;

                    info.damageTypes.ScaleAll(1 + value);
                    return null;
                }
                #endregion                

                #region Bradley APC

                if (entity is BradleyAPC apc)
                {
                    if (!AttackerIsRealPlayer) return null;
                    if (!GetBuffDetails(info.InitiatorPlayer.userID, out bd) || !bd.GetBuff(Buff.Bradley_Damage_Bonus, out var value)) return null;
                    info.damageTypes.ScaleAll(1f + value);
                    return null;
                }

                #endregion

                #region Attack Heli

                if (entity is PatrolHelicopter heli)
                {
                    if (!AttackerIsRealPlayer) return null;
                    if (!GetBuffDetails(info.InitiatorPlayer.userID, out bd) || !bd.GetBuff(Buff.Heli_Damage_Bonus, out var value)) return null;
                    info.damageTypes.ScaleAll(1f + value);
                    return null;
                }

                #endregion

                var damageType = info.damageTypes.GetMajorityDamageType();

                #region BaseAnimalNPC

                if (IsAnimal(entity))
                {
                    if (!AttackerIsRealPlayer) return null;
                    if (!GetBuffDetails(info.InitiatorPlayer.userID, out bd))
                    {
                        return null;
                    }
                    float value;
                    if (bd.GetBuff(Buff.Animal_NPC_Damage, out value))
                    {
                        info.damageTypes.ScaleAll(1f + value);
                    }

                    if (config.ultimate_settings.ultimate_combat.animals_enabled && bd.ContainsBuff(Buff.Combat_Ultimate) && IsUltimateEnabled(info.InitiatorPlayer, Buff.Combat_Ultimate) && CanCombatUltimateTrigger(info.InitiatorPlayer, info, damageType))
                    {
                        info.InitiatorPlayer.Heal(info.damageTypes.Total() * config.ultimate_settings.ultimate_combat.health_scale);
                    }

                    return null;
                }

                #endregion

                #region SimpleShark

                var shark = entity as SimpleShark;
                if (shark != null)
                {
                    if (!AttackerIsRealPlayer) return null;
                    if (!GetBuffDetails(info.InitiatorPlayer.userID, out bd)) return null;

                    float value;
                    if (bd.GetBuff(Buff.UnderwaterDamageBonus, out value) && IsUnderwater(info.InitiatorPlayer))
                    {
                        info.damageTypes.ScaleAll(1f + value);
                    }
                    return null;
                }
                #endregion

                #region BasePlayer

                var player = entity as BasePlayer;
                if (player != null)
                {
                    float value;
                    if ((!player.userID.IsSteamId() || ConsiderAsNPC(player)) && info.InitiatorPlayer != null)
                    {
                        var attackerPlayer = info.InitiatorPlayer;
                        if (attackerPlayer.IsNpc || !attackerPlayer.userID.IsSteamId() || attackerPlayer.skinID == 11162132011012) return null;
                        //Confirmed attacker is real.
                        if (!GetBuffDetails(attackerPlayer.userID, out bd))
                        {
                            return null;
                        }
                        var scale = 1f;
                        if (bd.GetBuff(Buff.Human_NPC_Damage, out value))
                        {
                            scale *= (1 + value);
                        }
                        if (bd.GetBuff(Buff.UnderwaterDamageBonus, out value) && IsUnderwater(player))
                        {
                            scale *= (1 + value);
                        }
                        if (player.skinID == 11162132011012 && info.WeaponPrefab != null && info.WeaponPrefab.skinID == MlrsSkin && config.bossMonster_settings.mlrs_damage_mods.TryGetValue(player.displayName, out value))
                        {
                            scale *= value;
                        }
                        info?.damageTypes?.ScaleAll(scale);
                        if (config.ultimate_settings.ultimate_combat.scientists_enabled && bd.ContainsBuff(Buff.Combat_Ultimate) && IsUltimateEnabled(info.InitiatorPlayer, Buff.Combat_Ultimate) && CanCombatUltimateTrigger(info.InitiatorPlayer, info, damageType))
                        {
                            attackerPlayer.Heal(info.damageTypes.Total() * config.ultimate_settings.ultimate_combat.health_scale);
                        }
                        return null;
                    }
                    if (!GetBuffDetails(player.userID, out bd))
                    {
                        return null;
                    }
                    if (bd == null) return null;
                    if (IsTrap(info.Initiator) && bd.GetBuff(Buff.Trap_Damage_Reduction, out value) && !config.buff_settings.raid_perk_settings.trap_damage_reduction_settings.blacklist.Contains(info.Initiator.ShortPrefabName) && PassRaidableBasesCheck(info.Initiator, Buff.Trap_Damage_Reduction))
                    {
                        var reducedValue = 1f - value;
                        if (reducedValue < 0) reducedValue = 0;
                        info.damageTypes.ScaleAll(reducedValue);
                        if (reducedValue > 0) AddRegenDelay(player);
                        HandleBearBuff(player, info, damageType);
                        return null;
                    }
                    var damage = info.damageTypes.GetMajorityDamageType();
                    switch (damage)
                    {
                        case Rust.DamageType.Thirst:
                        case Rust.DamageType.Hunger:
                            AddRegenDelay(player);
                            return null;
                        case Rust.DamageType.Cold:
                        case Rust.DamageType.ColdExposure:
                            if (bd.ContainsBuff(Buff.No_Cold_Damage))
                            {
                                player.metabolism.temperature.SetValue(20f);
                                info.damageTypes.ScaleAll(0f);
                                return null;
                            }
                            else AddRegenDelay(player);
                            return null;
                        case Rust.DamageType.Radiation:
                        case Rust.DamageType.RadiationExposure:
                            if (bd.GetBuff(Buff.Radiation_Reduction, out value))
                            {
                                var reducedValue = 1f - value;
                                if (reducedValue < 0) reducedValue = 0;
                                if (reducedValue == 0)
                                {
                                    player.metabolism.radiation_level.SetValue(0);
                                    player.metabolism.radiation_poison.SetValue(0);
                                }
                                info.damageTypes.ScaleAll(reducedValue);
                                if (reducedValue > 0) AddRegenDelay(player);
                            }
                            else AddRegenDelay(player);
                            return null;
                        case Rust.DamageType.Heat:
                            if (bd.GetBuff(Buff.Fire_Damage_Reduction, out value) || (config.buff_settings.raid_perk_settings.personal_explosive_reduction_settings.fire_damage_reduction && bd.GetBuff(Buff.Personal_Explosive_Reduction, out value) && info.InitiatorPlayer != null && info.InitiatorPlayer == player))
                            {
                                var reducedValue = 1f - value;
                                if (reducedValue < 0) reducedValue = 0;
                                info.damageTypes.ScaleAll(reducedValue);
                                if (reducedValue > 0) AddRegenDelay(player);
                            }
                            else AddRegenDelay(player);
                            return null;
                        case Rust.DamageType.Fall:
                            if (HasAnimalBuff(player, AnimalBuff.Chicken)) info.damageTypes.ScaleAll(0f);
                            else if (bd.GetBuff(Buff.Fall_Damage_Reduction, out value))
                            {
                                var reducedValue = 1f - value;
                                if (reducedValue < 0) reducedValue = 0;
                                if (reducedValue > 0) AddRegenDelay(player);
                                info.damageTypes.ScaleAll(reducedValue);
                            }
                            else AddRegenDelay(player);
                            HandleBearBuff(player, info, Rust.DamageType.Fall);
                            return null;
                        case Rust.DamageType.Collision:
                            if (!player.isMounted) break;
                            var vehicle = player.GetMountedVehicle();
                            if (vehicle == null || !bd.GetBuff(Buff.DriverCollisionResistance, out value)) break;

                            info.damageTypes.Scale(Rust.DamageType.Collision, Mathf.Max(0, 1f - value));
                            return null;
                    }
                    var attacker = info.Initiator;
                    if (attacker == null) return null;
                    if (bd.GetBuff(Buff.Animal_Damage_Resist, out value) && config.buff_settings.animals.Contains(attacker.ShortPrefabName))
                    {
                        var reducedValue = 1f - value;
                        if (reducedValue < 0) reducedValue = 0;
                        info.damageTypes.ScaleAll(reducedValue);
                        if (reducedValue > 0) AddRegenDelay(player);
                        HandleBearBuff(player, info, damageType);
                        return null;
                    }
                    if (bd.GetBuff(Buff.SharkResistance, out value) && attacker is SimpleShark)
                    {
                        var reducedValue = 1f - value;
                        if (reducedValue < 0) reducedValue = 0;
                        info.damageTypes.ScaleAll(reducedValue);
                        if (reducedValue > 0) AddRegenDelay(player);
                        HandleBearBuff(player, info, damageType);
                        return null;
                    }
                    var damageScale = 1f;
                    var player_attacker = attacker as BasePlayer;
                    if (player_attacker != null && AttackerIsRealPlayer)
                    {
                        if (bd.GetBuff(Buff.Melee_Resist, out value))
                        {
                            var heldEntity = player_attacker.GetHeldEntity();
                            if (heldEntity != null && heldEntity is BaseMelee)
                            {
                                damageScale -= value;
                            }
                        }

                        if (bd.GetBuff(Buff.PVP_Shield, out value))
                        {
                            damageScale -= value;
                        }

                        // hurt self
                        if (player_attacker == player)
                        {
                            if (bd.GetBuff(Buff.Personal_Explosive_Reduction, out value) && (info.WeaponPrefab == null || !config.buff_settings.raid_perk_settings.personal_explosive_reduction_settings.blacklist.Contains(info.WeaponPrefab.ShortPrefabName)) && IsExplosivePrefab(info.WeaponPrefab, damageType))
                            {
                                var reducedValue = 1f - value;
                                if (reducedValue < 0) reducedValue = 0;
                                info.damageTypes.ScaleAll(reducedValue);
                                if (reducedValue > 0) AddRegenDelay(player);
                                HandleBearBuff(player, info, damageType);
                                return null;
                            }
                        }

                        BuffDetails abd;
                        if (GetBuffDetails(player_attacker.userID, out abd))
                        {
                            if (abd.GetBuff(Buff.PVP_Critical, out value) && RollSuccessful(value))
                            {
                                damageScale += UnityEngine.Random.Range(0.01f, config.buff_settings.pvp_critical_modifier);
                            }
                            if (abd.GetBuff(Buff.PVP_Damage, out value))
                            {
                                damageScale += value;
                            }

                            if (config.buff_settings.UnderwaterDamageBonus_pvp && abd.GetBuff(Buff.UnderwaterDamageBonus, out value) && IsUnderwater(player_attacker))
                            {
                                damageScale += value;
                            }

                            if (config.ultimate_settings.ultimate_combat.players_enabled && abd.ContainsBuff(Buff.Combat_Ultimate) && IsUltimateEnabled(info.InitiatorPlayer, Buff.Combat_Ultimate) && CanCombatUltimateTrigger(info.InitiatorPlayer, info, damageType))
                            {
                                player_attacker.Heal(info.damageTypes.Total() * config.ultimate_settings.ultimate_combat.health_scale);
                            }
                        }
                    }
                    var npc_attacker = attacker as NPCPlayer;
                    if (npc_attacker != null)
                    {
                        if (bd.GetBuff(Buff.Human_NPC_Defence, out value))
                        {
                            damageScale -= value;
                        }
                    }
                    if (damageScale < 0) damageScale = 0;
                    if (damageScale != 1f) info.damageTypes.ScaleAll(damageScale);
                    if (damageScale > 0) AddRegenDelay(player);
                    HandleBearBuff(player, info, damageType);
                    return null;
                }
                #endregion

                #region LootContainer

                var lootContainer = entity as LootContainer;
                if (lootContainer != null)
                {
                    if (!AttackerIsRealPlayer) return null;
                    if (lootContainer.ShortPrefabName == "trash-pile-1") return null;
                    if (GetBuffDetails(info.InitiatorPlayer.userID, out bd))
                    {
                        if (bd.ContainsBuff(Buff.Barrel_Smasher) && IsBarrel(lootContainer.ShortPrefabName, true)) info?.damageTypes?.ScaleAll(100f);
                        if (info?.damageTypes?.Total() >= lootContainer?.health)
                        {
                            if (bd.GetBuff(Buff.Extra_Scrap_Barrel, out var value) && IsBarrel(lootContainer.ShortPrefabName) && lootContainer.inventory != null && RollSuccessful(value))
                            {
                                lootContainer.inventory.capacity++;
                                var item = ItemManager.CreateByName("scrap", UnityEngine.Random.Range(config.buff_settings.min_extra_scrap, config.buff_settings.max_extra_scrap + 1));
                                if (!item.MoveToContainer(lootContainer.inventory)) item.Remove();
                            }
                            if (bd.GetBuff(Buff.Component_Barrel, out value) && IsBarrel(lootContainer.ShortPrefabName) && RollSuccessful(value))
                            {
                                var item = GetRandomItemDef(ItemCategory.Component, config.buff_settings.min_components, config.buff_settings.max_components);
                                AddItemsToBarrel(item, lootContainer);
                            }
                            if (bd.GetBuff(Buff.Electronic_Barrel, out value) && IsBarrel(lootContainer.ShortPrefabName) && RollSuccessful(value))
                            {
                                var item = GetRandomItemDef(ItemCategory.Electrical, config.buff_settings.min_electrical_components, config.buff_settings.max_electrical_components);
                                AddItemsToBarrel(item, lootContainer);
                            }
                            List<Item> _containerItems = Pool.Get<List<Item>>();
                            try
                            {
                                if (bd.ContainsBuff(Buff.Scavengers_Ultimate) && IsUltimateEnabled(info.InitiatorPlayer, Buff.Scavengers_Ultimate) && lootContainer != null && lootContainer.inventory != null && lootContainer.inventory.itemList != null)
                                {
                                    _containerItems.AddRange(lootContainer.inventory.itemList);
                                    foreach (var item in _containerItems)
                                    {
                                        ScrapItems(item, lootContainer);
                                    }
                                }
                            }
                            finally
                            {
                                Pool.FreeUnmanaged(ref _containerItems);
                            }
                        }
                    }

                    return null;
                }
                #endregion

                #region BaseMountable
                var mountable = entity as BaseMountable;
                if (mountable != null)
                {
                    #region BaseVehicle

                    var vehicle = mountable as BaseVehicle;
                    if (vehicle != null)
                    {
                        var driver = vehicle.GetDriver();
                        if (driver == null) return null;
                        if (GetBuffDetails(driver.userID, out bd) && bd.GetBuff(Buff.Vehicle_Ultimate, out var value))
                        {
                            ScaleVehicleDamage(info, value);
                        }
                        return null;
                    }

                    #endregion

                }
                #endregion
            }
            catch
            {
            }


            return null;
        }

        void ScaleVehicleDamage(HitInfo info, float value)
        {
            if (config.ultimate_settings.ultimate_vehicle.prevent_damage_from_sams || info.WeaponPrefab?.ShortPrefabName != "rocket_sam")
                info.damageTypes.ScaleAll(1f - value);
        }

        bool IsExplosivePrefab(BaseEntity entity, Rust.DamageType damageType)
        {
            if (damageType == Rust.DamageType.Explosion || damageType == Rust.DamageType.AntiVehicle) return true;
            if (entity == null) return false;

            switch (entity.ShortPrefabName)
            {
                case "explosive.satchel.deployed":
                case "grenade.beancan.deployed":
                case "grenade.f1.deployed":
                case "grenade.flashbang.deployed":
                case "40mm_grenade_he":
                case "rocket_hv":
                    return true;

                default: return false;
            }
        }

        bool ConsiderAsNPC(BasePlayer player)
        {
            if (config.misc_settings.botRespawnSettings.BotRespawn_IsNPC && BotReSpawn != null && BotReSpawn.IsLoaded && Convert.ToBoolean(BotReSpawn.Call("IsBotReSpawn", player.userID.Get()))) return true;
            if (player.skinID == 11162132011012) return true;
            return false;
        }

        #endregion

        object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (action.Equals("gut", StringComparison.OrdinalIgnoreCase)) AwardXP(player, config.xp_settings.xp_sources.Gut_Fish, null, false, false, nameof(config.xp_settings.xp_sources.Gut_Fish));
            return null;
        }

        //object OnItemUse(Item item, int amountToUse)
        //{
        //    var player = item.GetOwnerPlayer();
        //    if (player == null) return null;
        //    BuffDetails bd;
        //    if (GetBuffDetails(player.userID, out bd) && bd.GetBuff(Buff.Rationer, out var value))
        //    {
        //        if (item.info.category == ItemCategory.Food && RollSuccessful(value) && !config.buff_settings.no_refund_item_skins.Contains(item.skin) && !item.info.shortname.StartsWith("fish.", StringComparison.Ordinal) && !item.info.shortname.StartsWith("clone.", StringComparison.Ordinal) && !item.info.shortname.StartsWith("seed.", StringComparison.Ordinal))
        //        {
        //            if (!PassCookingChecks(item)) return null;
        //            if (Interface.CallHook("STOnRationTrigger", player, item) != null) return null;
        //            var refunded_item = ItemManager.CreateByName(item.info.shortname, amountToUse, item.skin);
        //            if (item.name != null) refunded_item.name = item.name;
        //            GiveItem(player, refunded_item);
        //            //player.GiveItem(refunded_item);                   
        //            if (config.notification_settings.chatMessageNotificationSettings.Rationed_Proc && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("Rationed", this, player.UserIDString), item.name ?? item.info.displayName.english), config.misc_settings.ChatID);
        //        }
        //    }
        //    return null;
        //}

        bool PassCookingChecks(Item item)
        {
            if (Cooking != null && Cooking.IsLoaded)
            {
                if (Convert.ToBoolean(Cooking.Call("IsCookingMeal", item))) return config.misc_settings.ration_cooking_meals;
                if (Convert.ToBoolean(Cooking.Call("IsCustomIngredient", item))) return false;
            }
            return true;
        }

        bool NotificationsOn(BasePlayer player)
        {
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData) || playerData.notifications) return true;
            return false;
        }

        void OnPlayerRevive(BasePlayer reviver, BasePlayer player)
        {
            if (reviver == null || player == null) return;
            BuffDetails bd;
            if (GetBuffDetails(reviver.userID, out bd) && bd.GetBuff(Buff.Reviver, out var value))
            {
                BasePlayer revived_player = player;
                NextTick(() =>
                {
                    if (revived_player == null) return;
                    var healthFor = 100 * value;
                    if (healthFor > revived_player.health) revived_player.SetHealth(healthFor);
                });
            }
        }

        void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            try
            {
                if (newItem == null)
                {
                    Timer timer;
                    if (MiningUltimate_AutoTrigger_Timers.TryGetValue(player.userID, out timer))
                    {
                        if (timer != null && !timer.Destroyed) timer.Destroy();
                        MiningUltimate_AutoTrigger_Timers.Remove(player.userID);
                    }
                    return;
                }
                if (!IsPickaxe(newItem.info.shortname)) return;

                TriggerMiningUltimateFromItem(player);
            }
            catch
            {
                
            }
        }

        bool IsPickaxe(string shortname)
        {
            if (config == null || config.ultimate_settings == null || config.ultimate_settings.ultimate_mining == null || config.ultimate_settings.ultimate_mining.tools_list == null) LogToFile("IsPickaxe", "config.ultimate_settings.ultimate_mining.tools_list is null somehow.", this, false, true);
            return config.ultimate_settings.ultimate_mining.tools_list.Contains(shortname);
        }

        Dictionary<ulong, Timer> MiningUltimate_AutoTrigger_Timers = new Dictionary<ulong, Timer>();

        void OnPlayerAssist(BasePlayer target, BasePlayer player) => OnPlayerRevive(player, target);

        void OnMissionSucceeded(BaseMission mission, BaseMission.MissionInstance missionInstance, BasePlayer player)
        {
            AwardXP(player, config.xp_settings.xp_sources.Mission, null, false, false, nameof(config.xp_settings.xp_sources.Mission));
        }

        void HandleExistingData(Dictionary<string, PlayerInfo> allPlayers)
        {

            foreach (var kvp in allPlayers)
            {
                if (config.wipe_update_settings.xp_debt_wipe) kvp.Value.xp_debt = 0;

                kvp.Value.last_xp_loss = DateTime.Now;
                kvp.Value.raiding_ultimate_used_time = DateTime.MinValue;
                kvp.Value.cooking_ultimate_used_time = DateTime.MinValue;
                kvp.Value.Trap_Spotter_used_time = DateTime.Now;
                kvp.Value.Loot_Spotter_used_time = DateTime.Now;

                if (config.wipe_update_settings.respec_multiplier_wipe) kvp.Value.respec_multiplier = 0;
                if (config.rested_xp_settings.rested_xp_reset_on_wipe)
                {
                    kvp.Value.xp_bonus_pool = 0;
                    kvp.Value.logged_off = DateTime.Now;
                }

                if (config.wipe_update_settings.reset_pending_xp_on_wipe)
                {
                    kvp.Value.pending_xp_without_bonus = 0;
                    kvp.Value.pending_xp_with_bonus = 0;
                }

                if (config.wipe_update_settings.erase_ExtraPockets_on_wipe) kvp.Value.pouch_items.Clear();

                if (config.wipe_update_settings.xp_wipe_type == Configuration.WipeUpdate.WipeType.Reset)
                {
                    try
                    {
                        RunResetCommands(kvp.Key, kvp.Value.prestige_level > 0 ? config.general_settings.max_player_level : kvp.Value.achieved_level);
                    }
                    catch { }
                    kvp.Value.achieved_level = 0;
                    kvp.Value.current_level = 0;
                    kvp.Value.xp = 0;
                    kvp.Value.available_points = 0;
                    kvp.Value.buff_values.Clear();
                    kvp.Value.pending_xp_without_bonus = 0;
                    kvp.Value.pending_xp_with_bonus = 0;
                    kvp.Value.pouch_items.Clear();
                    kvp.Value.ultimate_settings.Clear();
                    kvp.Value.non_level_related_points_given = 0;
                }
                else if (config.wipe_update_settings.xp_wipe_type == Configuration.WipeUpdate.WipeType.Refund)
                {
                    var pointsSpent = 0;
                    foreach (var buff in kvp.Value.buff_values)
                        pointsSpent += buff.Value;

                    kvp.Value.buff_values.Clear();
                    kvp.Value.available_points += pointsSpent;
                    kvp.Value.ultimate_settings.Clear();
                    try
                    {
                        RemovePerms(kvp.Key, true);
                    }
                    catch { }
                }

                if (config.wipe_update_settings.prestige_wipe)
                {
                    try
                    {
                        RemovePrestigeGroup(kvp.Key, kvp.Value.prestige_level);
                    }
                    catch { }
                    kvp.Value.prestige_level = 0;
                    kvp.Value.prestige_xp_mod = 0;
                }
            }
        }

        void AwardBestPlayer(Dictionary<string, PlayerInfo> allPlayers)
        {
            if (!config.wipe_update_settings.bonus_skill_points) return;
            string highest_player = null;
            var highest_xp = 0d;
            foreach (var kvp in allPlayers)
            {
                if (kvp.Value.xp > highest_xp)
                {
                    highest_xp = kvp.Value.xp;
                    highest_player = kvp.Key;
                }
            }
            Puts($"The player with the highest score is {highest_player} with {highest_xp} xp achieved.");
            pcdData.HighestPlayer = Convert.ToUInt64(highest_player);
        }

        void OnNewSave(string filename)
        {
            if (config.wipe_update_settings.wipe_everything)
            {
                ResetAllData();
                return;
            }

            List<string> files = Pool.Get<List<string>>();
            files.AddRange(Directory.GetFiles(NewDirectory));
            Dictionary<string, PlayerInfo> allPlayers = new Dictionary<string, PlayerInfo>();
            List<string> ToDelete = Pool.Get<List<string>>();
            foreach (var file in files)
            {
                try
                {
                    var name = FormatUserIDFromPath(file);
                    var data = JsonConvert.DeserializeObject<PlayerInfo>(File.ReadAllText(file));
                    if (config.wipe_update_settings.wipe_after_days > 0 && (DateTime.Now - data.logged_off).TotalDays >= config.wipe_update_settings.wipe_after_days)
                    {
                        ToDelete.Add(name);
                        continue;
                    }
                    allPlayers.Add(name, data);
                }
                catch { }
            }
            Pool.FreeUnmanaged(ref files);

            foreach (var delete in ToDelete)
            {
                try
                {
                    File.Delete(delete);
                }
                catch
                {
                    
                }
            }

            Pool.FreeUnmanaged(ref ToDelete);

            HandleExistingData(allPlayers);

            AwardBestPlayer(allPlayers);

            foreach (var data in allPlayers)
            {
                try
                {
                    File.WriteAllText(NewDirectory + $"{data.Key}.json", JsonConvert.SerializeObject(data.Value, Formatting.Indented));
                }
                catch { Puts($"Failed to write data for {data.Key ?? "Null key"}"); }
            }

            pcdData.wipeTime = DateTime.Now;
            allPlayers.Clear();
            allPlayers = null;
        }

        object OnHealingItemUse(MedicalTool tool, BasePlayer player)
        {
            if (player == null || player.IsNpc || !player.userID.IsSteamId()) return null;
            var item = tool.GetItem();
            if (item == null || item.info.shortname != "bandage") return null;
            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - OnHealingItemUse. [Online = {player.IsConnected}]", this, true);
                return null;
            }
            if (bd.ContainsBuff(Buff.Double_Bandage_Heal))
            {
                if (!healers.Contains(player) && (config.buff_settings.Double_Bandage_Heal_Cooldown == 0 || bd.cooldown_Double_Bandage_Heal < Time.time))
                {
                    bd.cooldown_Double_Bandage_Heal = Time.time + config.buff_settings.Double_Bandage_Heal_Cooldown;
                    if (config.buff_settings.Double_Bandage_Heal_Cooldown > 0 && config.notification_settings.chatMessageNotificationSettings.Cooldown_Double_Bandage_Heal && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("CooldownNotify", this, player.UserIDString), Buff.Double_Bandage_Heal.ToString().Replace("_", " "), config.buff_settings.Double_Bandage_Heal_Cooldown));
                    healers.Add(player);
                }
            }
            return null;
        }

        List<BasePlayer> healers = new List<BasePlayer>();

        void OnPlayerHealthChange(BasePlayer player, float oldValue, float newValue)
        {
            if (player == null || player.IsNpc || !player.userID.IsSteamId()) return;
            if (newValue < oldValue) return;
            if (healers.Contains(player))
            {
                healers.Remove(player);
                player.Heal(newValue - oldValue);
            }
            if (HasAnimalBuff(player, AnimalBuff.Wolf) && player.Team != null && player.Team.teamID > 0)
            {
                List<BasePlayer> nearby_players = Pool.Get<List<BasePlayer>>();
                var entities = FindEntitiesOfType<BasePlayer>(player.transform.position, config.ultimate_settings.ultimate_skinning.wolf_team_dist);
                nearby_players.AddRange(entities.Where(x => x.Team != null && x.Team.teamID == player.Team.teamID));
                Pool.FreeUnmanaged(ref entities);

                Unsubscribe(nameof(OnPlayerHealthChange));
                player._health += Mathf.Clamp((newValue - oldValue) * (nearby_players.Count * config.ultimate_settings.ultimate_skinning.wolf_health_scale), 0f, player.MaxHealth());
                player.SendNetworkUpdate();
                Subscribe(nameof(OnPlayerHealthChange));

                Pool.FreeUnmanaged(ref nearby_players);
            }
            if (GetBuffDetails(player.userID, out var bd) && bd.GetBuff(Buff.Heal_Share, out var value)) HandleHPShare(player, oldValue, newValue, value);
        }

        void HandleHPShare(BasePlayer player, float oldValue, float newValue, float modifier)
        {
            if (player.Team == null) return;

            var nearby = FindNearbyTeamMates(player, config.buff_settings.healShareSettings.Distance);
            foreach (var _player in nearby)
            {
                if (_player == player || !_player.IsConnected || _player.IsDead() || _player.Team == null || _player.Team.teamID != player.Team.teamID) continue;
                _player._health += (newValue - oldValue) * modifier;
                _player.SendNetworkUpdate();
            }
        }

        object OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item) => HandleDispenser(dispenser, player, item);

        object HandleDispenser(ResourceDispenser dispenser, BasePlayer player, Item item, bool bonus = false)
        {
            if (player.IsNpc || !player.userID.IsSteamId() || dispenser == null || item == null) return null;

            BuffDetails bd;
            var tool = player.GetActiveItem();
            if (config.misc_settings.call_HandleDispenser) Interface.CallHook("OnSkillTreeHandleDispenser", player, dispenser.baseEntity, item);

            int tea_addition = 0;
            if (config.misc_settings.prevent_tea_bonus_on_yields)
            {
                int teaYield = GetModifierAmount(player, dispenser, item.amount);
                item.amount -= teaYield;
                tea_addition = teaYield;
            }
            item.amount = GetMultipliedItemAmount(item);

            if (tool != null && config.tools_black_white_list_settings.black_listed_gather_items.Contains(tool.info.shortname)) return null;
            if (!GetBuffDetails(player.userID, out bd))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - HandleDispenser. [Online = {player.IsConnected}]", this, true);
                return null;
            }

            HeldEntity heldEntity = player.GetHeldEntity();
            var gather_modifier = 1f;
            var xp_modifier = 1f;
            var luck_modifier = 1f;

            int bonusItemAmount = 0;
            if (dispenser.gatherType == ResourceDispenser.GatherType.Tree)
            {
                if (heldEntity != null && heldEntity is Chainsaw)
                {
                    gather_modifier = config.tools_black_white_list_settings.power_tool_modifier.woodcutting_yield_modifier;
                    xp_modifier = config.tools_black_white_list_settings.power_tool_modifier.woodcutting_xp_modifier;
                    luck_modifier = config.tools_black_white_list_settings.power_tool_modifier.woodcutting_luck_modifier;
                }

                if (!bonus)
                {
                    if (PassWhitelistCheck(player, tool, GatherSourceType.Woodcutting)) AwardXP(player, config.xp_settings.xp_sources.TreeHit * xp_modifier, dispenser.baseEntity, false, false, nameof(config.xp_settings.xp_sources.TreeHit));
                }

                var nightAmount = TOD_Sky.Instance.IsNight ? Convert.ToInt32(item.amount * (config.xp_settings.night_settings.night_woodcutting_yield_modifier - 1)) : 0;

                if (bd.GetBuff(Buff.Woodcutting_Yield, out var buffValue))
                {
                    bonusItemAmount += GetYield(dispenser, player, item, bd, gather_modifier, buffValue);
                }

                bonusItemAmount += nightAmount;
                bonusItemAmount += tea_addition;

                if (!bonus && bd.GetBuff(Buff.Instant_Chop, out buffValue) && RollSuccessful((buffValue * luck_modifier)))
                {
                    bonusItemAmount += HandleInstantChop(dispenser, player, item, bd);
                }

                //if (!bonus && bd.GetBuffValue(Buff.Instant_Chop, out value) && RollSuccessful((value * luck_modifier)))
                //{
                //    foreach (var r in dispenser.containedItems)
                //    {
                //        if (r.amount < 1) continue;
                //        r.amount = GetMultipliedItemAmount(r.itemDef.shortname, Convert.ToInt32(r.amount));
                //        var bonus_amount = Convert.ToInt32(r.amount + (r.amount * (TOD_Sky.Instance.IsNight ? (config.xp_settings.night_settings.night_woodcutting_yield_modifier - 1) * gather_modifier : 0)) + (r.amount * (bd.GetBuffValue(Buff.Woodcutting_Yield, out value) ? value * gather_modifier : 0)));

                //        if (r.itemDef.shortname == item.info.shortname) item.amount += bonus_amount;
                //        else
                //        {
                //            //player.GiveItem(ItemManager.CreateByName(r.itemDef.shortname, amount_to_give));
                //            if (bonus_amount > 0) GiveItem(player, ItemManager.CreateByName(r.itemDef.shortname, bonus_amount));
                //        }

                //        r.amount = 0;
                //    }
                //}
                if (bd.GetBuff(Buff.Woodcutting_Coal, out buffValue) && RollSuccessful((buffValue * gather_modifier)))
                {
                    GiveItem(player, ItemManager.CreateByName("charcoal", item.amount + bonusItemAmount));
                    //player.GiveItem(ItemManager.CreateByName("charcoal", item.amount));
                }
                if (bonusItemAmount > 0)
                    if (config.buff_settings.additiveYields) item.amount += bonusItemAmount;
                    else player.GiveItem(ItemManager.CreateByItemID(item.info.itemid, bonusItemAmount));
            }
            if (dispenser.gatherType == ResourceDispenser.GatherType.Ore)
            {
                if (heldEntity != null && heldEntity is Jackhammer)
                {
                    gather_modifier = config.tools_black_white_list_settings.power_tool_modifier.mining_yield_modifier;
                    xp_modifier = config.tools_black_white_list_settings.power_tool_modifier.mining_xp_modifier;
                    luck_modifier = config.tools_black_white_list_settings.power_tool_modifier.mining_luck_modifier;
                }

                if (!bonus)
                {
                    if (PassWhitelistCheck(player, tool, GatherSourceType.Mining)) AwardXP(player, config.xp_settings.xp_sources.NodeHit * xp_modifier, dispenser.baseEntity, false, false, nameof(config.xp_settings.xp_sources.NodeHit));
                }

                var nightAmount = TOD_Sky.Instance.IsNight ? Convert.ToInt32(item.amount * ((config.xp_settings.night_settings.night_mining_yield_modifier - 1) * gather_modifier)) : 0;

                if (bd.GetBuff(Buff.Mining_Yield, out var buffValue))
                {
                    bonusItemAmount += GetYield(dispenser, player, item, bd, gather_modifier, buffValue);
                }
                bonusItemAmount += nightAmount;
                bonusItemAmount += tea_addition;

                if (!bonus && bd.GetBuff(Buff.Instant_Mine, out buffValue) && RollSuccessful((buffValue * luck_modifier)))
                {
                    bonusItemAmount += HandleInstantMining(dispenser, player, item, bd);
                }
                if (dispenser.baseEntity != null && !string.IsNullOrEmpty(dispenser.baseEntity.ShortPrefabName) && dispenser.baseEntity.ShortPrefabName != "stone-ore" && bd.GetBuff(Buff.Smelt_On_Mine, out var value) && RollSuccessful((value * gather_modifier)))
                {
                    HandleSmeltOnMine(player, item, bonusItemAmount);
                    bonusItemAmount = 0;
                }
                if (bonusItemAmount > 0)
                    if (config.buff_settings.additiveYields) item.amount += bonusItemAmount;
                    else player.GiveItem(ItemManager.CreateByItemID(item.info.itemid, bonusItemAmount));
            }
            if (dispenser.gatherType == ResourceDispenser.GatherType.Flesh)
            {
                if (heldEntity != null && (heldEntity is Jackhammer || heldEntity is Chainsaw))
                {
                    gather_modifier = config.tools_black_white_list_settings.power_tool_modifier.skinning_yield_modifier;
                    xp_modifier = config.tools_black_white_list_settings.power_tool_modifier.skinning_xp_modifier;
                    luck_modifier = config.tools_black_white_list_settings.power_tool_modifier.skinning_luck_modifier;
                }
                bool isFinalHit = dispenser.containedItems.FirstOrDefault(x => x.amount > 0) == null;
                // Old award xp spot

                if (isFinalHit && dispenser.baseEntity.ShortPrefabName.Equals("shark.corpse") && bd.GetBuff(Buff.SharkSkinner, out var value) && RollSuccessful(value * luck_modifier))
                {
                    var randomItem = GetSharkLoot().GetRandom();
                    var _item = ItemManager.CreateByName(randomItem.shortname, randomItem.max == 1 ? 1 : UnityEngine.Random.Range(randomItem.min > 1 ? randomItem.min : 1, randomItem.max));
                    player.GiveItem(_item);
                    Player.Message(player, String.Format(lang.GetMessage("SharkStomachFound", this, player.UserIDString), _item.amount > 1 ? lang.GetMessage("some", this, player.UserIDString) : lang.GetMessage("a", this, player.UserIDString), _item.info.displayName.english), config.misc_settings.ChatID);
                }

                var nightAmount = TOD_Sky.Instance.IsNight ? Convert.ToInt32(item.amount * (config.xp_settings.night_settings.night_skinning_yield_modifier - 1)) : 0;

                if (bd.GetBuff(Buff.Skinning_Yield, out var buffValue))
                {
                    bonusItemAmount += GetYield(dispenser, player, item, bd, gather_modifier, buffValue);
                }

                bonusItemAmount += nightAmount;

                if (!isFinalHit && bd.GetBuff(Buff.Instant_Skin, out value) && RollSuccessful((value * luck_modifier)))
                {
                    Interface.CallHook("OnInstantGatherTrigger", player, dispenser, this.Name);
                    foreach (var r in dispenser.containedItems)
                    {
                        if (r.amount < 1) continue;
                        r.amount = GetMultipliedItemAmount(r.itemDef.shortname, Convert.ToInt32(r.amount));
                        var bonus_amount = Convert.ToInt32(r.amount + (r.amount * (TOD_Sky.Instance.IsNight ? (config.xp_settings.night_settings.night_skinning_yield_modifier - 1) * gather_modifier : 0)) + (r.amount * (bd.GetBuff(Buff.Skinning_Yield, out var skinYield) ? skinYield * gather_modifier : 0)));
                        if (r.itemDef.shortname == item.info.shortname) bonusItemAmount += bonus_amount;
                        else if (bonus_amount > 0)
                        {
                            var newItem = ItemManager.CreateByName(r.itemDef.shortname, bonus_amount);
                            Interface.CallHook("OnInstantGatherTriggered", player, dispenser, newItem, this.Name);
                            GiveItem(player, newItem);
                        }

                        r.amount = 0;
                    }
                    isFinalHit = true;
                }
                if (bd.GetBuff(Buff.Skin_Cook, out value) && RollSuccessful((value * luck_modifier)))
                {
                    var cooked = GetCookedMeat(item.info.shortname);
                    if (!string.IsNullOrEmpty(cooked))
                    {
                        GiveItem(player, ItemManager.CreateByName(cooked, item.amount + bonusItemAmount));
                        //player.GiveItem(ItemManager.CreateByName(cooked, item.amount));
                        item.amount = 0;
                        item.Remove();
                    }
                    bonusItemAmount = 0;
                }

                if (isFinalHit && bd.GetBuff(Buff.Skinning_Luck, out value) && RollSuccessful((value * luck_modifier)) && config.loot_settings.skinning_loot_table.Count > 0)
                {
                    var randProfile = RollLootItem(config.loot_settings.skinning_loot_table);
                    if (randProfile != null)
                    {
                        var randomitem = CreateDropItem(randProfile);
                        if (randomitem != null)
                        {
                            if (config.notification_settings.chatMessageNotificationSettings.SkinningLuck_Proc && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("ItemFound", this, player.UserIDString), randomitem.amount, randomitem.name ?? randomitem.info.displayName.english, "corpse"), config.misc_settings.ChatID);
                            if (randomitem != null) player.GiveItem(randomitem);
                        }
                    }
                    //if (def != null) player.GiveItem(ItemManager.CreateByName(randomitem.Key, quantity));                    
                }

                if (bonusItemAmount > 0)
                    if (config.buff_settings.additiveYields) item.amount += bonusItemAmount;
                    else player.GiveItem(ItemManager.CreateByItemID(item.info.itemid, bonusItemAmount));

                if (PassWhitelistCheck(player, tool, GatherSourceType.Skinning)) AwardXP(player, (isFinalHit ? config.xp_settings.xp_sources.SkinHitFinal : config.xp_settings.xp_sources.SkinHit) * xp_modifier, dispenser.baseEntity, false, false, isFinalHit ? nameof(config.xp_settings.xp_sources.SkinHitFinal) : nameof(config.xp_settings.xp_sources.SkinHit));
            }

            return null;
        }

        // Credit Nivex
        private int GetModifierAmount(BasePlayer player, ResourceDispenser dispenser, int itemAmount)
        {
            if (dispenser.gatherType == ResourceDispenser.GatherType.Flesh) return 0;
            float yieldModifier = 0;

            if (permission.UserHasPermission(player.UserIDString, perm_teaBonus)) // Person is allowed full tea bonus before skills
            {
                return 0;
            }
            switch (dispenser.gatherType)
            {
                case ResourceDispenser.GatherType.Tree:
                    yieldModifier = player.modifiers.GetValue(Modifier.ModifierType.Wood_Yield);
                    break;
                case ResourceDispenser.GatherType.Ore:
                    yieldModifier = player.modifiers.GetValue(Modifier.ModifierType.Ore_Yield);
                    break;
            }
            if (yieldModifier == 0)
            {
                return 0;
            }
            return (int)(itemAmount - (itemAmount / (1f + yieldModifier)));
        }

        void HandleSmeltOnMine(BasePlayer player, Item item, int bonusAmount)
        {
            var refined = GetRefinedMaterial(item.info.shortname);
            if (!string.IsNullOrEmpty(refined))
            {
                GiveItem(player, ItemManager.CreateByName(refined, Math.Max(item.amount + bonusAmount, 1)));
                item.amount = 0;
                item.Remove();
            }
        }

        float GetTeaModifiedAmount(BasePlayer player, ResourceDispenser dispenser, float amount, out bool applyBefore)
        {
            applyBefore = false;
            float modifier;
            switch (dispenser.gatherType)
            {
                case ResourceDispenser.GatherType.Ore:
                    modifier = player.modifiers.GetValue(Modifier.ModifierType.Ore_Yield);
                    break;

                case ResourceDispenser.GatherType.Tree:
                    modifier = player.modifiers.GetValue(Modifier.ModifierType.Wood_Yield);
                    break;

                default: return 0;
            }

            if (!config.misc_settings.prevent_tea_bonus_on_yields || permission.UserHasPermission(player.UserIDString, perm_teaBonus)) applyBefore = true;

            return amount * modifier;
        }

        int HandleInstantMining(ResourceDispenser dispenser, BasePlayer player, Item item, BuffDetails bd)
        {
            Interface.CallHook("OnInstantGatherTrigger", player, dispenser, this.Name);
            var bonusItemAmount = 0;
            foreach (var r in dispenser.containedItems)
            {
                if (r.amount < 1) continue;

                var teaAmount = Mathf.RoundToInt(GetTeaModifiedAmount(player, dispenser, r.amount, out var applyBefore));
                if (applyBefore) r.amount += teaAmount;

                r.amount = GetMultipliedItemAmount(r.itemDef.shortname, r.amount);
                var bonus_amount = Convert.ToInt32(r.amount + (r.amount * (TOD_Sky.Instance.IsNight ? config.xp_settings.night_settings.night_mining_yield_modifier - 1 : 0)) + (r.amount * (bd.GetBuff(Buff.Mining_Yield, out var buffValue) ? buffValue : 0)));
                if (!applyBefore) bonus_amount += teaAmount;
                if (item.info.itemid == r.itemDef.itemid) bonusItemAmount += bonus_amount;
                else if (bonus_amount > 0)
                {
                    var newItem = ItemManager.CreateByName(r.itemDef.shortname, bonus_amount);
                    Interface.CallHook("OnInstantGatherTriggered", player, dispenser, newItem, this.Name);
                    GiveItem(player, newItem);
                }

                r.amount = 0;
            }
            return bonusItemAmount;
        }

        int HandleInstantChop(ResourceDispenser dispenser, BasePlayer player, Item item, BuffDetails bd)
        {
            Interface.CallHook("OnInstantGatherTrigger", player, dispenser, this.Name);
            var bonusAmount = 0;
            foreach (var r in dispenser.containedItems)
            {
                if (r.amount < 1) continue;

                var teaAmount = Mathf.RoundToInt(GetTeaModifiedAmount(player, dispenser, r.amount, out var applyBefore));
                if (applyBefore) r.amount += teaAmount;

                r.amount = GetMultipliedItemAmount(r.itemDef.shortname, r.amount);
                var bonus_amount = Convert.ToInt32(r.amount + (r.amount * (TOD_Sky.Instance.IsNight ? config.xp_settings.night_settings.night_woodcutting_yield_modifier - 1 : 0)) + (r.amount * (bd.GetBuff(Buff.Woodcutting_Yield, out var buffValue) ? buffValue : 0)));
                if (!applyBefore) bonus_amount += teaAmount;
                bonusAmount += bonus_amount;
                if (r.itemDef.itemid == item.info.itemid) bonusAmount += bonus_amount;
                else if (bonus_amount > 0)
                {
                    var newItem = ItemManager.CreateByName(r.itemDef.shortname, bonus_amount);
                    Interface.CallHook("OnInstantGatherTriggered", player, dispenser, newItem, this.Name);
                    GiveItem(player, newItem);
                }

                r.amount = 0;
            }
            return bonusAmount;
        }

        int GetYield(ResourceDispenser dispenser, BasePlayer player, Item item, BuffDetails bd, float gather_modifier, float buffValue)
        {
            if (Interface.CallHook("STCanReceiveYield", player, dispenser.baseEntity, item) == null)
            {
                var amount = item.amount * (buffValue * gather_modifier) + (TOD_Sky.Instance.IsNight ? item.amount * (((dispenser.gatherType == ResourceDispenser.GatherType.Ore ? config.xp_settings.night_settings.night_mining_yield_modifier : dispenser.gatherType == ResourceDispenser.GatherType.Tree ? config.xp_settings.night_settings.night_woodcutting_yield_modifier : config.xp_settings.night_settings.night_skinning_yield_modifier) - 1) * gather_modifier) : 0);
                if (amount > 0.5)
                {
                    if (amount < 1) amount = 1;
                    //item.amount += Convert.ToInt32(amount);
                }
                return Convert.ToInt32(amount);
            }
            return 0;
        }

        string GetCookedMeat(string shortname)
        {
            switch (shortname)
            {
                case "bearmeat": return "bearmeat.cooked";
                case "chicken.raw": return "chicken.cooked";
                case "deermeat.raw": return "deermeat.cooked";
                case "fish.raw": return "fish.cooked";
                case "horsemeat.raw": return "horsemeat.cooked";
                case "humanmeat.raw": return "humanmeat.cooked";
                case "meat.boar": return "meat.pork.cooked";
                case "wolfmeat.raw": return "wolfmeat.cooked";
                case "snake.entity": return "snake.cooked";
                case "meat.panther": return "meat.panther.cooked";
                case "meat.tiger": return "meat.tiger.cooked";
                case "meat.snake": return "meat.snake.cooked";
                default: return null;
            }
        }

        string GetRefinedMaterial(string shortname)
        {
            switch (shortname)
            {
                case "hq.metal.ore": return "metal.refined";
                case "metal.ore": return "metal.fragments";
                case "sulfur.ore": return "sulfur";
                default: return null;
            }
        }

        void HandleTree(BasePlayer player, ResourceDispenser dispenser)
        {
            var heldEntity = player.GetHeldEntity();
            if (heldEntity == null || !(heldEntity is AttackEntity)) return;
            // Sets the skinID to 222 if the deforest perk is triggering the tree to fall.
            dispenser.baseEntity.skinID = 222;
            dispenser.AssignFinishBonus(player, 1f, heldEntity as AttackEntity);
            HitInfo hitInfo = new HitInfo(player, dispenser.baseEntity, Rust.DamageType.Generic, dispenser.baseEntity.MaxHealth(), dispenser.transform.position);
            hitInfo.gatherScale = 0f;
            hitInfo.PointStart = dispenser.transform.position;
            hitInfo.PointEnd = dispenser.transform.position;
            hitInfo.WeaponPrefab = heldEntity;
            hitInfo.Weapon = null;
            dispenser.baseEntity.OnAttacked(hitInfo);
        }

        public static bool UltimateTriggered = false;

        LootItems RollLootItem(List<LootItems> items)
        {
            var count = 0;
            foreach (var entry in items)
                count += entry.dropWeight;

            var roll = UnityEngine.Random.Range(0, count + 1);
            var _checked = 0;

            foreach (var entry in items)
            {
                _checked += entry.dropWeight;
                if (roll <= _checked) return entry;
            }

            return items[UnityEngine.Random.Range(0, items.Count)];
        }

        Item CreateDropItem(LootItems info)
        {
            if (info == null) return null;
            var item = ItemManager.CreateByName(info.shortname, Math.Max(UnityEngine.Random.Range(info.min, info.max + 1), 1), info.skin);
            if (item == null) return null;
            if (!string.IsNullOrEmpty(info.displayName)) item.name = info.displayName;
            return item;
        }

        object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (dispenser == null || item == null || player == null || player.IsNpc || !player.userID.IsSteamId()) return null;
            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - OnDispenserBonus. [Online = {player.IsConnected}]", this, true);
                return null;
            }

            HeldEntity heldEntity = player.GetHeldEntity();
            var gather_modifier = 1f;
            var xp_modifier = 1f;
            var luck_modifier = 1f;
            if (dispenser.gatherType == ResourceDispenser.GatherType.Tree)
            {
                if (heldEntity != null && heldEntity is Chainsaw)
                {
                    gather_modifier = config.tools_black_white_list_settings.power_tool_modifier.woodcutting_yield_modifier;
                    xp_modifier = config.tools_black_white_list_settings.power_tool_modifier.woodcutting_xp_modifier;
                    luck_modifier = config.tools_black_white_list_settings.power_tool_modifier.woodcutting_luck_modifier;
                }

                float value;
                if ((!UltimateTriggered || config.ultimate_settings.ultimate_woodcutting.award_xp) && PassWhitelistCheck(player, null, GatherSourceType.WoodcuttingFinal)) AwardXP(player, config.xp_settings.xp_sources.TreeHitFinal * xp_modifier, dispenser.baseEntity, false, false, nameof(config.xp_settings.xp_sources.TreeHitFinal));

                if (bd.GetBuff(Buff.Woodcutting_Luck, out value) && RollSuccessful((value * luck_modifier)) && config.loot_settings.wc_loot_table.Count > 0)
                {
                    var randProfile = RollLootItem(config.loot_settings.wc_loot_table);
                    if (randProfile != null)
                    {
                        var randomitem = CreateDropItem(randProfile);
                        if (randomitem != null)
                        {
                            if (config.notification_settings.chatMessageNotificationSettings.WoodcuttingLuck_Proc && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("ItemFound", this, player.UserIDString), randomitem.amount, randomitem.name ?? randomitem.info.displayName.english, "tree"), config.misc_settings.ChatID);
                            player.GiveItem(randomitem);
                        }
                    }
                    //if (def != null) player.GiveItem(ItemManager.CreateByName(randomitem.Key, quantity));                    
                }
                if (bd.GetBuff(Buff.Regrowth, out value) && RollSuccessful(value * luck_modifier))
                {
                    if (Interface.Oxide.CallHook("STOnRespawnTree", player, dispenser) == null)
                        RespawnTree(player, dispenser.baseEntity.PrefabName, dispenser.baseEntity.transform.position, dispenser.baseEntity.transform.rotation);

                }
                if (!UltimateTriggered && bd.ContainsBuff(Buff.Woodcutting_Ultimate) && IsUltimateEnabled(player, Buff.Woodcutting_Ultimate) && luck_modifier > 0 && (config.ultimate_settings.ultimate_woodcutting.cooldown_between_uses == 0 || bd.cooldown_Woodcutting_Ultimate < Time.time))
                {
                    bd.cooldown_Woodcutting_Ultimate = Time.time + config.ultimate_settings.ultimate_woodcutting.cooldown_between_uses;
                    if (config.ultimate_settings.ultimate_woodcutting.cooldown_between_uses > 0 && config.notification_settings.chatMessageNotificationSettings.Cooldown_woodcutting_ultimate && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("CooldownNotify", this, player.UserIDString), Buff.Woodcutting_Ultimate.ToString().Replace("_", " "), config.ultimate_settings.ultimate_woodcutting.cooldown_between_uses));
                    List<TreeEntity> other_trees = Pool.Get<List<TreeEntity>>();
                    var entities = FindEntitiesOfType<TreeEntity>(dispenser.transform.position, config.ultimate_settings.ultimate_woodcutting.distance_from_player);
                    foreach (var entity in entities)
                    {
                        if (entity.skinID == 0 && (entity.PrefabName.StartsWith("assets/bundled/prefabs/autospawn/resource/v3_", StringComparison.Ordinal) || entity.PrefabName.StartsWith("assets/bundled/prefabs/autospawn/resource/swamp", StringComparison.Ordinal)))
                            other_trees.Add(entity);
                    }
                    Pool.FreeUnmanaged(ref entities);
                    UltimateTriggered = true;
                    foreach (var _dispenser in other_trees)
                    {
                        if (_dispenser == null) continue;
                        if (_dispenser != dispenser && _dispenser.resourceDispenser.gatherType == ResourceDispenser.GatherType.Tree)
                        {
                            HandleTree(player, _dispenser.resourceDispenser);
                        }
                    }
                    UltimateTriggered = false;
                }
            }
            else if (dispenser.gatherType == ResourceDispenser.GatherType.Ore)
            {
                if (heldEntity != null && heldEntity is Jackhammer)
                {
                    gather_modifier = config.tools_black_white_list_settings.power_tool_modifier.mining_yield_modifier;
                    xp_modifier = config.tools_black_white_list_settings.power_tool_modifier.mining_xp_modifier;
                    luck_modifier = config.tools_black_white_list_settings.power_tool_modifier.mining_luck_modifier;
                }

                if (PassWhitelistCheck(player, null, GatherSourceType.MiningFinal) && item.info.shortname != "hq.metal.ore")
                {
                    AwardXP(player, config.xp_settings.xp_sources.NodeHitFinal * xp_modifier, dispenser.baseEntity, false, false, nameof(config.xp_settings.xp_sources.NodeHitFinal));
                }

                if (bd.GetBuff(Buff.Mining_Luck, out var value) && RollSuccessful((value * luck_modifier)) && config.loot_settings.mining_loot_table.Count > 0)
                {
                    var randProfile = RollLootItem(config.loot_settings.mining_loot_table);
                    if (randProfile != null)
                    {
                        var randomitem = CreateDropItem(randProfile);
                        if (randomitem != null)
                        {
                            if (config.notification_settings.chatMessageNotificationSettings.MiningLuck_Proc && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("ItemFound", this, player.UserIDString), randomitem.amount, randomitem.name ?? randomitem.info.displayName.english, "node"), config.misc_settings.ChatID);
                            player.GiveItem(randomitem);
                        }
                    }
                    //if (def != null) player.GiveItem(ItemManager.CreateByName(randomitem.Key, quantity));                    
                }
            }
            // Dispenser bonus doesnt trigger for flesh.
            HandleDispenser(dispenser, player, item, true);
            return null;
        }

        void RespawnTree(BasePlayer player, string prefab, Vector3 pos, Quaternion rot)
        {
            ServerMgr.Instance.Invoke(() =>
            {
                var nodes = FindEntitiesOfType<ResourceEntity>(pos, 2);
                foreach (var node in nodes)
                {
                    if (node.PrefabName != prefab) continue;
                    if (InRange(node.transform.position, pos, 0.1f))
                    {
                        Pool.FreeUnmanaged(ref nodes);
                        return;
                    }
                }
                Pool.FreeUnmanaged(ref nodes);

                var entity = GameManager.server.CreateEntity(prefab, pos, rot);
                entity.Spawn();
                if (player != null && config.notification_settings.chatMessageNotificationSettings.Regrowth_Proc && NotificationsOn(player)) 
                    Player.Message(player, lang.GetMessage("RegrowthProc", this, player.UserIDString), config.misc_settings.ChatID);
            }, 0.1f); 
        }

        enum GatherSourceType
        {
            Woodcutting,
            WoodcuttingFinal,
            Mining,
            MiningFinal,
            Skinning
        }

        bool PassWhitelistCheck(BasePlayer player, Item tool, GatherSourceType type)
        {
            if (!config.xp_settings.white_listed_tools_only) return true;

            if (tool == null) tool = player.GetActiveItem();
            if (tool == null) return true;

            switch (type)
            {
                case GatherSourceType.Woodcutting:
                case GatherSourceType.WoodcuttingFinal:
                    if (config.tools_black_white_list_settings.wc_tools.Count == 0 || config.tools_black_white_list_settings.wc_tools.Contains(tool.info.shortname)) return true;
                    else return false;

                case GatherSourceType.Mining:
                case GatherSourceType.MiningFinal:
                    if (config.tools_black_white_list_settings.mining_tools.Count == 0 || config.tools_black_white_list_settings.mining_tools.Contains(tool.info.shortname)) return true;
                    else return false;

                case GatherSourceType.Skinning:
                    if (config.tools_black_white_list_settings.skinning_tools.Count == 0 || config.tools_black_white_list_settings.skinning_tools.Contains(tool.info.shortname)) return true;
                    else return false;
            }

            return true;
        }

        object OnItemRepair(BasePlayer player, Item item)
        {
            object result = null;
            if (!GetBuffDetails(player.userID, out var bd)) return result;
            if (bd.ContainsBuff(Buff.Free_Repairs))
            {
                var bench = item.parent.GetEntityOwner() as RepairBench;
                if (bench != null)
                {
                    var maxLossFraction = bench.maxConditionLostOnRepair;
                    var component = item.info.GetComponent<ItemModRepair>();
                    if (component != null) maxLossFraction = component.conditionLost;
                    if (item.hasCondition)
                    {
                        if (item.info.condition.maintainMaxCondition)
                        {
                            maxLossFraction = 0f;
                        }

                        float num = 1f - item.condition / item.maxCondition;
                        maxLossFraction = Mathf.Clamp(maxLossFraction, 0f, item.info.condition.max);
                        item.maxCondition *= 1f - maxLossFraction * num;
                        item.condition = item.maxCondition;
                        BaseEntity baseEntity = item.GetHeldEntity();
                        if (baseEntity != null)
                        {
                            baseEntity.SetFlag(BaseEntity.Flags.Broken, b: false);
                        }
                        result = true;
                    }
                }
            }
            NextTick(() =>
            {
                if (item == null || player == null) return;
                if (item.condition != item.maxCondition) return;

                if (bd.ContainsBuff(Buff.MaxRepair) && Interface.CallHook("STOnItemRepairWithMaxRepair", item) == null)
                {
                    if (item != null && item.condition != item.info.condition.max)
                    {
                        item.maxCondition = item.info.condition.max;
                        item.condition = item.maxCondition;
                        item.MarkDirty();
                    }
                }
            });

            return result;
        }

        void OnLoseCondition(Item item, ref float amount)
        {
            var player = item.GetEntityOwner() as BasePlayer;
            if (player == null || player.IsNpc || !player.userID.IsSteamId() || !GetBuffDetails(player.userID, out var bd)) return;

            float amount_to_repair = 0f;
            float value;
            if (bd.GetBuff(Buff.Durability, out value) && !config.buff_settings.durability_blacklist.Contains(item.info.shortname))
                amount_to_repair += (amount * value);

            if (bd.ContainsBuff(Buff.Primitive_Expert) && config.buff_settings.primitive_weapons.Contains(item.info.shortname))
                amount_to_repair = amount;

            else if (bd.GetBuff(Buff.Woodcutting_Tool_Durability, out value) && config.tools_black_white_list_settings.wc_tools.Contains(item.info.shortname))
                amount_to_repair += (value * amount);

            else if (bd.GetBuff(Buff.Mining_Tool_Durability, out value) && config.tools_black_white_list_settings.mining_tools.Contains(item.info.shortname))
                amount_to_repair += (value * amount);

            else if (bd.GetBuff(Buff.Skinning_Tool_Durability, out value) && config.tools_black_white_list_settings.skinning_tools.Contains(item.info.shortname))
                amount_to_repair += (value * amount);

            item.condition += amount_to_repair >= amount ? amount : amount_to_repair;
        }

        void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProtoBuf.ProjectileShoot projectiles)
        {
            BuffDetails bd;
            if (GetBuffDetails(player.userID, out bd))
            {
                if (bd.GetBuff(Buff.Free_Bullet_Chance, out var value) && RollSuccessful(value))
                {
                    var heldEntity = projectile.GetItem();
                    if (heldEntity == null) return;
                    projectile.primaryMagazine.contents++;
                    projectile.SendNetworkUpdateImmediate();
                }
            }
        }

        void CanCatchFish(BasePlayer player, BaseFishingRod fishingRod, Item fish)
        {
            if (player.IsNpc || !player.userID.IsSteamId()) return;
            fish.amount = GetMultipliedItemAmount(fish);

            AwardXP(player, GetFishXP(fish.info.itemid, out var source), null, false, false, source);

            float value;
            BuffDetails bd;
            if (GetBuffDetails(player.userID, out bd) && bd.GetBuff(Buff.Extra_Fish, out value))
            {
                RollExtraFish(player, fish, value);
            }
        }

        double GetFishXP(int itemID, out string source)
        {
            switch (itemID)
            {
                case -587989372: source = nameof(config.xp_settings.xp_sources.FishCaught); return config.xp_settings.xp_sources.FishCaught; // Catfish
                case 342438846: source = nameof(config.xp_settings.xp_sources.CatchAnchovy); return config.xp_settings.xp_sources.CatchAnchovy;
                case -1698937385: source = nameof(config.xp_settings.xp_sources.CatchHerring); return config.xp_settings.xp_sources.CatchHerring;
                case -1904821376: source = nameof(config.xp_settings.xp_sources.CatchOrangeRoughy); return config.xp_settings.xp_sources.CatchOrangeRoughy;
                case -851988960: source = nameof(config.xp_settings.xp_sources.CatchSalmon); return config.xp_settings.xp_sources.CatchSalmon;
                case -1654233406: source = nameof(config.xp_settings.xp_sources.CatchSardine); return config.xp_settings.xp_sources.CatchSardine;
                case -1768880890: source = nameof(config.xp_settings.xp_sources.CatchSmallShark); return config.xp_settings.xp_sources.CatchSmallShark;
                case -1878764039: source = nameof(config.xp_settings.xp_sources.CatchSmallTrout); return config.xp_settings.xp_sources.CatchSmallTrout;
                case 680234026: source = nameof(config.xp_settings.xp_sources.CatchYellowPerch); return config.xp_settings.xp_sources.CatchYellowPerch;
                default: source = nameof(config.xp_settings.xp_sources.CatchTrash); return config.xp_settings.xp_sources.CatchTrash;
            }
        }

        void RollExtraFish(BasePlayer player, Item fish, float value)
        {
            var extraFish = 0;

            for (int i = 1; i < 999; i++)
            {
                if (i < value) extraFish++;
                else break;
            }
            float leftOver = value - extraFish;
            var roll = UnityEngine.Random.Range(0f, 100f);
            if (roll > 100f - (leftOver / 1 * 100))
            {
                extraFish++;
            }
            if (extraFish < 1) return;
            if (config.notification_settings.chatMessageNotificationSettings.Extra_Fish_Proc && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("ExtraFish", this, player.UserIDString), extraFish, fish.info.displayName.english), config.misc_settings.ChatID);
            if (config.buff_settings.additiveYields) fish.amount += extraFish;
            else player.GiveItem(ItemManager.Create(fish.info, extraFish, fish.skin));
        }

        void OnFishCatch(Item item, BaseFishingRod rod, BasePlayer player)
        {
            if (TrackedRods.ContainsKey(rod.net.ID.Value)) ResetRod(rod);

            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd)) return;

            float luck;
            if (!bd.GetBuff(Buff.Fishing_Luck, out luck) || !RollSuccessful(luck)) return;

            var randProfile = RollLootItem(config.loot_settings.fishing_loot_table);
            if (randProfile == null) return;

            var randomitem = CreateDropItem(randProfile);
            if (randomitem != null)
            {
                if (config.notification_settings.chatMessageNotificationSettings.FishingLuck_Proc && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("ItemFound", this, player.UserIDString), randomitem.amount, randomitem.name ?? randomitem.info.displayName.english, item.info.displayName.english), config.misc_settings.ChatID);
                player.GiveItem(randomitem);
            }
        }

        void ApplyRodStrength(BaseFishingRod rod, float modifier)
        {
            rod.GlobalStrainSpeedMultiplier = 1 - modifier;
            TrackedRods.Add(rod.net.ID.Value, rod);
        }

        void ResetRod(BaseFishingRod rod, bool doRemove = true)
        {
            rod.GlobalStrainSpeedMultiplier = 1f;
            if (doRemove) TrackedRods.Remove(rod.net.ID.Value);
        }

        Dictionary<ulong, BaseFishingRod> TrackedRods = new Dictionary<ulong, BaseFishingRod>();
        void OnFishingStopped(BaseFishingRod rod, BaseFishingRod.FailReason failReason)
        {
            if (rod?.net != null && TrackedRods.ContainsKey(rod.net.ID.Value)) ResetRod(rod);
        }

        bool CheckHarvestingBlacklist = false;

        void OnCollectiblePickup(CollectibleEntity entity, BasePlayer player)
        {
            if (player == null || entity == null || player.IsNpc || !player.userID.IsSteamId() || entity.itemList == null) return;

            if (config.base_yield_settings.adjust_base_yield)
            {
                foreach (var item in entity.itemList)
                {
                    item.amount = GetMultipliedItemAmount(item.itemDef.shortname, item.amount);
                }
            }

            AwardXP(player, config.xp_settings.xp_sources.CollectWildPlant, entity, false, false, nameof(config.xp_settings.xp_sources.CollectWildPlant));
            BuffDetails bd;
            float buffValue;
            if (GetBuffDetails(player.userID, out bd) && bd.GetBuff(Buff.Harvest_Wild_Yield, out buffValue))
            {
                if (Interface.CallHook("STCanReceiveYield", player, entity) == null)
                {
                    foreach (var item in entity.itemList)
                    {
                        if (item == null) continue;
                        if (CheckHarvestingBlacklist && config.buff_settings.harvest_yield_blacklist.Contains(item.itemDef.shortname)) continue;
                        //item.amount += Convert.ToInt32(Math.Round((buffValue * item.amount) + (TOD_Sky.Instance.IsNight ? (config.xp_settings.night_settings.night_harvesting_yield_modifier - 1) * item.amount : 0), 0, MidpointRounding.AwayFromZero));
                        var amount = Mathf.RoundToInt((buffValue * item.amount) + (TOD_Sky.Instance.IsNight ? (config.xp_settings.night_settings.night_harvesting_yield_modifier - 1) * item.amount : 0));
                        if (amount >= 1)
                            if (config.buff_settings.additiveYields) item.amount += amount;
                            else player.GiveItem(ItemManager.Create(item.itemDef, amount));
                    }
                }
            }
            else if (Interface.CallHook("STCanReceiveYield", player, entity) == null)
            {
                foreach (var item in entity.itemList)
                {
                    if (item == null) continue;
                    var amount = Convert.ToInt32(Math.Round(TOD_Sky.Instance.IsNight ? (config.xp_settings.night_settings.night_harvesting_yield_modifier - 1) * item.amount : 0, 0, MidpointRounding.AwayFromZero));
                    if (amount >= 1)
                        if (config.buff_settings.additiveYields) item.amount += amount;
                        else player.GiveItem(ItemManager.Create(item.itemDef, amount));
                }
            }
            if (HasAnimalBuff(player, AnimalBuff.Boar) && !string.IsNullOrEmpty(entity.PrefabName) && (entity.PrefabName.StartsWith("assets/content/nature/plants/mushroom/") || entity.PrefabName.StartsWith("assets/bundled/prefabs/autospawn/collectable/"))) RollBoarLoot(player, entity);
            if (bd != null && config.loot_settings.harvesting_loot_table_wild.Count > 0 && bd.GetBuff(Buff.Harvesting_Luck, out buffValue) && RollSuccessful(buffValue) && !config.buff_settings.harvesting_luck_settings.blacklist.Contains(entity.ShortPrefabName))
            {
                var randProfile = RollLootItem(config.loot_settings.harvesting_loot_table_wild);
                if (randProfile != null)
                {
                    var randomitem = CreateDropItem(randProfile);
                    if (randomitem != null)
                    {
                        if (config.notification_settings.chatMessageNotificationSettings.HarvestingLuck_Proc && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("ItemFoundOnly", this, player.UserIDString), randomitem.amount, randomitem.name ?? randomitem.info.displayName.english), config.misc_settings.ChatID);
                        player.GiveItem(randomitem);
                    }
                }
                //if (def != null) player.GiveItem(ItemManager.CreateByName(randomitem.Key, quantity));                    
            }
        }

        Dictionary<ulong, float> Harvester_Ultimate_cooldown = new Dictionary<ulong, float>();

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (go == null) return;
            var player = plan?.GetOwnerPlayer();
            if (player == null) return;
            var entity = go.ToBaseEntity();
            if (entity != null)
            {
                if (entity is BuildingBlock) AwardXP(player, config.xp_settings.xp_sources.BuildingBlockDeployed, entity, false, false, nameof(config.xp_settings.xp_sources.BuildingBlockDeployed));
            }

            GrowableEntity plant = go.GetComponent<GrowableEntity>();
            if (plant != null)
            {
                BuffDetails bd;
                PlayerInfo pi;
                var item = plan.GetItem();
                if ((item == null || item.info.shortname != "clone.hemp") && GetBuffDetails(player.userID, out bd) && bd.ContainsBuff(Buff.Harvester_Ultimate) && IsUltimateEnabled(player, Buff.Harvester_Ultimate) && pcdData.pEntity.TryGetValue(player.userID, out pi) && !config.ultimate_settings.ultimate_harvesting.blacklist.Contains(item.info.shortname))
                {
                    if (config.ultimate_settings.ultimate_harvesting.cooldown > 0)
                    {
                        float cd;
                        if (!Harvester_Ultimate_cooldown.TryGetValue(player.userID, out cd))
                        {
                            Harvester_Ultimate_cooldown.Add(player.userID, Time.time + config.ultimate_settings.ultimate_harvesting.cooldown);
                            if (config.ultimate_settings.ultimate_harvesting.notify_on_cooldown) Player.Message(player, string.Format(lang.GetMessage("HarvestUltiCDNotification", this, player.UserIDString), config.ultimate_settings.ultimate_harvesting.cooldown), config.misc_settings.ChatID);
                        }

                        else
                        {
                            if (Time.time < cd) return;
                            else
                            {
                                Harvester_Ultimate_cooldown[player.userID] = Time.time + config.ultimate_settings.ultimate_harvesting.cooldown;
                                if (config.ultimate_settings.ultimate_harvesting.notify_on_cooldown) Player.Message(player, string.Format(lang.GetMessage("HarvestUltiCDNotification", this, player.UserIDString), config.ultimate_settings.ultimate_harvesting.cooldown), config.misc_settings.ChatID);
                            }
                        }
                    }
                    var genes = plant.Genes.Genes;
                    for (int i = 0; i < pi.plant_genes.Length; i++)
                    {
                        switch (pi.plant_genes[i])
                        {
                            case 'g':
                                genes[i].Set(GrowableGenetics.GeneType.GrowthSpeed);
                                genes[i].SetPrevious(GrowableGenetics.GeneType.GrowthSpeed);
                                break;

                            case 'e':
                                genes[i].Set(GrowableGenetics.GeneType.Empty);
                                genes[i].SetPrevious(GrowableGenetics.GeneType.Empty);
                                break;

                            case 'x':
                                genes[i].Set(GrowableGenetics.GeneType.Empty);
                                genes[i].SetPrevious(GrowableGenetics.GeneType.Empty);
                                break;

                            case 'w':
                                genes[i].Set(GrowableGenetics.GeneType.WaterRequirement);
                                genes[i].SetPrevious(GrowableGenetics.GeneType.WaterRequirement);
                                break;

                            case 'y':
                                genes[i].Set(GrowableGenetics.GeneType.Yield);
                                genes[i].SetPrevious(GrowableGenetics.GeneType.Yield);
                                break;

                            case 'h':
                                genes[i].Set(GrowableGenetics.GeneType.Hardiness);
                                genes[i].SetPrevious(GrowableGenetics.GeneType.Hardiness);
                                break;

                            default:
                                genes[i].Set(GrowableGenetics.GeneType.GrowthSpeed);
                                genes[i].SetPrevious(GrowableGenetics.GeneType.GrowthSpeed);
                                break;
                        }
                    }
                    plant.SendNetworkUpdateImmediate();
                }
            }
        }

        void OnItemCraftFinished(ItemCraftTask task, Item item, ItemCrafter crafter)
        {
            if (crafter == null) return;
            var player = crafter.owner;
            if (player == null) return;

            if (task.blueprint == null)
            {
                return;
            }

            if (!ExcludeFromCraftXP(item.info.shortname))
            {
                var experienceGain = CraftTimes.ContainsKey(task.taskUID) && config.buff_settings.timeBasedCraftingXP ? Math.Round(CraftTimes[task.taskUID] * config.xp_settings.xp_sources.Crafting, 2) : Math.Round((item.info.Blueprint.time + 0.99f) * config.xp_settings.xp_sources.Crafting, 2);
                AwardXP(player, experienceGain, null, false, false, nameof(config.xp_settings.xp_sources.Crafting));
            }
            BuffDetails bd;
            if (GetBuffDetails(player.userID, out bd))
            {
                float value;
                if (bd.GetBuff(Buff.Craft_Refund, out value) && RollSuccessful(value))
                {
                    var refunded = 0;
                    ItemBlueprint bp;
                    if (item_BPs.TryGetValue(item.info.shortname, out bp))
                    {
                        foreach (var component in bp.ingredients)
                        {
                            if (config.tools_black_white_list_settings.craft_refund_blacklist.Contains(component.itemDef.shortname)) continue;
                            var nitem = ItemManager.CreateByName(component.itemDef.shortname, Convert.ToInt32(component.amount));
                            if (nitem == null) continue;
                            if (!player.inventory.containerBelt.IsFull() || !player.inventory.containerMain.IsFull())
                            {
                                GiveItem(player, nitem);
                                //player.inventory.GiveItem(nitem);
                            }
                            else nitem.DropAndTossUpwards(player.transform.position);
                            refunded++;
                        }
                        if (refunded > 0 && config.notification_settings.chatMessageNotificationSettings.Craft_Refund_Proc && NotificationsOn(player)) Player.Message(player, lang.GetMessage("CraftRefund", this, player.UserIDString), config.misc_settings.ChatID);
                    }
                }
                if (bd.GetBuff(Buff.Craft_Duplicate, out value) && RollSuccessful(value) && !config.tools_black_white_list_settings.craft_duplicate_blacklist.Contains(item.info.shortname))
                {
                    var ditem = ItemManager.CreateByName(item.info.shortname, item.amount, item.skin);
                    if (ditem != null)
                    {
                        if (item.info.TryGetComponent<ItemModContainerArmorSlot>(out var modRef) && ditem.info.TryGetComponent<ItemModContainerArmorSlot>(out var modNew)) 
                            modNew.CreateAtCapacity(modRef.capacity, ditem); 

                        if (config.notification_settings.chatMessageNotificationSettings.Craft_Duplicate_Proc && NotificationsOn(player)) 
                            Player.Message(player, string.Format(lang.GetMessage("DuplicateProc", this, player.UserIDString), item.info.displayName.english), config.misc_settings.ChatID);
                        player.GiveItem(ditem);
                    }
                }
            }

            if (task.amount > 0)
            {
                if (CraftTimes.ContainsKey(task.taskUID)) CraftTimes[task.taskUID] = GetModifiedTime(player, task);
                return;
            }

            CraftTimes.Remove(task.taskUID);

            if (task.blueprint != null && task.blueprint.name.Contains("(Clone)"))
            {
                var behaviours = task.blueprint.GetComponents<MonoBehaviour>();
                foreach (var behaviour in behaviours)
                {
                    if (behaviour.name.Contains("(Clone)")) UnityEngine.Object.Destroy(behaviour);
                }
            }
        }

        object OnItemCraft(ItemCraftTask task, BasePlayer player, Item fromTempBlueprint)
        {
            if (GetBuffDetails(player.userID, out var bd))
            {
                if (bd.GetBuff(Buff.Craft_Speed, out var value))
                {
                    var craftingTime = task.blueprint.time;
                    var reducedTime = craftingTime - (craftingTime * value);
                    if (reducedTime <= 0) reducedTime = 0.0f;
                    if (!task.blueprint.name.Contains("(Clone)"))
                        task.blueprint = UnityEngine.Object.Instantiate(task.blueprint);
                    task.blueprint.time = reducedTime;

                }
                if (!CraftTimes.ContainsKey(task.taskUID)) CraftTimes.Add(task.taskUID, GetModifiedTime(player, task));
            }

            return null;
        }

        void OnItemCraftCancelled(ItemCraftTask task)
        {
            if (task == null) return;
            CraftTimes.Remove(task.taskUID);
        }

        bool ExcludeFromCraftXP(string shortname)
        {
            if (config.xp_settings.craft_xp_whitelist != null && config.xp_settings.craft_xp_whitelist.Count > 0)
            {
                if (config.xp_settings.craft_xp_whitelist.Contains(shortname)) return false;
                return true;
            }
            if (config.xp_settings.craft_xp_blacklist != null && config.xp_settings.craft_xp_blacklist.Contains(shortname)) return true;
            return false;
        }

        Dictionary<int, float> CraftTimes = new Dictionary<int, float>();


        float GetModifiedTime(BasePlayer player, ItemCraftTask task)
        {
            var workbenchLevel = player.currentCraftLevel;

            if (workbenchLevel == 0) return task.blueprint.time;
            var diff = workbenchLevel - task.blueprint.workbenchLevelRequired;
            if (diff < 0.5) return task.blueprint.time;
            else if (diff < 1.5) return task.blueprint.time / 2;
            else return task.blueprint.time / 4;
        }

        void OnGrowableGathered(GrowableEntity plant, Item item, BasePlayer player)
        {
            item.amount = GetMultipliedItemAmount(item);

            if (player.IsNpc || !player.userID.IsSteamId()) return;
            GetBuffDetails(player.userID, out var bd);
            if (!item.info.shortname.Contains("seed") && (!config.xp_settings.ripe_required || plant.State == PlantProperties.State.Ripe))
            {
                HandleGrownHarvestingLuck(plant, item, player, bd);
                AwardXP(player, config.xp_settings.xp_sources.CollectGrownPlant, plant, false, false, nameof(config.xp_settings.xp_sources.CollectGrownPlant));
            }

            if (bd != null && bd.GetBuff(Buff.Harvest_Grown_Yield, out var value) && Interface.CallHook("STCanReceiveYield", player, plant, item) == null)
            {
                var amount = Convert.ToInt32(Math.Round(value * item.amount + (TOD_Sky.Instance.IsNight && config.xp_settings.night_settings.include_grown_harvesting ? (config.xp_settings.night_settings.night_harvesting_yield_modifier - 1) * item.amount : 0), 0, MidpointRounding.AwayFromZero));
                if (amount < 1) return;

                if (config.buff_settings.additiveYields) item.amount += amount;
                else player.GiveItem(ItemManager.Create(item.info, amount, item.skin));
            }
            else
            {
                var amount = Convert.ToInt32(Math.Round(TOD_Sky.Instance.IsNight && config.xp_settings.night_settings.include_grown_harvesting ? (config.xp_settings.night_settings.night_harvesting_yield_modifier - 1) * item.amount : 0, 0, MidpointRounding.AwayFromZero));
                if (amount < 1) return;

                if (config.buff_settings.additiveYields) item.amount += amount;
                else player.GiveItem(ItemManager.Create(item.info, amount, item.skin));
            }
        }

        void HandleGrownHarvestingLuck(GrowableEntity plant, Item item, BasePlayer player, BuffDetails bd)
        {
            if (!config.buff_settings.harvesting_luck_settings.Harvesting_luck_works_with_grown || config.buff_settings.harvesting_luck_settings.blacklist.Contains(plant.ShortPrefabName)) return;
            if (bd == null || config.loot_settings.harvesting_loot_table_grown.Count == 0 || !bd.GetBuff(Buff.Harvesting_Luck, out var value) || !RollSuccessful(value)) return;
            var randProfile = RollLootItem(config.loot_settings.harvesting_loot_table_grown);
            if (randProfile == null) return;
            var randomitem = CreateDropItem(randProfile);
            if (randomitem == null) return;
            if (config.notification_settings.chatMessageNotificationSettings.HarvestingLuck_Proc && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("ItemFoundOnly", this, player.UserIDString), randomitem.amount, randomitem.name ?? randomitem.info.displayName.english), config.misc_settings.ChatID);
            player.GiveItem(randomitem);
        }

        public static bool ContainsTopology(TerrainTopology.Enum mask, Vector3 position)
        {
            return (TerrainMeta.TopologyMap.GetTopology(position, (int)mask));
        }

        public bool IsUnderwater(BasePlayer player)
        {
            return player.WaterFactor() == 1f || ContainsTopology(TerrainTopology.Enum.Monument, player.transform.position) && ContainsTopology(TerrainTopology.Enum.Ocean, player.transform.position);
        }

        bool IsEntityUnderwater(BaseEntity entity)
        {
            return entity.WaterFactor() == 1f;
        }

        bool IsTrap(BaseEntity entity)
        {
            switch (entity?.ShortPrefabName)
            {
                case "flameturret.deployed":
                case "autoturret_deployed":
                case "spikes.floor":
                case "teslacoil.deployed":
                case "beartrap":
                case "landmine":
                case "guntrap.deployed":
                    return true;

                default: return false;
            }
        }

        bool RaidableBasesLoaded() => RaidableBases != null && RaidableBases.IsLoaded;

        bool PassRaidableBasesCheck(BaseEntity entity, Buff buff)
        {
            if (!RaidableBasesLoaded()) return config.buff_settings.raid_perk_settings.default_pass;
            switch (buff)
            {
                case Buff.Trap_Damage_Reduction:
                    if (!config.buff_settings.raid_perk_settings.trap_damage_reduction_settings.raidable_bases_only) return true;
                    break;

                case Buff.Trap_Damage_Increase:
                    if (!config.buff_settings.raid_perk_settings.trap_damage_increase_settings.raidable_bases_only) return true;
                    break;

                case Buff.Explosion_Radius:
                    if (!config.buff_settings.raid_perk_settings.Explosion_Radius_settings.raidable_bases_only) return true;
                    return Convert.ToBoolean(RaidableBases.Call("EventTerritory", entity.transform.position));

                case Buff.Double_Explosion_Chance:
                    if (!config.buff_settings.raid_perk_settings.Double_Explosion_chance_settings.raidable_bases_only) return true;
                    return Convert.ToBoolean(RaidableBases.Call("EventTerritory", entity.transform.position));

                case Buff.Lock_Picker:
                    if (!config.buff_settings.raid_perk_settings.Lock_Picker_settings.raidable_bases_only) return true;
                    break;

                case Buff.Dudless_Explosive:
                    if (!config.buff_settings.raid_perk_settings.Dudless_Explosiv_settings.raidable_bases_only) return true;
                    return Convert.ToBoolean(RaidableBases.Call("EventTerritory", entity.transform.position));

                case Buff.Trap_Spotter:
                    if (!config.buff_settings.raid_perk_settings.Trap_Spotter_settings.raidable_bases_only) return true;
                    return Convert.ToBoolean(RaidableBases.Call("EventTerritory", entity.transform.position));

                case Buff.Loot_Spotter:
                    if (!config.buff_settings.raid_perk_settings.Loot_Spotter_settings.raidable_bases_only) return true;
                    return Convert.ToBoolean(RaidableBases.Call("EventTerritory", entity.transform.position));
            }
            return Convert.ToBoolean(RaidableBases.Call("HasEventEntity", entity));
        }

        bool PassRaidableBasesCheck(Vector3 pos, Buff buff)
        {
            if (!RaidableBasesLoaded()) return true;
            switch (buff)
            {
                case Buff.Raiding_Ultimate:
                    if (config.ultimate_settings.ultimate_raiding.raidable_bases_mode_blacklist.Count > 0)
                    {
                        if (!PassRaidModeBlacklistCheck(pos)) return false;                        
                    }
                    if (!config.ultimate_settings.ultimate_raiding.raidable_bases_only) return true;
                    return Convert.ToBoolean(RaidableBases.Call("EventTerritory", pos));

                default: return true;
            }
        }

        bool PassRaidModeBlacklistCheck(Vector3 pos)
        {
            var Raids = RaidableBases.Call("GetAllEvents", pos) as List<(Vector3 pos, string mode, int level, bool allowPVP, string a, float b, float c, float loadTime, ulong ownerId, BasePlayer owner, List<BasePlayer> raiders, List<BasePlayer> intruders, HashSet<BaseEntity> entities, string baseName, DateTime spawnDateTime, DateTime despawnDateTime, float radius, int lootRemaining)>;
            if (Raids == null) return true;
            foreach (var raid in Raids)
            {
                if (!InRange(pos, raid.pos, raid.radius)) continue;
                if (config.ultimate_settings.ultimate_raiding.raidable_bases_mode_blacklist.Contains(raid.mode)) return false;
            }
            return true;
        }

        void HandleBearBuff(BasePlayer player, HitInfo info, Rust.DamageType damageType)
        {
            if (HasAnimalBuff(player, AnimalBuff.PolarBear) && OverShields.ContainsKey(player))
            {
                var shield_value = OverShields[player];
                var total_Damage = info.damageTypes.Total();
                if (shield_value <= 0) RemoveAnimalBuff(player);
                else if (total_Damage <= shield_value)
                {
                    OverShields[player] = shield_value - total_Damage;
                    info.damageTypes.ScaleAll(0f);
                    Overshield_main(player, shield_value - total_Damage);
                }
                else
                {
                    var excess_damage = total_Damage - shield_value;
                    Unsubscribe("OnEntityTakeDamage");
                    player.Hurt(excess_damage, damageType);
                    Subscribe("OnEntityTakeDamage");
                    info.damageTypes.ScaleAll(0f);
                    RemoveAnimalBuff(player);
                }
            }
        }

        Dictionary<ulong, RecyclerEfficiency> ModifiedRecyclers = new Dictionary<ulong, RecyclerEfficiency>();
        public class RecyclerEfficiency
        {
            public Recycler recycler;
            public float radtownRecycleEfficiency;
            public float safezoneRecycleEfficiency;
            public RecyclerEfficiency(float radtownRecycleEfficiency, float safezoneRecycleEfficiency, Recycler recycler)
            {
                this.safezoneRecycleEfficiency = safezoneRecycleEfficiency;
                this.radtownRecycleEfficiency = radtownRecycleEfficiency;
                this.recycler = recycler;
            }
        }

        public void ResetRecyclerEfficiency(ulong id, RecyclerEfficiency data = null, bool remove = false)
        {
            if (data == null && !ModifiedRecyclers.TryGetValue(id, out data)) return;
            if (data.recycler != null)
            {
                data.recycler.radtownRecycleEfficiency = data.radtownRecycleEfficiency;
                data.recycler.safezoneRecycleEfficiency = data.safezoneRecycleEfficiency;
            }
            if (remove)
            {
                ModifiedRecyclers.Remove(id);
            }
        }

        private void OnRecyclerToggle(Recycler recycler, BasePlayer player)
        {
            if (recycler.IsOn()) return;
            if (Convert.ToBoolean(VirtualRecycler?.Call("IsVirtualRecycler", recycler))) return;
            if (!GetBuffDetails(player.userID, out var bd)) return;

            if (bd.GetBuff(Buff.Recycler_Efficiency, out var value))
            {
                if (ModifiedRecyclers.TryGetValue(recycler.net.ID.Value, out var existingData))
                {
                    ResetRecyclerEfficiency(recycler.net.ID.Value, existingData, true);
                }
                ModifiedRecyclers.Add(recycler.net.ID.Value, new RecyclerEfficiency(recycler.radtownRecycleEfficiency, recycler.safezoneRecycleEfficiency, recycler));

                recycler.radtownRecycleEfficiency += recycler.radtownRecycleEfficiency * value;
                recycler.safezoneRecycleEfficiency += recycler.safezoneRecycleEfficiency * value;

                recycler.SendNetworkUpdate();
                if (config.notification_settings.chatMessageNotificationSettings.Recycler_Efficiency_Proc && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("SetRecyclerEfficiency", this, player.UserIDString), (recycler.IsSafezoneRecycler() ? recycler.safezoneRecycleEfficiency : recycler.radtownRecycleEfficiency) * 100), config.misc_settings.ChatID);
            }
            if (bd.GetBuff(Buff.Recycler_Speed, out var speedDecrease))
            {
                recycler.CancelInvoke(nameof(recycler.RecycleThink));
                var recycler_speed = recycler.GetRecycleThinkDuration() - speedDecrease;
                if (recycler_speed <= 0.1) recycler_speed = 0.1f;
                ServerMgr.Instance.Invoke(() => recycler.InvokeRepeating(recycler.RecycleThink, recycler_speed - 0.1f, recycler_speed), 0.1f);
            }
        }

        List<ulong> looted_crates = new List<ulong>();
        void OnLootEntity(BasePlayer player, LootContainer entity)
        {
            switch (entity.ShortPrefabName)
            {
                case "codelockedhackablecrate_oilrig":
                case "codelockedhackablecrate":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.LootHackedCrate, entity, false, false, nameof(config.xp_settings.xp_sources.LootHackedCrate));
                    }
                    break;
                case "heli_crate":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.LootHeliCrate, entity, false, false, nameof(config.xp_settings.xp_sources.LootHeliCrate));
                    }
                    break;
                case "bradley_crate":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.LootBradleyCrate, entity, false, false, nameof(config.xp_settings.xp_sources.LootBradleyCrate));
                    }
                    break;
                case "crate_basic":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_basic, entity, false, false, nameof(config.xp_settings.xp_sources.crate_basic));
                    }
                    break;
                case "crate_elite":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_elite, entity, false, false, nameof(config.xp_settings.xp_sources.crate_elite));
                    }
                    break;
                case "crate_mine":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_mine, entity, false, false, nameof(config.xp_settings.xp_sources.crate_mine));
                    }
                    break;
                case "crate_normal":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_normal, entity, false, false, nameof(config.xp_settings.xp_sources.crate_normal));
                    }
                    break;
                case "crate_normal_2":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_normal_2, entity, false, false, nameof(config.xp_settings.xp_sources.crate_normal_2));
                    }
                    break;
                case "crate_normal_2_food":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_normal_2_food, entity, false, false, nameof(config.xp_settings.xp_sources.crate_normal_2_food));
                    }
                    break;
                case "crate_normal_2_medical":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_normal_2_medical, entity, false, false, nameof(config.xp_settings.xp_sources.crate_normal_2_medical));
                    }
                    break;
                case "crate_tools":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_tools, entity, false, false, nameof(config.xp_settings.xp_sources.crate_tools));
                    }
                    break;
                case "crate_underwater_advanced":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_underwater_advanced, entity, false, false, nameof(config.xp_settings.xp_sources.crate_underwater_advanced));
                    }
                    break;
                case "crate_underwater_basic":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_underwater_basic, entity, false, false, nameof(config.xp_settings.xp_sources.crate_underwater_basic));
                    }
                    break;
                case "crate_ammunition":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_ammunition, entity, false, false, nameof(config.xp_settings.xp_sources.crate_ammunition));
                    }
                    break;
                case "crate_food_1":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_food_1, entity, false, false, nameof(config.xp_settings.xp_sources.crate_food_1));
                    }
                    break;
                case "crate_food_2":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_food_2, entity, false, false, nameof(config.xp_settings.xp_sources.crate_food_2));
                    }
                    break;
                case "crate_fuel":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_fuel, entity, false, false, nameof(config.xp_settings.xp_sources.crate_fuel));
                    }
                    break;
                case "crate_medical":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_medical, entity, false, false, nameof(config.xp_settings.xp_sources.crate_medical));
                    }
                    break;

                case "trash-pile-1":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_food_1, entity, false, false, nameof(config.xp_settings.xp_sources.crate_food_1));
                    }
                    break;
                case "supply_drop":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.supply_drop, entity, false, false, nameof(config.xp_settings.xp_sources.supply_drop));
                    }
                    break;
                case "vehicle_parts":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_basic, entity, false, false, nameof(config.xp_settings.xp_sources.crate_basic));
                    }
                    break;
                case "minecart":
                    if (!looted_crates.Contains(entity.net.ID.Value))
                    {
                        looted_crates.Add(entity.net.ID.Value);
                        AwardXP(player, config.xp_settings.xp_sources.crate_normal, entity, false, false, nameof(config.xp_settings.xp_sources.crate_normal));
                    }
                    break;
            }
        }

        [HookMethod("RolledLootPickup")]
        public bool RolledLootPickup(BasePlayer player)
        {
            BuffDetails bd;
            if (GetBuffDetails(player.userID, out bd))
            {
                float value;
                if (bd.GetBuff(Buff.Loot_Pickup, out value) && (value >= 1f || RollSuccessful(value))) return true;
            }
            return false;
        }

        Dictionary<BasePlayer, bool> LastMagnetSuccess = new Dictionary<BasePlayer, bool>();

        void OnBonusItemDropped(Item item, BasePlayer player)
        {
            BuffDetails bd;
            bool result;
            if (LastMagnetSuccess.TryGetValue(player, out result) && result && GetBuffDetails(player.userID, out bd) && bd.ContainsBuff(Buff.Loot_Pickup))
            {
                GiveItem(player, item);
            }

        }

        bool IsBarrel(string shortname, bool isBarrelSmasher = false)
        {
            switch (shortname)
            {
                case "loot-barrel-1": return true;
                case "loot-barrel-2": return true;
                case "loot_barrel_1": return true;
                case "loot_barrel_2": return true;
                case "oil_barrel": return true;
                case "roadsign1":
                case "roadsign2":
                case "roadsign3":
                case "roadsign4":
                case "roadsign5":
                case "roadsign6":
                case "roadsign7":
                case "roadsign8":
                case "roadsign9":
                    return isBarrelSmasher && config.buff_settings.allow_roadsigns_smasher;
                default: return false;
            }
        }

        void HandleLootPickup(BasePlayer player, LootContainer entity)
        {
            BuffDetails bd;
            if (GetBuffDetails(player.userID, out bd) && bd.GetBuff(Buff.Loot_Pickup, out var value) && entity.inventory?.itemList != null && entity.inventory.itemList.Count > 0)
            {
                if (!LastMagnetSuccess.ContainsKey(player)) LastMagnetSuccess.Add(player, false);

                if (RollSuccessful(value))
                {
                    if (config.buff_settings.loot_pickup_buff_max_distance > 0 && Vector3.Distance(entity.transform.position, player.transform.position) > config.buff_settings.loot_pickup_buff_max_distance)
                    {
                        LastMagnetSuccess[player] = false;
                        return;
                    }

                    List<Item> item_drops = Pool.Get<List<Item>>();
                    if (!config.buff_settings.lootPickupBuffMeleeOnly || (player.GetHeldEntity() != null && player.GetHeldEntity() is BaseMelee))
                    {
                        item_drops.AddRange(entity.inventory.itemList);

                        BasePlayer _player = player;
                        NextTick(() =>
                        {
                            try
                            {
                                if (_player == null)
                                {
                                    Pool.FreeUnmanaged(ref item_drops);
                                    return;
                                }
                                foreach (var item in item_drops)
                                {
                                    if (item == null) continue;
                                    var parent = item.GetOwnerPlayer();
                                    if (parent == null)
                                    {
                                        GiveItem(_player, item);
                                    }
                                }
                                LastMagnetSuccess[player] = false;
                            }
                            finally
                            {
                                Pool.FreeUnmanaged(ref item_drops);
                            }
                        });
                    }
                    LastMagnetSuccess[player] = true;
                }
                else LastMagnetSuccess[player] = false;
            }
        }

        public Vector3 GetPositionInLookDirection(Vector3 playerPosition, Vector3 playerForward)
        {
            if (config.buff_settings.Node_Spawn_Chance_dist == 0) return playerPosition;
            Vector3 offset = playerForward.normalized * config.buff_settings.Node_Spawn_Chance_dist;
            Vector3 targetPosition = playerPosition + offset;

            return new Vector3(targetPosition.x, TerrainMeta.HeightMap.GetHeight(targetPosition), targetPosition.z);
        }

        void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            if (entity == null || info == null || entity.IsDestroyed) return;
            var player = info.InitiatorPlayer;
            if (player == null || player.IsNpc || !player.userID.IsSteamId()) return;
            BuffDetails bd;
            switch (entity.ShortPrefabName)
            {
                case "sulfur-ore":
                case "metal-ore":
                case "stone-ore":
                    float value;
                    if (GetBuffDetails(player.userID, out bd))
                    {
                        var heldEntity = player.GetHeldEntity();
                        if (bd.GetBuff(Buff.Node_Spawn_Chance, out value) && RollSuccessful(value * (heldEntity != null && heldEntity is Jackhammer ? config.tools_black_white_list_settings.power_tool_modifier.mining_luck_modifier : 1f)))
                        {
                            Vector3 pos = GetPositionInLookDirection(entity.transform.position, player.eyes.MovementForward());
                            string prefab = entity.PrefabName;
                            Quaternion rot = entity.transform.rotation;
                            ulong oldID = entity.net.ID.Value;

                            NextTick(() =>
                            {
                                var nodes = FindEntitiesOfType<OreResourceEntity>(pos, 2);
                                foreach (var node in nodes)
                                {
                                    if (node.PrefabName != prefab || node.net.ID.Value == oldID) continue;
                                    if (InRange(node.transform.position, pos, 0.1f))
                                    {
                                        Pool.FreeUnmanaged(ref nodes);
                                        return;
                                    }
                                }
                                Pool.FreeUnmanaged(ref nodes);

                                var newNode = GameManager.server.CreateEntity(prefab, pos, rot);
                                newNode.Spawn();
                                if (player != null && config.notification_settings.chatMessageNotificationSettings.Node_Respawn_Proc && NotificationsOn(player)) Player.Message(player, lang.GetMessage("NodeSpawned", this, player.UserIDString), config.misc_settings.ChatID);
                            });
                        }
                    }
                    break;
                case "loot-barrel-1":
                case "loot-barrel-2":
                case "loot_barrel_1":
                case "loot_barrel_2":
                    AwardXP(player, config.xp_settings.xp_sources.Barrel, entity, false, false, nameof(config.xp_settings.xp_sources.Barrel));
                    HandleLootPickup(player, (LootContainer)entity);
                    break;
                case "roadsign1":
                case "roadsign2":
                case "roadsign3":
                case "roadsign4":
                case "roadsign5":
                case "roadsign6":
                case "roadsign7":
                case "roadsign8":
                case "roadsign9":
                    AwardXP(player, config.xp_settings.xp_sources.RoadSign, entity, false, false, nameof(config.xp_settings.xp_sources.RoadSign));
                    if (config.buff_settings.allow_roadsigns_magnet) HandleLootPickup(player, (LootContainer)entity);
                    break;
                case "oil_barrel":
                    AwardXP(player, config.xp_settings.xp_sources.Barrel, entity, false, false, nameof(config.xp_settings.xp_sources.Barrel));
                    HandleLootPickup(player, (LootContainer)entity);
                    break;
                case "chicken":
                    AwardXP(player, config.xp_settings.xp_sources.SmallAnimal, entity as Chicken, false, false, nameof(config.xp_settings.xp_sources.SmallAnimal));
                    AddAnimalBuff(player, AnimalBuff.Chicken);
                    break;
                case "snake.entity":
                    AwardXP(player, config.xp_settings.xp_sources.SmallAnimal, entity as SnakeHazard, false, false, nameof(config.xp_settings.xp_sources.SmallAnimal));
                    break;
                case "boar":
                    AwardXP(player, config.xp_settings.xp_sources.MediumAnimal, entity as Boar, false, false, nameof(config.xp_settings.xp_sources.MediumAnimal));
                    AddAnimalBuff(player, AnimalBuff.Boar);
                    break;
                case "stag":
                    AwardXP(player, config.xp_settings.xp_sources.MediumAnimal, entity as Stag, false, false, nameof(config.xp_settings.xp_sources.MediumAnimal));
                    AddAnimalBuff(player, AnimalBuff.Stag);
                    break;
                case "wolf":
                    AwardXP(player, config.xp_settings.xp_sources.MediumAnimal, entity as Wolf, false, false, nameof(config.xp_settings.xp_sources.MediumAnimal));
                    AddAnimalBuff(player, AnimalBuff.Wolf);
                    break;
                case "wolf2":
                    AwardXP(player, config.xp_settings.xp_sources.MediumAnimal, entity as Wolf2, false, false, nameof(config.xp_settings.xp_sources.MediumAnimal));
                    AddAnimalBuff(player, AnimalBuff.Wolf);
                    break;
                case "tiger":
                    AwardXP(player, config.xp_settings.xp_sources.LargeAnimal, entity as Tiger, false, false, nameof(config.xp_settings.xp_sources.LargeAnimal));
                    break;
                case "panther":
                    AwardXP(player, config.xp_settings.xp_sources.LargeAnimal, entity as Panther, false, false, nameof(config.xp_settings.xp_sources.LargeAnimal));
                    break;
                case "crocodile":
                    AwardXP(player, config.xp_settings.xp_sources.LargeAnimal, entity as Crocodile, false, false, nameof(config.xp_settings.xp_sources.LargeAnimal));
                    break;
                case "simpleshark":
                    AwardXP(player, config.xp_settings.xp_sources.LargeAnimal, entity as SimpleShark, false, false, nameof(config.xp_settings.xp_sources.LargeAnimal));
                    break;
                case "bear":
                    AwardXP(player, config.xp_settings.xp_sources.LargeAnimal, entity as Bear, false, false, nameof(config.xp_settings.xp_sources.LargeAnimal));
                    AddAnimalBuff(player, AnimalBuff.Bear);
                    break;
                case "polarbear":
                    AwardXP(player, config.xp_settings.xp_sources.LargeAnimal, entity, false, false, nameof(config.xp_settings.xp_sources.LargeAnimal));
                    AddAnimalBuff(player, AnimalBuff.PolarBear);
                    break;
                case "horse":
                case "ridablehorse":
                    AwardXP(player, config.xp_settings.xp_sources.LargeAnimal, entity, false, false, nameof(config.xp_settings.xp_sources.LargeAnimal));
                    break;
                case "bradleyapc":
                    if (config.xp_settings.UseLootDefender && LootDefender != null && LootDefender.IsLoaded) return;
                    AwardXP(player, config.xp_settings.xp_sources.BradleyAPC, entity, false, false, nameof(config.xp_settings.xp_sources.BradleyAPC));
                    break;

                case "autoturret_deployed":
                    AwardXP(player, config.xp_settings.xp_sources.AutoTurret, entity, false, false, nameof(config.xp_settings.xp_sources.AutoTurret));
                    break;
            }
        }

        private static bool InRange(Vector3 a, Vector3 b, float distance)
        {
            return (a - b).sqrMagnitude <= distance * distance;
        }

        void AddItemsToBarrel(Item item, LootContainer entity)
        {
            if (item == null) return;
            if (entity == null || entity.inventory == null)
            {
                item.Remove();
                return;
            }
            entity.inventory.capacity++;
            if (!item.MoveToContainer(entity.inventory)) item.DropAndTossUpwards(entity.transform.position);
        }

        bool HandlingCookingUltimate = false;
        object OnPlayerAddModifiers(BasePlayer player, Item item, ItemModConsumable consumable)
        {
            if (HandlingCookingUltimate) return null;
            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - OnPlayerAddModifiers. [Online = {player.IsConnected}]", this, true);
                return null;
            }

            float value;
            if (bd.GetBuff(Buff.Extra_Food_Water, out value))
            {
                var gain = consumable.GetIfType(MetabolismAttribute.Type.Calories);
                if (gain > 0) player.metabolism.calories.value += value * gain;
                gain = consumable.GetIfType(MetabolismAttribute.Type.Hydration);
                if (gain > 0) player.metabolism.hydration.value += value * gain;
            }
            if (bd.ContainsBuff(Buff.Iron_Stomach))
            {
                if (consumable.GetIfType(MetabolismAttribute.Type.Poison) > 0)
                {
                    player.metabolism.poison.SetValue(player.metabolism.FindAttribute(MetabolismAttribute.Type.Poison).lastValue);
                    if (config.notification_settings.chatMessageNotificationSettings.Iron_Stomach_Proc && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("IronTummy", this, player.UserIDString), item?.info.displayName.english), config.misc_settings.ChatID);
                }
            }

            if (bd.GetBuff(Buff.Metabolism_Share, out value)) HandleMetabolismSharing(player, consumable, value);
            if (item != null)
            {
                if (bd.GetBuff(Buff.Tea_Share, out value) && item.info.shortname.Contains("tea")) HandleTeaSharing(player, item, consumable, value);
                if (bd.GetBuff(Buff.Rationer, out value)) HandleRationer(player, item, value);

                if (bd.GetBuff(Buff.Extended_Tea_Duration, out value) && item.info.shortname.Contains("tea"))
                {
                    string messageString = lang.GetMessage("ExtendedTeaDurationMessage", this, player.UserIDString);

                    List<ModifierDefintion> mods = Pool.Get<List<ModifierDefintion>>();
                    foreach (var mod in consumable.modifiers)
                    {
                        var defaultDuration = GetTeaDuration(item.info.shortname);
                        var modifiedDuration = defaultDuration + (defaultDuration * value);
                        mods.Add(new ModifierDefintion
                        {
                            source = Modifier.ModifierSource.Tea,
                            type = mod.type,
                            duration = modifiedDuration,
                            value = mod.value
                        });
                        messageString += string.Format(lang.GetMessage("ExtendedTeaDurationMessageBody", this, player.UserIDString), mod.type.ToString().Replace('_', ' '), Math.Round(modifiedDuration / 60, 0));
                    }

                    player.modifiers.Add(mods);
                    Pool.FreeUnmanaged(ref mods);

                    if (consumable.modifiers.Count > 0) Player.Message(player, messageString, config.misc_settings.ChatID);
                    return true;
                }
            }

            return null;
        }

        void HandleRationer(BasePlayer player, Item item, float value)
        {
            if (item.info.category == ItemCategory.Food && RollSuccessful(value) && !config.buff_settings.no_refund_item_skins.Contains(item.skin) && !item.info.shortname.StartsWith("fish.", StringComparison.Ordinal) && !item.info.shortname.StartsWith("clone.", StringComparison.Ordinal) && !item.info.shortname.StartsWith("seed.", StringComparison.Ordinal))
            {
                if (!PassCookingChecks(item)) return;
                if (Interface.CallHook("STOnRationTrigger", player, item) != null) return;
                var refunded_item = ItemManager.CreateByName(item.info.shortname, 1, item.skin);
                if (item.name != null) refunded_item.name = item.name;
                if (item.text != null) refunded_item.text = item.text;
                GiveItem(player, refunded_item);
                //player.GiveItem(refunded_item);                   
                if (config.notification_settings.chatMessageNotificationSettings.Rationed_Proc && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("Rationed", this, player.UserIDString), item.name ?? item.info.displayName.english), config.misc_settings.ChatID);
            }
        }

        void HandleMetabolismSharing(BasePlayer player, ItemModConsumable consumable, float Modifier)
        {
            if (player.Team == null) return;

            var nearby = FindNearbyTeamMates(player, config.buff_settings.metabolismShareSettings.Distance);

            foreach (var _player in nearby)
            {
                if (_player == player || !_player.IsConnected || _player.IsDead() || _player.Team == null || _player.Team.teamID != player.Team.teamID) continue;

                var gain = consumable.GetIfType(MetabolismAttribute.Type.Calories);
                _player.metabolism.calories.value += gain * Modifier;

                gain = consumable.GetIfType(MetabolismAttribute.Type.Hydration);
                _player.metabolism.hydration.value += gain * Modifier;

                _player.SendNetworkUpdate();

                if (config.notification_settings.chatMessageNotificationSettings.Metabolism_Share_Notify)
                {
                    if (NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("MetabolismSharePlayerMsg", this, player.UserIDString), _player.displayName), config.misc_settings.ChatID);
                    if (NotificationsOn(_player)) Player.Message(_player, string.Format(lang.GetMessage("MetabolismShareTargetMsg", this, _player.UserIDString), player.displayName), config.misc_settings.ChatID);
                }
            }

            Pool.FreeUnmanaged(ref nearby);
        }

        void HandleTeaSharing(BasePlayer player, Item item, ItemModConsumable consumable, float value)
        {
            if (player.Team == null) return;

            var nearby = FindNearbyTeamMates(player, config.buff_settings.teaShareSettings.Distance);

            foreach (var _player in nearby)
            {
                if (_player == player || !_player.IsConnected || _player.IsDead() || _player.Team == null || _player.Team.teamID != player.Team.teamID) continue;
                bool HasBetterBuff = false;
                foreach (var mod in _player.modifiers.All)
                {
                    if (_player.modifiers.All.Count == 0) break;
                    foreach (var def in consumable.modifiers)
                    {
                        var prospectiveAmount = (def.value * value);
                        if (def.type == mod.Type && (mod.Value > prospectiveAmount || (mod.Value == prospectiveAmount && mod.Duration > def.duration)))
                        {
                            HasBetterBuff = true;
                            break;
                        }
                    }
                    if (HasBetterBuff) break;
                }

                if (!HasBetterBuff)
                {
                    AddModifier(_player, consumable.modifiers, value);
                    if (config.notification_settings.chatMessageNotificationSettings.Tea_Share_Notify)
                    {
                        if (NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("TeaSharePlayerMsg", this, player.UserIDString), value * 100, _player.displayName), config.misc_settings.ChatID);
                        if (NotificationsOn(_player)) Player.Message(_player, string.Format(lang.GetMessage("TeaShareTargetMsg", this, _player.UserIDString), player.displayName, value * 100), config.misc_settings.ChatID);
                    }
                }
            }

            Pool.FreeUnmanaged(ref nearby);
        }

        void AddModifier(BasePlayer receiver, List<ModifierDefintion> mods, float value)
        {
            List<ModifierDefintion> modsToAdd = Pool.Get<List<ModifierDefintion>>();

            foreach (var mod in mods)
            {
                modsToAdd.Add(new ModifierDefintion()
                {
                    source = Modifier.ModifierSource.Tea,
                    duration = mod.duration,
                    type = mod.type,
                    value = mod.value * value
                });
            }
            receiver.modifiers.Add(modsToAdd);
            Pool.FreeUnmanaged(ref modsToAdd);

        }

        float GetTeaDuration(string shortname)
        {
            switch (shortname)
            {
                case "radiationresisttea.pure":
                case "radiationresisttea.advanced":
                case "radiationresisttea":
                case "oretea.pure":
                case "oretea.advanced":
                case "oretea":
                case "woodtea.pure":
                case "woodtea.advanced":
                case "woodtea":
                case "scraptea":
                    return 1800f;

                case "maxhealthtea.pure":
                case "maxhealthtea.advanced":
                case "maxhealthtea":
                case "harvestingtea":
                    return 1200f;

                case "craftingtea_quality":
                    return 300f;

                case "scraptea.pure":
                case "supertea":
                    return 3600f;

                case "scraptea.advanced":
                    return 2700f;

                default: return 1800f;
            }
        }

        object OnPlayerWound(BasePlayer player, HitInfo info)
        {
            if (player.IsNpc || !player.userID.IsSteamId()) return null;
            if (!GetBuffDetails(player.userID, out var bd))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - OnPlayerWound. [Online = {player.IsConnected}]", this, true);
                return null;
            }
            if (bd.GetBuff(Buff.Wounded_Resist, out var value) && RollSuccessful(value) && (config.buff_settings.Wounded_Resist_Cooldown == 0 || bd.cooldown_Wounded_Resist < Time.time))
            {
                bd.cooldown_Wounded_Resist = Time.time + config.buff_settings.Wounded_Resist_Cooldown;
                if (NotificationsOn(player))
                {
                    Player.Message(player, lang.GetMessage("WoundSave", this, player.UserIDString), config.misc_settings.ChatID);
                    if (config.buff_settings.Wounded_Resist_Cooldown > 0 && config.notification_settings.chatMessageNotificationSettings.Cooldown_Wounded_Resist) Player.Message(player, string.Format(lang.GetMessage("CooldownNotify", this, player.UserIDString), Buff.Wounded_Resist.ToString().Replace("_", " "), config.buff_settings.Wounded_Resist_Cooldown));
                }
                player.metabolism.radiation_level.SetValue(0);
                player.metabolism.radiation_poison.SetValue(0);
                player.metabolism.oxygen.SetValue(1);
                player.metabolism.temperature.SetValue(15);
                player.metabolism.bleeding.SetValue(0);
                player.health += 10;
                return false;
            }
            return null;
        }

        Dictionary<ulong, PlayerHelicopter> tracked_helis = new Dictionary<ulong, PlayerHelicopter>();
        Dictionary<ulong, MotorRowboat> tracked_rowboats = new Dictionary<ulong, MotorRowboat>();
        Dictionary<ulong, MotorRowboat> tracked_rhibs = new Dictionary<ulong, MotorRowboat>();

        // 444 == vehicle ultimate no damage.
        void AssignSkinToChildren(ulong id, List<BaseEntity> mountables)
        {
            if (mountables != null && mountables.Count > 0)
            {
                List<BaseEntity> tracked_children;
                if (!reduced_damage_entities.TryGetValue(id, out tracked_children)) reduced_damage_entities.Add(id, tracked_children = new List<BaseEntity>());
                foreach (var child in mountables)
                {
                    if (child == null || child.IsDestroyed) continue;
                    tracked_children.Add(child);
                    child.skinID = 444;
                    List<BaseEntity> children = Pool.Get<List<BaseEntity>>();
                    children.AddRange(child.children.Where(x => x.skinID != 444));
                    var parent = child.GetParentEntity();
                    if (parent != null && parent.skinID != 444) children.Add(parent);
                    AssignSkinToChildren(id, children);
                    Pool.FreeUnmanaged(ref children);
                }
            }
        }

        void RestoreSkinToChildren(List<BaseEntity> mountables)
        {
            if (mountables == null || mountables.Count == 0) return;
            foreach (var entity in mountables)
            {
                if (entity != null && !entity.IsDestroyed)
                {
                    if (entity.skinID == 444) entity.skinID = 0;
                }
            }
            mountables.Clear();
        }

        Dictionary<ulong, List<BaseEntity>> reduced_damage_entities = new Dictionary<ulong, List<BaseEntity>>();

        void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            if (player == null || entity == null || player.IsNpc || !player.userID.IsSteamId()) return;

            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - OnEntityMounted. [Online = {player.IsConnected}]", this, true);
                return;
            }

            if (bd.ContainsBuff(Buff.Vehicle_Ultimate) && IsUltimateEnabled(player, Buff.Vehicle_Ultimate))
            {
                if (entity.ShortPrefabName == "tugboatdriver") entity.GetParentEntity().skinID = 444;
                else
                {
                    List<BaseEntity> children = Pool.Get<List<BaseEntity>>();

                    if (entity.children != null) children.AddRange(entity.children);
                    var parent = entity.GetParentEntity();
                    if (parent != null) children.Add(parent);
                    AssignSkinToChildren(player.userID, children);
                    Pool.FreeUnmanaged(ref children);
                }
            }

            var vehicle = entity.GetParentEntity();
            if (vehicle == null) return;
            var horse = vehicle as RidableHorse;
            if (horse != null && bd.GetBuff(Buff.Riding_Speed, out var value))
            {
                if (horse.modifiers.GetValue(Modifier.ModifierType.HorseGallopSpeed) > value)
                    if (Interface.CallHook("STCanModifyHorse", player, horse, value) != null) return;

                if (Cooking != null && Cooking.IsLoaded && Convert.ToBoolean(Cooking.Call("IsHorseBuffed", horse))) return;
                if (HorseStats.TryGetValue(horse.net.ID.Value, out var horseData))
                {
                    if (horseData.mod > value) return;
                    RestoreHorseStats(horse);
                }
                HorseStats.Add(horse.net.ID.Value, new HorseInfo(player, horse, value));
                float baseSpeed = (horse.gaits[horse.gaits.Length - 1].maxSpeed + horse.equipmentSpeedMod) * horse.currentBreed.maxSpeed;
                horse.modifiers.Add(new List<ModifierDefintion>()
                {
                    new ModifierDefintion
                    {
                        type = Modifier.ModifierType.HorseGallopSpeed,
                        duration = 36000,
                        source = Modifier.ModifierSource.Tea,
                        value = baseSpeed * value
                    }
                });
                horse.modifiers.ServerUpdate(horse);
                return;
            }
            else if (vehicle is PlayerHelicopter)
            {
                var mini = vehicle as PlayerHelicopter;
                if (bd.GetBuff(Buff.Heli_Fuel_Rate, out value))
                {
                    ModifyHeliFuelRate(mini, value);
                }
                if (bd.GetBuff(Buff.Heli_Speed, out value))
                {
                    ModifyHeliSpeed(player, mini, value);
                }
            }
            else if (vehicle is Bike)
            {
                var bike = vehicle as Bike;
                if (bd.GetBuff(Buff.BikeEnginePower, out value))
                {
                    if (BikeStats.ContainsKey(bike.net.ID.Value)) return;
                    var oldKW = Convert.ToInt32(Engine.GetValue(bike));
                    BikeStats.Add(bike.net.ID.Value, new BikeInfo(player, bike, oldKW));
                    Engine.SetValue(bike, Convert.ToInt32(oldKW + (oldKW * value)));
                    bike.SendNetworkUpdate();
                }
            }
            else if (vehicle is MotorRowboat)
            {
                var boat = vehicle as MotorRowboat;

                if (bd.GetBuff(Buff.Boat_Fuel_Rate, out value))
                {
                    ModifyBoatFuelRate(boat, player, value);
                }
                if (config.buff_settings.boat_turbo_on_mount) IncreaseBoatSpeed(player, boat);
            }
        }

        void ModifyHeliSpeed(BasePlayer player, PlayerHelicopter mini, float value)
        {
            if (MiniStats.ContainsKey(mini.net.ID.Value)) return;
            MiniStats.Add(mini.net.ID.Value, new MiniInfo(player, mini, mini.liftFraction, mini.engineThrustMax));
            mini.liftFraction += mini.liftFraction * value;
            mini.engineThrustMax += mini.engineThrustMax * value;
            mini.SendNetworkUpdate();
        }

        void ModifyHeliFuelRate(PlayerHelicopter mini, float value)
        {
            if (mini.fuelPerSec < 0.5f) return;
            var fuelSystem = mini.GetFuelSystem() as EntityFuelSystem;
            if (fuelSystem == null || fuelSystem.nextFuelCheckTime == float.MaxValue || fuelSystem.GetFuelContainer().HasFlag(BaseEntity.Flags.Locked)) return;
            if (tracked_helis.ContainsKey(mini.net.ID.Value)) return;
            tracked_helis.Add(mini.net.ID.Value, mini);
            var fuel_rate = default_heli_fuel_rate - (default_heli_fuel_rate * value);
            mini.fuelPerSec = fuel_rate;
        }

        void ModifyBoatFuelRate(MotorRowboat boat, BasePlayer player, float value)
        {
            if (boat is RHIB)
            {
                if (boat.fuelPerSec < 0.25f) return;

                var fuelSystem = boat.GetFuelSystem() as EntityFuelSystem;
                if (fuelSystem == null || fuelSystem.nextFuelCheckTime == float.MaxValue || fuelSystem.GetFuelContainer().HasFlag(BaseEntity.Flags.Locked)) return;

                if (tracked_rhibs.ContainsKey(boat.net.ID.Value)) return;
                tracked_rhibs.Add(boat.net.ID.Value, boat);
                var fuel_rate = default_rhib_fuel_rate - (default_rhib_fuel_rate * value);
                boat.fuelPerSec = fuel_rate;
            }
            else
            {
                if (boat.fuelPerSec < 0.1f) return;

                var fuelSystem = boat.GetFuelSystem() as EntityFuelSystem;
                if (fuelSystem == null || fuelSystem.nextFuelCheckTime == float.MaxValue || fuelSystem.GetFuelContainer().HasFlag(BaseEntity.Flags.Locked)) return;

                if (tracked_rowboats.ContainsKey(boat.net.ID.Value)) return;
                tracked_rowboats.Add(boat.net.ID.Value, boat);
                var fuel_rate = default_rowboat_fuel_rate - (default_rowboat_fuel_rate * value);
                boat.fuelPerSec = fuel_rate;
            }
        }

        Dictionary<ulong, float> Vehicle_Mechanic_CooldownTimer = new Dictionary<ulong, float>();
        object OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (GetBuffDetails(player.userID, out var bd) && info?.HitEntity is BaseVehicle && bd.ContainsBuff(Buff.Vehicle_Mechanic))
            {
                if (config.buff_settings.Vehicle_Mechanic_Cooldown > 0)
                {
                    if (Vehicle_Mechanic_CooldownTimer.TryGetValue(player.userID, out var timeToEnd) && timeToEnd > Time.time) return null;
                    Vehicle_Mechanic_CooldownTimer[player.userID] = Time.time + config.buff_settings.Vehicle_Mechanic_Cooldown;
                }                
                var vehicle = info.HitEntity as BaseVehicle;
                var amount = vehicle.MaxHealth() - vehicle.health;
                if (amount <= 0) return null;
                else
                {
                    vehicle.Heal(amount);
                    if (!string.IsNullOrEmpty(config.effect_settings.repair_effect)) EffectNetwork.Send(new Effect(config.effect_settings.repair_effect, player.transform.position, player.transform.position), player.net.connection);
                    return false;
                }
            }

            return null;
        }

        void RestoreHorseStats(RidableHorse horse, bool doRemove = true)
        {
            HorseInfo hd;
            if (HorseStats.TryGetValue(horse.net.ID.Value, out hd))
            {
                horse.modifiers.RemoveVariable(Modifier.ModifierType.HorseGallopSpeed);
                horse.modifiers.ServerUpdate(horse);
            }
            if (doRemove) HorseStats.Remove(horse.net.ID.Value);
        }

        void RestoreMiniStats(PlayerHelicopter mini, BasePlayer dismounter, bool doRemove = true)
        {
            if (mini == null) return;
            MiniInfo data;
            if (!MiniStats.TryGetValue(mini.net.ID.Value, out data) || (dismounter != null && dismounter != data.player)) return;
            if (mini.IsAlive())
            {
                mini.liftFraction = data.old_lift_fraction;
                mini.engineThrustMax = data.old_engineThrustMax;
                mini.SendNetworkUpdate();
            }
            if (doRemove) MiniStats.Remove(mini.net.ID.Value);
        }

        void RestoreBikeStats(Bike bike, BasePlayer dismounter, bool doRemove = true)
        {
            if (bike == null) return;
            if (!BikeStats.TryGetValue(bike.net.ID.Value, out var data) || (dismounter != null && dismounter != data.player)) return;
            if (bike.IsAlive()) Engine.SetValue(bike, data.oldKW);
            if (doRemove) BikeStats.Remove(bike.net.ID.Value);
        }

        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null) return;
            DestroyRaidBehaviour(player);

            var attacker = info?.Initiator ?? info?.WeaponPrefab?.creatorEntity ?? info?.ProjectilePrefab?.owner;

            RemoveAnimalBuff(player);
            if (HorseStats.Count > 0)
            {
                List<KeyValuePair<ulong, HorseInfo>> temp_horse_list = Pool.Get<List<KeyValuePair<ulong, HorseInfo>>>();
                temp_horse_list.AddRange(HorseStats);
                foreach (KeyValuePair<ulong, HorseInfo> kvp in temp_horse_list)
                {
                    if (kvp.Value.player == player)
                    {
                        if (kvp.Value.horse == null)
                        {
                            HorseStats.Remove(kvp.Key);
                            break;
                        }
                        var horse = kvp.Value.horse;
                        if (horse != null && horse.IsAlive())
                        {
                            RestoreHorseStats(horse);
                            break;
                        }
                    }
                }
                Pool.FreeUnmanaged(ref temp_horse_list);
            }
            if (MiniStats.Count > 0)
            {
                List<KeyValuePair<ulong, MiniInfo>> temp_mini_list = Pool.Get<List<KeyValuePair<ulong, MiniInfo>>>();
                temp_mini_list.AddRange(MiniStats);
                foreach (var entry in MiniStats)
                {
                    if (entry.Value.player == player)
                    {
                        RestoreMiniStats(entry.Value.mini, player);
                        break;
                    }
                }
                Pool.FreeUnmanaged(ref temp_mini_list);
            }
            if (config.general_settings.drop_bag_on_death && !permission.UserHasPermission(player.UserIDString, "skilltree.bag.keepondeath"))
            {
                PlayerInfo pi;
                if (pcdData.pEntity.TryGetValue(player.userID, out pi) && pi.pouch_items != null && pi.pouch_items.Count > 0 && Interface.CallHook("STOnPouchDrop", player) == null && !player.InSafeZone())
                {
                    var bag = GenerateBag(player, 42);
                    if (bag != null && bag.inventory?.itemList != null && bag.inventory.itemList.Count > 0)
                    {
                        var pos = player.transform.position;
                        var rot = player.transform.rotation;
                        ServerMgr.Instance.Invoke(() =>
                        {
                            bag.inventory.Drop("assets/prefabs/misc/item drop/item_drop_backpack.prefab", pos, rot, 0);
                            pi.pouch_items.Clear();
                            containers.Remove(bag.inventory.uid.Value);
                            bag.KillMessage();
                        }, 0.1f);
                    }
                }
            }
            HandleResurrection(player, attacker);

            var damageType = info?.damageTypes?.GetMajorityDamageType();

            switch (damageType)
            {
                case Rust.DamageType.Fall:
                    if (config.roguelikeSettings.enabled && config.roguelikeSettings.wipeOnFallDeath && PlayerIsReal(player) && (!config.roguelikeSettings.requireConnection || player.IsConnected) && (!config.roguelikeSettings.require_permission || permission.UserHasPermission(player.UserIDString, "skilltree.roguelike")))
                    {
                        HandleDataReset(player);
                        Player.Message(player, lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), config.misc_settings.ChatID);
                        CreateGameTip(lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), player);
                    }
                    else LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Fall);
                    return;

                case Rust.DamageType.Drowned:
                    LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Drowned);
                    return;

                case Rust.DamageType.Radiation:
                    LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Radiation);
                    return;

                case Rust.DamageType.Cold:
                case Rust.DamageType.ColdExposure:
                    LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Cold);
                    return;

                case Rust.DamageType.Heat:
                    LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Fire);
                    return;

                case Rust.DamageType.ElectricShock:
                    LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Codelock);
                    return;

                case Rust.DamageType.Hunger:
                    LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Hunger);
                    return;

                case Rust.DamageType.Thirst:
                    LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Thirst);
                    return;
            }

            if (attacker == null) return;
            if (attacker is BasePlayer && player == (BasePlayer)attacker)
            {
                if (config.roguelikeSettings.enabled && config.roguelikeSettings.wipeOnSuicideDeath && PlayerIsReal(player) && (!config.roguelikeSettings.requireConnection || player.IsConnected) && (!config.roguelikeSettings.require_permission || permission.UserHasPermission(player.UserIDString, "skilltree.roguelike")))
                {
                    HandleDataReset(player);
                    Player.Message(player, lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), config.misc_settings.ChatID);
                    CreateGameTip(lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), player);
                }
                else LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Suicide);
                return;
            }
            // Attacker is real player
            if (info?.InitiatorPlayer != null && PlayerIsReal(info.InitiatorPlayer))
            {
                switch (player.GetType().Name)
                {
                    case "ZombieNPC":
                        AwardXP(info.InitiatorPlayer, config.xp_settings.xp_sources.Zombie, player, false, false, nameof(config.xp_settings.xp_sources.Zombie));
                        break;

                    case "NpcRaider":
                    case "RandomRaider":
                        AwardXP(info.InitiatorPlayer, config.xp_settings.xp_sources.Raider, player, false, false, nameof(config.xp_settings.xp_sources.Raider));
                        break;

                    case "JetPilot":
                        AwardXP(info.InitiatorPlayer, config.xp_settings.xp_sources.JetPilot, player, false, false, nameof(config.xp_settings.xp_sources.JetPilot));
                        break;

                    default:
                        if (!PlayerIsReal(player)) break;
                        if (!IsSameTeam(info.InitiatorPlayer, player)) AwardXP(info.InitiatorPlayer, config.xp_settings.xp_sources.PVP, player, false, false, nameof(config.xp_settings.xp_sources.PVP));
                        if (config.roguelikeSettings.enabled && config.roguelikeSettings.wipeOnPVPDeath && (!config.roguelikeSettings.requireConnection || player.IsConnected) && (!config.roguelikeSettings.require_permission || permission.UserHasPermission(player.UserIDString, "skilltree.roguelike")))
                        {
                            HandleDataReset(player);
                            Player.Message(player, lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), config.misc_settings.ChatID);
                            CreateGameTip(lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), player);
                        }
                        else LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.PVP);
                        break;
                }
            }
            else if (config.xp_settings.xp_loss_settings.xp_loss_table.Animal > 0 && attacker is BaseAnimalNPC)
            {
                if (config.roguelikeSettings.enabled && config.roguelikeSettings.wipeOnPVEDeath && PlayerIsReal(player) && (!config.roguelikeSettings.requireConnection || player.IsConnected) && (!config.roguelikeSettings.require_permission || permission.UserHasPermission(player.UserIDString, "skilltree.roguelike")))
                {
                    HandleDataReset(player);
                    Player.Message(player, lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), config.misc_settings.ChatID);
                    CreateGameTip(lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), player);
                }
                else LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Animal);
            }
            else if (config.xp_settings.xp_loss_settings.xp_loss_table.Scientist > 0 && (attacker is ScientistNPC))
            {
                if (config.roguelikeSettings.enabled && config.roguelikeSettings.wipeOnPVEDeath && PlayerIsReal(player) && (!config.roguelikeSettings.requireConnection || player.IsConnected) && (!config.roguelikeSettings.require_permission || permission.UserHasPermission(player.UserIDString, "skilltree.roguelike")))
                {
                    HandleDataReset(player);
                    Player.Message(player, lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), config.misc_settings.ChatID);
                    CreateGameTip(lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), player);
                }
                else LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Scientist);
            }
            else if (config.xp_settings.xp_loss_settings.xp_loss_table.Bradley > 0 && attacker is BradleyAPC)
            {
                if (config.roguelikeSettings.enabled && config.roguelikeSettings.wipeOnPVEDeath && PlayerIsReal(player) && (!config.roguelikeSettings.requireConnection || player.IsConnected) && (!config.roguelikeSettings.require_permission || permission.UserHasPermission(player.UserIDString, "skilltree.roguelike")))
                {
                    HandleDataReset(player);
                    Player.Message(player, lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), config.misc_settings.ChatID);
                    CreateGameTip(lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), player);
                }
                else LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Bradley);
            }
            else if (config.xp_settings.xp_loss_settings.xp_loss_table.Heli > 0 && attacker is PatrolHelicopter)
            {
                if (config.roguelikeSettings.enabled && config.roguelikeSettings.wipeOnPVEDeath && PlayerIsReal(player) && (!config.roguelikeSettings.requireConnection || player.IsConnected) && (!config.roguelikeSettings.require_permission || permission.UserHasPermission(player.UserIDString, "skilltree.roguelike")))
                {
                    HandleDataReset(player);
                    Player.Message(player, lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), config.misc_settings.ChatID);
                    CreateGameTip(lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), player);
                }
                else LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Heli);
            }
            else if (config.xp_settings.xp_loss_settings.xp_loss_table.Traps > 0 && (attacker is AutoTurret || attacker is GunTrap || attacker is BaseTrap))
            {
                if (config.roguelikeSettings.enabled && config.roguelikeSettings.wipeOnPVEDeath && PlayerIsReal(player) && (!config.roguelikeSettings.requireConnection || player.IsConnected) && (!config.roguelikeSettings.require_permission || permission.UserHasPermission(player.UserIDString, "skilltree.roguelike")))
                {
                    HandleDataReset(player);
                    Player.Message(player, lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), config.misc_settings.ChatID);
                    CreateGameTip(lang.GetMessage("RoguelikeDeathMessage", this, player.UserIDString), player);
                }
                else LoseXP(player, config.xp_settings.xp_loss_settings.xp_loss_table.Traps);
            }
        }

        bool IsSameTeam(BasePlayer attacker, BasePlayer defender)
        {
            if (attacker.Team == null || defender.Team == null) return false;
            return attacker.Team.teamID == defender.Team.teamID;
        }

        bool PlayerIsReal(BasePlayer player)
        {
            return !player.IsNpc && player.userID.IsSteamId();
        }

        void HandleResurrection(BasePlayer player, BaseEntity attacker)
        {
            BuffDetails bd;
            if ((!config.ultimate_settings.ultimate_medical.prevent_on_suicide || (attacker == null || attacker != player)) && GetBuffDetails(player.userID, out bd) && bd.ContainsBuff(Buff.Medical_Ultimate) && IsUltimateEnabled(player, Buff.Medical_Ultimate))
            {
                if (!config.ultimate_settings.ultimate_medical.allow_in_pvp_death && attacker != null)
                {
                    BasePlayer attackerPlayer = attacker as BasePlayer;
                    if (attackerPlayer != null && attackerPlayer.userID.IsSteamId()) return;
                }
                if (Interface.Oxide.CallHook("isEventPlayer", player) != null) return;
                SendResurrectionButton(player, player.transform.position);
            }
        }

        void OnPlayerDeath(ScarecrowNPC scarecrow, HitInfo info)
        {
            if (scarecrow == null || info == null || info.InitiatorPlayer == null || info.InitiatorPlayer.IsNpc || !info.InitiatorPlayer.userID.IsSteamId()) return;
            AwardXP(info.InitiatorPlayer, config.xp_settings.xp_sources.Scarecrow, scarecrow, false, false, nameof(config.xp_settings.xp_sources.Scarecrow));
        }

        void OnPlayerDeath(GingerbreadNPC npc, HitInfo info)
        {
            if (npc == null || info == null) return;
            var attacker = info.InitiatorPlayer;
            if (attacker == null || attacker.IsNpc || !attacker.userID.IsSteamId()) return;
            AwardXP(attacker, config.xp_settings.xp_sources.GingerbreadNPC, npc, false, false, nameof(config.xp_settings.xp_sources.GingerbreadNPC));
        }

        void OnPlayerDeath(ScientistNPC npc, HitInfo info)
        {
            if (npc == null || info == null) return;
            var attacker = info.InitiatorPlayer;
            if (attacker == null || attacker.IsNpc) return;
            if (config.misc_settings.botRespawnSettings.enabled && BotReSpawn != null && BotReSpawn.IsLoaded && Convert.ToBoolean(BotReSpawn.Call("IsBotReSpawn", npc))) return;
            double betterNPCXP = 0;
            if (npc.skinID == 11162132011012 && config.betternpc_settings.NPC_xp_table.TryGetValue(npc.displayName, out betterNPCXP))
            {
                if (betterNPCXP == 0) betterNPCXP = config.xp_settings.xp_sources.ScientistNormal;
                AwardXP(attacker, betterNPCXP, npc);
            }
            else if (npc.ShortPrefabName == "scientistnpc_heavy")
            {
                AwardXP(attacker, config.xp_settings.xp_sources.ScientistHeavy, npc, false, false, nameof(config.xp_settings.xp_sources.ScientistHeavy));
            }
            else
            {
                AwardXP(attacker, config.xp_settings.xp_sources.ScientistNormal, npc, false, false, nameof(config.xp_settings.xp_sources.ScientistNormal));
            }

        }

        void OnEntityDeath(ScientistNPC2 npc, HitInfo info)
        {
            if (npc == null || info == null) return;
            var attacker = info.InitiatorPlayer;
            if (attacker == null || attacker.IsNpc) return;

            AwardXP(attacker, config.xp_settings.xp_sources.Scientist2, npc, false, false, nameof(config.xp_settings.xp_sources.Scientist2));
        }



        void OnPlayerDeath(TunnelDweller npc, HitInfo info)
        {
            if (npc == null || info == null) return;
            var attacker = info.InitiatorPlayer;
            if (attacker == null || attacker.IsNpc || !attacker.userID.IsSteamId()) return;
            AwardXP(attacker, config.xp_settings.xp_sources.TunnelDweller, npc, false, false, nameof(config.xp_settings.xp_sources.TunnelDweller));
        }

        void OnPlayerDeath(UnderwaterDweller npc, HitInfo info)
        {
            if (npc == null || info == null) return;
            var attacker = info.InitiatorPlayer;
            if (attacker == null || attacker.IsNpc || !attacker.userID.IsSteamId()) return;
            AwardXP(attacker, config.xp_settings.xp_sources.UnderwaterDweller, npc, false, false, nameof(config.xp_settings.xp_sources.UnderwaterDweller));
        }

        bool PassZoneManagerCheck(BasePlayer player)
        {
            if (ZoneManager == null || !ZoneManager.IsLoaded) return true;
            string[] zones = (string[])ZoneManager.Call("GetPlayerZoneIDs", player);
            if (zones == null) return true;

            foreach (var zone in zones)
                if (config.misc_settings.zoneManagerSettings.NoXPLossZones.Contains(zone))
                    return false;

            return true;
        }

        void LoseXP(BasePlayer player, float lossValue)
        {
            if (lossValue <= 0) return;
            if (config.xp_settings.xp_loss_settings.prevent_offline_xp_loss && !player.IsConnected) return;
            if (Interface.CallHook("STOnLoseXP", player) != null || (config.xp_settings.prevent_xp_loss && ((EventManager != null && EventManager.IsLoaded && Convert.ToBoolean(EventManager.Call("IsEventPlayer", player))) || (EventHelper != null && EventHelper.IsLoaded && Convert.ToBoolean(EventHelper.Call("EMPlayerDiedAtEvent", player)))))) return;
            if (!PassZoneManagerCheck(player)) return;
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData)) return;
            if (config.xp_settings.xp_loss_settings.no_xp_loss_time > 0 && playerData.last_xp_loss.AddSeconds(config.xp_settings.xp_loss_settings.no_xp_loss_time) > DateTime.Now) return;

            var Level = config.level.GetLevel(playerData.xp);
            var LevelStartXP = config.level.GetLevelStartXP(Level) + 1;

            double xp_loss = 0;
            switch (config.xp_settings.xp_loss_settings.xp_loss_type)
            {
                case XPLossType.XpValue:
                case XPLossType.PercentageOfCurrentLevel:
                    xp_loss = GetXPLoss(player, lossValue, playerData.xp - LevelStartXP);
                    break;

                case XPLossType.PercentageOfTotalXp:
                    xp_loss = GetXPLoss(player, lossValue, playerData.xp);
                    break;
            }

            if (xp_loss <= 0) return;

            playerData.last_xp_loss = DateTime.Now;
            if (playerData.xp - LevelStartXP > xp_loss)
            {
                playerData.xp -= xp_loss;
                Player.Message(player, string.Format(lang.GetMessage("LostXP", this, player.UserIDString), xp_loss.ToString($"N{config.xp_settings.xp_rounding}")), config.misc_settings.ChatID);
            }
            else
            {
                if (config.xp_settings.xp_loss_settings.allow_xp_debt)
                {
                    var xpLeft = playerData.xp - LevelStartXP;
                    var excess = xp_loss - xpLeft;
                    playerData.xp = LevelStartXP;
                    playerData.xp_debt += excess;

                    Player.Message(player, string.Format(lang.GetMessage("AccumulatedXPDebt", this, player.UserIDString), Math.Round(excess, config.xp_settings.xp_rounding), Math.Round(playerData.xp_debt, config.xp_settings.xp_rounding)), config.misc_settings.ChatID);

                }
                else
                {
                    Player.Message(player, string.Format(lang.GetMessage("LostXP", this, player.UserIDString), (playerData.xp - LevelStartXP).ToString($"N{config.xp_settings.xp_rounding}")), config.misc_settings.ChatID);
                    playerData.xp = LevelStartXP;
                }
            }

            CheckLevel(player);
            UpdateXP(player, playerData);
        }

        void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            if (player.IsNpc || !player.userID.IsSteamId() || entity == null || entity.GetParentEntity() == null) return;

            if (reduced_damage_entities.ContainsKey(player.userID)) RestoreSkinToChildren(reduced_damage_entities[player.userID]);

            var vehicle = entity.GetParentEntity();
            if (vehicle is RidableHorse horse)
            {
                if (horse == null) return;
                if (HorseStats.ContainsKey(horse.net.ID.Value))
                {
                    if (horse != null && horse.IsAlive()) RestoreHorseStats(horse);
                    else HorseStats.Remove(horse.net.ID.Value);
                }
            }
            else if (vehicle is MotorRowboat boat)
            {
                ResetBoatSpeed(boat, player);

                BuffDetails bd;
                if (GetBuffDetails(player.userID, out bd) && bd.ContainsBuff(Buff.Boat_Fuel_Rate))
                {
                    if (boat == null) return;
                    if (tracked_rowboats.ContainsKey(boat.net.ID.Value) && boat.IsAlive())
                    {
                        boat.fuelPerSec = default_rowboat_fuel_rate;
                        tracked_rowboats.Remove(boat.net.ID.Value);
                    }
                    else if (tracked_rhibs.ContainsKey(boat.net.ID.Value) && boat.IsAlive())
                    {
                        boat.fuelPerSec = default_rhib_fuel_rate;
                        tracked_rhibs.Remove(boat.net.ID.Value);
                    }
                }
            }
            else if (vehicle is PlayerHelicopter mini)
            {
                BuffDetails bd;
                if (!GetBuffDetails(player.userID, out bd)) return;
                if (bd.ContainsBuff(Buff.Heli_Fuel_Rate))
                {
                    if (!tracked_helis.ContainsKey(mini.net.ID.Value)) return;
                    mini.fuelPerSec = default_heli_fuel_rate;
                    tracked_helis.Remove(mini.net.ID.Value);
                }
                if (bd.ContainsBuff(Buff.Heli_Speed))
                {
                    RestoreMiniStats(mini, player);
                }
            }
            else if (vehicle is Bike bike)
            {
                if (!GetBuffDetails(player.userID, out var bd)) return;
                if (bd.ContainsBuff(Buff.BikeEnginePower))
                {
                    RestoreBikeStats(bike, player);
                }
            }
        }

        object OnPayForUpgrade(BasePlayer player, BuildingBlock block, ConstructionGrade gradeTarget)
        {
            if (player != null && GetBuffDetails(player.userID, out var bd) && bd.GetBuff(Buff.Upgrade_Refund, out var value) && RollSuccessful(value))
            {
                if (config.notification_settings.chatMessageNotificationSettings.Free_Upgrade_Proc && NotificationsOn(player)) Player.Message(player, lang.GetMessage("FreeUpgrade", this, player.UserIDString), config.misc_settings.ChatID);
                return 0;
            }
            return null;
        }

        void ChangeBoatSpeedCMD(BasePlayer player)
        {
            var boat = player.GetMountedVehicle() as MotorRowboat;
            if (boat == null)
            {
                Player.Message(player, lang.GetMessage("NoBoatFound", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }

            if (Boats.ContainsKey(boat.net.ID.Value)) ResetBoatSpeed(boat, player);
            else IncreaseBoatSpeed(player, boat);
        }

        void IncreaseBoatSpeed(BasePlayer player, MotorRowboat boat)
        {
            if (boat == null) return;

            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd)) return;

            float value;
            if (!bd.GetBuff(Buff.Boat_Speed, out value)) return;

            if (Interface.CallHook("STOnModifyBoatSpeed", player, boat) != null) return;

            var defaultSpeed = DefaultBoatSpeed(boat.ShortPrefabName);

            BoatInfo bi;
            if (Boats.TryGetValue(boat.net.ID.Value, out bi))
            {
                if (boat.engineThrust > defaultSpeed) return;

                bi.defaultSpeed = defaultSpeed;
                boat.engineThrust += value * defaultSpeed;
                MessageMounted(boat, "TurboToggleOn");
                //Player.Message(player, lang.GetMessage("TurboToggleOn", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }

            Boats.Add(boat.net.ID.Value, new BoatInfo(player, boat, defaultSpeed));
            boat.engineThrust += value * defaultSpeed;
            MessageMounted(boat, "TurboToggleOn");
            //Player.Message(player, lang.GetMessage("TurboToggleOn", this, player.UserIDString), config.misc_settings.ChatID);
        }

        void MessageMounted(MotorRowboat boat, string langKey)
        {
            foreach (var entity in boat.children)
            {
                var seat = entity as BaseVehicleSeat;
                if (seat != null && seat._mounted != null) Player.Message(seat._mounted, lang.GetMessage(langKey, this, seat._mounted.UserIDString), config.misc_settings.ChatID);

            }
        }

        void ResetBoatSpeed(MotorRowboat boat, BasePlayer player = null, bool doRemove = true)
        {
            if (boat == null) return;
            BoatInfo bi;
            if (!Boats.TryGetValue(boat.net.ID.Value, out bi)) return;

            if (player != null && bi.player != player) return;

            var defaultSpeed = DefaultBoatSpeed(boat.ShortPrefabName);
            if (boat.engineThrust > defaultSpeed)
            {
                MessageMounted(boat, "TurboToggleOff");
                boat.engineThrust = defaultSpeed;
            }

            if (doRemove) Boats.Remove(boat.net.ID.Value);
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (input.WasJustPressed(BUTTON.FIRE_THIRD) && player.isMounted)
            {
                var boat = player.GetMountedVehicle() as MotorRowboat;
                if (boat == null) return;

                if (Boats.ContainsKey(boat.net.ID.Value)) ResetBoatSpeed(boat, player, true);
                else IncreaseBoatSpeed(player, boat);
            }
        }

        Dictionary<ResearchTable, BasePlayer> Researchers = new Dictionary<ResearchTable, BasePlayer>();
        object OnResearchCostDetermine(Item item)
        {
            ResearchTable researchTable = item.GetEntityOwner() as ResearchTable;
            if (researchTable == null) return null;
            var player = researchTable.user;
            if (player != null) Researchers[researchTable] = player;
            else if (Researchers.ContainsKey(researchTable)) player = Researchers[researchTable];
            if (!researchTable.IsResearching()) return null;
            BuffDetails bd;
            float value;
            if (player != null && GetBuffDetails(player.userID, out bd) && bd.GetBuff(Buff.Research_Refund, out value) && RollSuccessful(value))
            {
                if (config.notification_settings.chatMessageNotificationSettings.Research_Refund_Proc && NotificationsOn(player)) Player.Message(player, lang.GetMessage("ScrapRefund", this, player.UserIDString), config.misc_settings.ChatID);
                return 0;
            }
            return null;
        }

        void SaveNewNodesToConfig(bool unloaded)
        {
            if (QueuedNodes == null || QueuedNodes.Count == 0) return;
            int count = 0;
            foreach (var tree in QueuedNodes)
            {
                foreach (var node in tree.Value)
                {
                    Configuration.TreeInfo treeData;
                    if (!config.trees.TryGetValue(tree.Key, out treeData)) continue;
                    if (!treeData.nodes.ContainsKey(node.Key))
                    {
                        treeData.nodes.Add(node.Key, node.Value);
                        count++;
                    }
                }
            }
            Puts($"Saved {count} new nodes. Reloading plugin.");
            SaveConfig();
            NewNodesAdded = false;
            QueuedNodes.Clear();

            if (!unloaded) Interface.Oxide.ReloadPlugin(Name);
        }

        void OnServerSave()
        {
            SaveData();
            if (NewNodesAdded)
            {
                try
                {
                    SaveNewNodesToConfig(false);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        DoClear(player, config.buff_settings.removePermissionsOnDisconnect);
                        LoggingOff(player, true);
                        HandleNewConnection(player);
                    }
                }
                catch { }
            }

            if (!string.IsNullOrEmpty(PlayerDataLogs))
            {
                LogToFile($"New_Player_Data", PlayerDataLogs, this);
                PlayerDataLogs = string.Empty;
            }
        }

        string PlayerDataLogs = string.Empty;

        public void HandleNewConnection(BasePlayer player)
        {
            if (buffDetails.ContainsKey(player.userID))
            {
                try
                {
                    DoClear(player, true);
                }
                catch { buffDetails.Remove(player.userID); }
                try
                {
                    LoggingOff(player, true);
                }
                catch { }
            }
            var data = LoadPlayerData(player.UserIDString);
            if (data == null)
            {
                PlayerDataLogs += $"\nData was null for {player.userID}. Creating new data.";
                data = new PlayerInfo();
            }
            pcdData.pEntity[player.userID] = data;

            SetupPlayer(player.userID, player.displayName);
            UpdateInstancedData(player);
            PlayerInfo playerData = pcdData.pEntity[player.userID];
            if (playerData.xp_hud) UpdateXP(player, playerData);
            BuffDetails bd;
            if (GetBuffDetails(player.userID, out bd) && bd.GetBuff(Buff.Metabolism_Boost, out var value)) IncreaseCalories(player, value);
            LoggedOn(player, playerData);

            if (playerData.pending_xp_with_bonus > 0)
            {
                Player.Message(player, string.Format(lang.GetMessage("OfflineXPReceived", this, player.UserIDString), playerData.pending_xp_with_bonus), config.misc_settings.ChatID);
                AwardXP(player, playerData.pending_xp_with_bonus, null, true, true, "pending_xp_with_bonus");
                playerData.pending_xp_with_bonus = 0;
            }

            if (playerData.pending_xp_without_bonus > 0)
            {
                Player.Message(player, string.Format(lang.GetMessage("OfflineXPReceived", this, player.UserIDString), playerData.pending_xp_without_bonus), config.misc_settings.ChatID);
                AwardXP(player, playerData.pending_xp_without_bonus, null, true, true, "pending_xp_without_bonus");
                playerData.pending_xp_without_bonus = 0;
            }
        }

        List<ulong> looted_containers = new List<ulong>();
        List<ItemDefinition> component_item_list = new List<ItemDefinition>();
        List<ItemDefinition> electrical_item_list = new List<ItemDefinition>();

        Item GetRandomItemDef(ItemCategory category, int min, int max)
        {
            Item result = null;
            if (category == ItemCategory.Component)
            {
                if (component_item_list.Count > 0) result = CreateItemUsingDef(component_item_list.GetRandom(), min, max);
                else if (config.tools_black_white_list_settings.electricalComponentSettings.component_loot_override.Count > 0)
                    result = CreateDropItem(RollLootItem(config.tools_black_white_list_settings.electricalComponentSettings.component_loot_override));
            }
            if (category == ItemCategory.Electrical)
            {
                if (electrical_item_list.Count > 0) result = CreateItemUsingDef(electrical_item_list.GetRandom(), min, max);
                else if (config.tools_black_white_list_settings.electricalComponentSettings.electrical_loot_override.Count > 0)
                    result = CreateDropItem(RollLootItem(config.tools_black_white_list_settings.electricalComponentSettings.electrical_loot_override));
            }
            return result;
        }

        Item CreateItemUsingDef(ItemDefinition def, int min, int max)
        {
            return ItemManager.CreateByName(def.shortname, Math.Max(UnityEngine.Random.Range(min, max + 1), 1));
        }

        void AddItemToContainer(LootContainer container, Item item)
        {
            if (container == null || container.inventory == null || item == null) return;
            container.inventory.capacity++;
            container.inventorySlots++;
            if (!item.MoveToContainer(container.inventory)) item.Remove();
        }

        void CanLootEntity(BasePlayer player, LootContainer container)
        {
            if (container == null || container.net == null || player == null) return;

            if (!GetBuffDetails(player.userID, out var bd)) return;
            if (looted_containers.Contains(container.net.ID.Value)) return;
            looted_containers.Add(container.net.ID.Value);
            if (Interface.CallHook("STCanReceiveBonusLootFromContainer", player, container) != null) return;

            float value;
            if (config.loot_settings.loot_crate_whitelist.IsNullOrEmpty() || (config.loot_settings.loot_crate_whitelist.Contains(container.PrefabName)))
            {
                if (bd.GetBuff(Buff.Component_Chest, out value) && RollSuccessful(value) && container.inventorySlots < 12)
                {
                    var item = GetRandomItemDef(ItemCategory.Component, config.buff_settings.min_components, config.buff_settings.max_components);
                    AddItemToContainer(container, item);
                }
                if (bd.GetBuff(Buff.Electronic_Chest, out value) && RollSuccessful(value) && container.inventorySlots < 12)
                {
                    var item = GetRandomItemDef(ItemCategory.Electrical, config.buff_settings.min_electrical_components, config.buff_settings.max_electrical_components);
                    AddItemToContainer(container, item);
                }
                if (bd.GetBuff(Buff.Extra_Scrap_Crate, out value) && RollSuccessful(value))
                {
                    var item = ItemManager.CreateByName("scrap", Math.Max(UnityEngine.Random.Range(config.buff_settings.min_extra_scrap, config.buff_settings.max_extra_scrap + 1), 1));
                    AddItemToContainer(container, item);
                }
            }

            if (DeepSeaLooterLootTable.TryGetValue(container.PrefabName, out var table) && table.Count > 0 && bd.GetBuff(Buff.DeepSeaLooter, out value) && RollSuccessful(value))
            {
                var loot = table[UnityEngine.Random.Range(0, table.Count)];
                container.inventory.capacity++;
                container.inventorySlots++;
                ItemManager.CreateByName(loot.shortname, UnityEngine.Random.Range(loot.min, loot.max)).MoveToContainer(container.inventory);
            }

            if (bd.GetBuff(Buff.Tea_Looter, out value) && RollSuccessful(value) && IsFoodCrate(container.ShortPrefabName))
            {
                var item = ItemManager.CreateByName(RollTea(), config.buff_settings.tea_looter_settings.max_tea < 2 ? 1 : Math.Max(UnityEngine.Random.Range(config.buff_settings.tea_looter_settings.min_tea, config.buff_settings.tea_looter_settings.max_tea + 1), 1));
                if (item != null)
                {
                    Player.Message(player, string.Format(lang.GetMessage("TeaFound", this, player.UserIDString), item.amount, item.info.displayName.english));
                    container.inventory.capacity++;
                    container.inventorySlots++;
                    if (!item.MoveToContainer(container.inventory)) player.GiveItem(item);
                }
            }
        }

        string RollTea()
        {
            var totalWeight = config.buff_settings.tea_looter_settings.TeaDropTable.Sum(x => x.Value);
            var roll = UnityEngine.Random.Range(0, totalWeight + 1);

            var count = 0;
            foreach (var tea in config.buff_settings.tea_looter_settings.TeaDropTable)
            {
                if (tea.Value <= 0) continue;
                count += tea.Value;
                if (roll <= count) return tea.Key;
            }

            Puts("Error: Failed to find tea for some reason. Rolling a random tea.");
            List<string> randomTea = Pool.Get<List<string>>();
            foreach (var tea in config.buff_settings.tea_looter_settings.TeaDropTable)
                if (tea.Value > 0) randomTea.Add(tea.Key);

            var result = randomTea.GetRandom();
            Pool.FreeUnmanaged(ref randomTea);

            return result;
        }

        bool IsFoodCrate(string shortname)
        {
            switch (shortname)
            {
                case "crate_normal_2_food":
                case "invisible_crate_normal_2_food":
                case "crate_food_1":
                case "crate_food_2":
                case "wagon_crate_normal_2_food":
                case "foodbox":
                case "invisible_foodbox":
                case "dmfood":
                    return true;

                default: return false;
            }
        }

        [PluginReference]
        private Plugin ImageLibrary, Economics, ServerRewards, ShoppyStock, EventManager, BotReSpawn, Cooking, UINotify, ZombieHorde, EventHelper, RaidableBases, LootDefender, SkillTreeXPEvent, ZoneManager, VirtualRecycler, DeployableNature, NotificationSystem;

        Dictionary<Buff, BuffType> BuffBuffType = new Dictionary<Buff, BuffType>();

        private Dictionary<string, string> loadOrder = new Dictionary<string, string>();

        private KeyValuePair<string, string> ExtraPocketsImg;
        private KeyValuePair<string, ulong> ExtraPocketsImgSkin;
        Timer LogTimer;
        List<string> TrackedPermissionPerms = new List<string>();
        List<string> Trees = new List<string>();

        bool Update()
        {
            if (pcdData.updated) return false;
            foreach (var tree in config.trees)
            {
                foreach (var nodes in tree.Value.nodes)
                {
                    if (nodes.Value.tier == 4) 
                        nodes.Value.tier = UltimateLevel;
                }
            }
            pcdData.updated = true;
            return true;
        }

        void OnServerInitialized(bool initial)
        {
            LoadMessages();

            if (config.xp_settings.xPCapSettings.cap > 0)
            {
                pcdData.nextXPCapReset = GetNextCapReset();
                ServerMgr.Instance.InvokeRepeating(() => CheckForCapUpdate(), 60, 60);
            }

            var foundNewContent = false;
            if (Update()) foundNewContent = true;
            bool allfalse = true;
            foreach (var tree in config.trees)
            {
                if (tree.Value.enabled) allfalse = false;
                foreach (var node in tree.Value.nodes)
                {
                    if (!tree.Value.point_requirements.ContainsKey(node.Value.tier))
                    {
                        if (node.Value.tier == UltimateLevel) tree.Value.point_requirements.Add(node.Value.tier, 25);
                        else tree.Value.point_requirements.Add(node.Value.tier, (node.Value.tier - 1) * 5);
                        foundNewContent = true;
                    }
                    if (!string.IsNullOrEmpty(node.Value.required_permission))
                    {
                        if (!node.Value.required_permission.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase))
                        {
                            node.Value.required_permission = "skilltree." + node.Value.required_permission;
                            foundNewContent = true;
                        }
                        if (!permission.PermissionExists(node.Value.required_permission, this))
                        {
                            permission.RegisterPermission(node.Value.required_permission, this);
                        }
                        if (!TrackedPermissionPerms.Contains(node.Value.required_permission)) TrackedPermissionPerms.Add(node.Value.required_permission);
                    }

                    var defaultTree = DefaultTrees.ContainsKey(tree.Key) ? DefaultTrees[tree.Key] : null;
                    if (defaultTree == null) continue;
                    var defaultNode = defaultTree != null && defaultTree.nodes.ContainsKey(node.Key) ? defaultTree.nodes[node.Key] : null;
                    if (defaultNode == null) continue;                    
                    if (node.Value.skin == 0 && config.misc_settings.update_skinIDs_from_default)
                    {
                        node.Value.skin = defaultNode.skin;
                        Puts($"Updating node skin id for: {node.Key}");
                        foundNewContent = true;
                    }
                }
            }

            if (!config.general_settings.require_tree_perms && TrackedPermissionPerms.Count == 0 && config.wipe_update_settings.starting_skill_point_overrides.Count == 0)
            {
                Unsubscribe(nameof(OnGroupPermissionRevoked));
                Unsubscribe(nameof(OnGroupPermissionGranted));
                Unsubscribe(nameof(OnUserPermissionRevoked));
                Unsubscribe(nameof(OnUserPermissionGranted));
                Unsubscribe(nameof(OnUserGroupAdded));
                Unsubscribe(nameof(OnUserGroupRemoved));
            }

            if (allfalse)
            {
                foreach (var tree in config.trees)
                    tree.Value.enabled = true;
                foundNewContent = true;
            }

            if (pcdData.HighestPlayer == 0)
            {
                bonus_given = true;
            }

            if (config.general_settings.points_per_level_override.Count == 0)
            {
                config.general_settings.points_per_level_override.Add("points.vip", config.general_settings.points_per_level + 1);
                foundNewContent = true;
                if (!permission.PermissionExists("skilltree.points.vip", this)) permission.RegisterPermission("skilltree.points.vip", this);
            }

            if (config.general_settings.respec_cost_override.Count == 0)
            {
                config.general_settings.respec_cost_override.Add("vip", Math.Round(config.general_settings.respec_cost / 2, 0));
                foundNewContent = true;
                if (!permission.PermissionExists("skilltree.vip")) permission.RegisterPermission("skilltree.vip", this);
            }

            if (config.general_settings.max_skill_points_override.Count == 0)
            {
                config.general_settings.max_skill_points_override.Add("vip", config.general_settings.max_skill_points + (Convert.ToInt32(config.general_settings.max_skill_points * 0.2)));
                foundNewContent = true;
                if (!permission.PermissionExists("skilltree.vip")) permission.RegisterPermission("skilltree.vip", this);
            }

            if (config.xp_settings.xp_loss_settings.xp_loss_override.Count == 0)
            {
                config.xp_settings.xp_loss_settings.xp_loss_override.Add("vip", 0.5);
                foundNewContent = true;
                if (!permission.PermissionExists("skilltree.vip")) permission.RegisterPermission("skilltree.vip", this);
            }

            if (config.rested_xp_settings.rested_xp_modifier_perm_mod.Count == 0)
            {
                config.rested_xp_settings.rested_xp_modifier_perm_mod.Add("restedxp.10", 0.1f);
                foundNewContent = true;
                if (!permission.PermissionExists("skilltree.vip")) permission.RegisterPermission("skilltree.vip", this);
            }

            if (config.wipe_update_settings.starting_skill_point_overrides.Count == 0)
            {
                config.wipe_update_settings.starting_skill_point_overrides.Add("vip.starting.points", 5);
                foundNewContent = true;
                if (!permission.PermissionExists("skilltree.vip.starting.points")) permission.RegisterPermission("skilltree.vip.starting.points", this);
            }

            foreach (var perm in config.xp_settings.xp_loss_settings.xp_loss_override)
            {
                if (!permission.PermissionExists("skilltree." + perm.Key, this)) permission.RegisterPermission("skilltree." + perm.Key, this);
            }

            foreach (var perm in config.general_settings.level_requirement_override)
            {
                var permStr = perm.Key;
                if (!permStr.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase)) permStr = "skilltree." + perm.Key;
                permission.RegisterPermission(permStr, this);
            }

            foreach (var perm in config.general_settings.point_requirement_override)
            {
                var permStr = perm.Key;
                if (!permStr.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase)) permStr = "skilltree." + perm.Key;
                permission.RegisterPermission(permStr, this);
            }

            foreach (var perm in config.misc_settings.presetSettings.maxPresetsOverride)
            {
                var permStr = perm.Key;
                if (!permStr.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase)) permStr = "skilltree." + perm.Key;
                permission.RegisterPermission(permStr, this);
            }

            config.level.CalculateTable(config.general_settings.max_player_level);
            if (Configuration.ExperienceInfo.UpdatedTable) foundNewContent = true;
            if (BotReSpawn != null && config.misc_settings.botRespawnSettings.enabled)
            {
                var BotReSpawnBots = (Dictionary<string, List<ulong>>)BotReSpawn?.Call("BotReSpawnBots");
                foreach (var profile in BotReSpawnBots)
                {
                    if (!config.misc_settings.botRespawnSettings.botrespawn_profiles.ContainsKey(profile.Key))
                    {
                        config.misc_settings.botRespawnSettings.botrespawn_profiles.Add(profile.Key, config.xp_settings.xp_sources.default_botrespawn);
                        Puts($"Added new BotReSpawn profile: {profile.Key}. Allocated default xp value of: {config.xp_settings.xp_sources.default_botrespawn}.");
                        foundNewContent = true;
                    }
                }
            }
            else Unsubscribe(nameof(OnBotReSpawnNPCKilled));

            // Checks for new trees added to the plugin between updates and adds them to the users config.
            Dictionary<string, Configuration.TreeInfo> trees = DefaultTrees;
            foreach (var tree in DefaultTrees)
            {
                if (!config.trees.ContainsKey(tree.Key))
                {
                    if (!config.wipe_update_settings.auto_update_trees) continue;
                    config.trees.Add(tree.Key, tree.Value);
                    Puts($"Adding new tree: {tree.Key}");
                    foundNewContent = true;
                }
                else
                {
                    foreach (var node in tree.Value.nodes)
                    {
                        if (!config.trees[tree.Key].nodes.ContainsKey(node.Key) && config.wipe_update_settings.auto_update_nodes)
                        {
                            Puts($"Adding new node: {node.Key}");
                            config.trees[tree.Key].nodes.Add(node.Key, node.Value);
                            foundNewContent = true;
                        }
                        var configNodes = config.trees[tree.Key].nodes;
                        if (configNodes.TryGetValue(node.Key, out var nodeData) && nodeData.skin < 1 && node.Value.skin > 0)
                        {
                            if (!config.misc_settings.update_skinIDs_from_default) continue;
                            nodeData.skin = node.Value.skin;
                            foundNewContent = true;
                        }
                    }
                }
            }

            // Gets and stores all bp defs. Also stores category info.
            foreach (var itemDef in ItemManager.GetItemDefinitions())
            {
                ItemDefs.Add(itemDef.shortname, itemDef);
                if (itemDef.Blueprint != null && itemDef.Blueprint.userCraftable)
                {
                    if (!item_BPs.ContainsKey(itemDef.shortname)) item_BPs.Add(itemDef.shortname, itemDef.Blueprint);
                }
                if (itemDef.steamDlc != null || itemDef.steamItem != null || itemDef.hidden) continue;
                if (itemDef.category == ItemCategory.Electrical && config.tools_black_white_list_settings.electricalComponentSettings.electrical_loot_override.Count == 0 && !config.tools_black_white_list_settings.electricalComponentSettings.comp_blacklist.Contains(itemDef.shortname)) electrical_item_list.Add(itemDef);
                else if (itemDef.category == ItemCategory.Component && config.tools_black_white_list_settings.electricalComponentSettings.component_loot_override.Count == 0 && !config.tools_black_white_list_settings.electricalComponentSettings.comp_blacklist.Contains(itemDef.shortname)) component_item_list.Add(itemDef);
            }
            if (config.misc_settings.enableDebug) Puts($"Blueprint count: {item_BPs.Count}");

            if (config.ultimate_settings.ultimate_skinning.enabled_buffs.Count == 0)
            {
                config.ultimate_settings.ultimate_skinning.enabled_buffs = DefaultAnimalBuffs;
                foundNewContent = true;
            }
            DeepSeaLooterLootTable = GetUnderwaterLoot();

            if (config.buff_settings.durability_blacklist.Count == 0)
            {
                config.buff_settings.durability_blacklist = DefaultDurabilityBlacklist;
                foundNewContent = true;
            }

            if (config.loot_settings.mining_loot_table.Count == 0)
            {
                config.loot_settings.mining_loot_table = DefaultLootItems;
                foundNewContent = true;
            }

            if (config.loot_settings.wc_loot_table.Count == 0)
            {
                config.loot_settings.wc_loot_table = DefaultLootItems;
                foundNewContent = true;
            }

            if (config.loot_settings.skinning_loot_table.Count == 0)
            {
                config.loot_settings.skinning_loot_table = DefaultLootItems;
                foundNewContent = true;
            }

            if (config.loot_settings.fishing_loot_table.Count == 0)
            {
                config.loot_settings.fishing_loot_table = DefaultLootItems;
                foundNewContent = true;
            }

            if (config.loot_settings.metal_detector_loot_table.Count == 0)
            {
                config.loot_settings.metal_detector_loot_table = DefaultLootItems;
                foundNewContent = true;
            }

            if (config.loot_settings.harvesting_loot_table_wild.Count == 0)
            {
                config.loot_settings.harvesting_loot_table_wild = DefaultLootItems;
                foundNewContent = true;
            }

            if (config.loot_settings.harvesting_loot_table_grown.Count == 0)
            {
                config.loot_settings.harvesting_loot_table_grown = DefaultLootItems;
                foundNewContent = true;
            }

            if (config.ultimate_settings.ultimate_mining.trigger_on_item_change && config.ultimate_settings.ultimate_mining.tools_list.Count == 0)
            {
                config.ultimate_settings.ultimate_mining.tools_list = DefaultUltimateToolsList;
                foundNewContent = true;
            }

            if (string.IsNullOrEmpty(config.buff_settings.raid_perk_settings.Lock_Picker_settings.pick_command.Trim()))
            {
                config.buff_settings.raid_perk_settings.Lock_Picker_settings.pick_command = "picklock";
                foundNewContent = true;
            }
            cmd.AddChatCommand(config.buff_settings.raid_perk_settings.Lock_Picker_settings.pick_command.Trim(), this, nameof(SetPicker));

            if (string.IsNullOrEmpty(config.ultimate_settings.ultimate_raiding.command) || string.IsNullOrWhiteSpace(config.ultimate_settings.ultimate_raiding.command))
            {
                config.ultimate_settings.ultimate_raiding.command = "strike";
                foundNewContent = true;
            }

            if (string.IsNullOrEmpty(config.ultimate_settings.ultimate_cooking.command) || string.IsNullOrWhiteSpace(config.ultimate_settings.ultimate_cooking.command))
            {
                config.ultimate_settings.ultimate_cooking.command = "teatime";
                foundNewContent = true;
            }

            if (string.IsNullOrEmpty(config.chat_commands.track_animal_cmd))
            {
                config.chat_commands.track_animal_cmd = "track";
                foundNewContent = true;
            }
            cmd.AddChatCommand(config.chat_commands.track_animal_cmd, this, nameof(TrackAnimal));
            cmd.AddChatCommand(config.buff_settings.forager_settings.command, this, nameof(ForagerChatCMD));
            cmd.AddChatCommand(config.buff_settings.sonar_settings.command, this, nameof(SonarChatCMD));
            cmd.AddConsoleCommand(config.buff_settings.forager_settings.command, this, nameof(ForagerConsoleCMD));
            cmd.AddConsoleCommand(config.buff_settings.sonar_settings.command, this, nameof(SonarConsoleCMD));

            List<YieldTypes> yieldTypes = Pool.Get<List<YieldTypes>>();
            yieldTypes.AddRange(Enum.GetValues(typeof(YieldTypes)).Cast<YieldTypes>());

            foreach (var yieldType in yieldTypes)
            {
                float value;
                if (!config.base_yield_settings.multipliers.TryGetValue(yieldType, out value))
                {
                    config.base_yield_settings.multipliers.Add(yieldType, value = 1);
                    foundNewContent = true;
                }
                if (value < 1 || value > 1) BaseYieldOverrides.Add(yieldType, value);
            }

            if (config.base_yield_settings.adjust_base_yield && BaseYieldOverrides.Count > 0)
            {
                string message = $"Adjusting Yields for:\n";
                foreach (var type in BaseYieldOverrides)
                {
                    message += $"- {type.Key}: {type.Value}x\n";
                }
                Puts(message);
            }

            if (config.buff_settings.tea_looter_settings.containers.IsNullOrEmpty())
            {
                config.buff_settings.tea_looter_settings.containers = DefaultTeaContainers;
                foundNewContent = true;
            }

            if (config.buff_settings.tea_looter_settings.TeaDropTable.IsNullOrEmpty())
            {
                config.buff_settings.tea_looter_settings.TeaDropTable = DefaultTeaWeights;
                foundNewContent = true;
            }

            if (config.buff_settings.forager_settings.displayColours.IsNullOrEmpty())
            {
                config.buff_settings.forager_settings.displayColours = DefaultForagerColours;
                foundNewContent = true;
            }
            if (config.ultimate_settings.ultimate_cooking.tea_mods.IsNullOrEmpty())
            {
                config.ultimate_settings.ultimate_cooking.tea_mods = DefaultCookingUltimateMods;
                foundNewContent = true;
            }
            if (string.IsNullOrEmpty(config.buff_settings.raid_perk_settings.Trap_Spotter_settings.command))
            {
                config.buff_settings.raid_perk_settings.Trap_Spotter_settings.command = "traps";
                foundNewContent = true;
            }
            if (string.IsNullOrEmpty(config.buff_settings.raid_perk_settings.Loot_Spotter_settings.command))
            {
                config.buff_settings.raid_perk_settings.Loot_Spotter_settings.command = "crates";
                foundNewContent = true;
            }

            if (config.buff_settings.raid_perk_settings.Trap_Spotter_settings.trap_colours.IsNullOrEmpty())
            {
                config.buff_settings.raid_perk_settings.Trap_Spotter_settings.trap_colours = DefaultSpotterCols;
                foundNewContent = true;
            }

            if (config.prestige_settings.levels == null || config.prestige_settings.levels.Count == 0)
            {
                config.prestige_settings.Initialize();
                foundNewContent = true;
            }

            if (config.ultimate_settings.ultimate_raiding.use_real_MLRS_entity)
            {
                //MLRSRepairTimer = timer.Once(10, () => { });
                mlrs = BaseNetworkable.serverEntities.OfType<MLRS>()?.FirstOrDefault();
                if (mlrs == null)
                {
                    Puts("No MLRS found on map. Disabling option to use for raiding ultimate.");
                    config.ultimate_settings.ultimate_raiding.use_real_MLRS_entity = false;
                    foundNewContent = true;
                }
            }

            var urls = DefaultUrls;
            foreach (var url in urls)
                if (!config.misc_settings.videoURLs.ContainsKey(url.Key))
                {
                    config.misc_settings.videoURLs.Add(url.Key, url.Value);
                    foundNewContent = true;
                }

            if (!config.tools_black_white_list_settings.extendedMag_weapon_blacklist.Contains("mini_crossbow.entity"))
            {
                config.tools_black_white_list_settings.extendedMag_weapon_blacklist.Add("mini_crossbow.entity");
                foundNewContent = true;
            }

            if (!config.tools_black_white_list_settings.electricalComponentSettings.comp_blacklist.Contains("command.block"))
            {
                config.tools_black_white_list_settings.electricalComponentSettings.comp_blacklist.Add("command.block");
                foundNewContent = true;
            }                

            if (foundNewContent) SaveConfig();

            if (SkillTreeXPEvent != null && SkillTreeXPEvent.IsLoaded) IsSkillTreeXPEventLoaded = true;
            // Chat command stuff
            foreach (var chatcommand in config.chat_commands.score_chat_cmd)
            {
                cmd.AddChatCommand(chatcommand, this, "CheckScoreBoard");
                cmd.AddConsoleCommand(chatcommand, this, "CheckScoreBoardConsole");
            }

            cmd.AddChatCommand(config.ultimate_settings.ultimate_raiding.command, this, nameof(CallRocketStrike));
            cmd.AddChatCommand(config.ultimate_settings.ultimate_cooking.command, this, nameof(AddTeaBuffsCMD));
            cmd.AddChatCommand(config.buff_settings.raid_perk_settings.Trap_Spotter_settings.command, this, nameof(SearchForTraps));
            cmd.AddConsoleCommand(config.buff_settings.raid_perk_settings.Trap_Spotter_settings.command, this, nameof(SearchForTrapsConsoleCMD));
            cmd.AddChatCommand(config.buff_settings.raid_perk_settings.Loot_Spotter_settings.command, this, nameof(SearchForLoot));
            cmd.AddConsoleCommand(config.buff_settings.raid_perk_settings.Loot_Spotter_settings.command, this, nameof(SearchForLootConsoleCMD));

            foreach (var chatcommand in config.chat_commands.chat_cmd)
            {
                cmd.AddChatCommand(chatcommand, this, "SendMenuCMD");
            }

            CreatePrestigeGroups();

            // Image lib stuff


            bool workBenchSkillEnabled = false;
            foreach (var tree in config.trees)
            {
                foreach (var node in tree.Value.nodes)
                {
                    if (!node.Value.enabled) continue;
                    if (node.Value.buff_info.Key == Buff.Human_Workbench) workBenchSkillEnabled = true;

                    if (!NodeIconDirectory.TryGetValue(node.Key, out var iconData)) NodeIconDirectory.Add(node.Key, iconData = new IconInfo(node.Value.icon_url, node.Value.skin));
                    else
                    {
                        iconData.iconID = node.Value.skin;
                        iconData.url = node.Value.icon_url;
                    }
                    if (iconData.iconID == 0 && !string.IsNullOrEmpty(iconData.url))
                        loadOrder.Add(node.Key, iconData.url);
                    if (node.Value.buff_info.Key == Buff.ExtraPockets && string.IsNullOrEmpty(ExtraPocketsImg.Key))
                    {
                        ExtraPocketsImg = new KeyValuePair<string, string>("ExtraPocketsButton", node.Value.icon_url);
                        loadOrder.Add("ExtraPocketsButton", node.Value.icon_url);
                    }

                    if (node.Value.buff_info.Key == Buff.ExtraPockets && ExtraPocketsImgSkin.Value == 0)
                        ExtraPocketsImgSkin = new KeyValuePair<string, ulong>(node.Key, node.Value.skin);

                    if (!BuffBuffType.ContainsKey(node.Value.buff_info.Key)) BuffBuffType.Add(node.Value.buff_info.Key, node.Value.buff_info.Value);
                }
            }
            if (workBenchSkillEnabled) SpawnWorkbenchs();

            if (BasePlayer.activePlayerList.Count > 0)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    HandleNewConnection(player);
                }
            }

            if (!config.buff_settings.boat_turbo_on_mount) cmd.AddChatCommand(config.chat_commands.turbo_cmd, this, nameof(ChangeBoatSpeedCMD));
            if (!config.chat_commands.use_input_key_boat)
            {
                Unsubscribe("OnPlayerInput");
            }
            if (config.xp_settings.xp_sources.Mission == 0) Unsubscribe("OnMissionSucceeded");
            if (config.xp_settings.xp_sources.Win_HungerGames == 0) Unsubscribe("HGWinner");
            if (config.xp_settings.xp_sources.Win_ScubaArena == 0) Unsubscribe("SAWinner");
            if (config.xp_settings.xp_sources.Win_Skirmish == 0)
            {
                Unsubscribe("SAWinner");
                Unsubscribe("SAWinners");
            }
            loadOrder.Add("arrow_down_double", "https://www.dropbox.com/s/a1aysr6qmcuinyb/arrow_down_double.png?dl=1");
            loadOrder.Add("arrow_left_double", "https://www.dropbox.com/s/tx5vgr3m9bujvde/arrow_left_double.png?dl=1");
            loadOrder.Add("arrow_right_double", "https://www.dropbox.com/s/6ns3a41qwdn74h8/arrow_right_double.png?dl=1");
            loadOrder.Add("arrow_up_double", "https://www.dropbox.com/s/yqygkxfsyput635/arrow_up_double.png?dl=1");
            loadOrder.Add("arrow_down_single", "https://www.dropbox.com/s/jqi9ulzgj8pq024/arrow_down_single.png?dl=1");
            loadOrder.Add("arrow_left_single", "https://www.dropbox.com/s/ht2pol52oc4q5k9/arrow_left_single.png?dl=1");
            loadOrder.Add("arrow_right_single", "https://www.dropbox.com/s/aixjnroopq9vess/arrow_right_single.png?dl=1");
            loadOrder.Add("arrow_up_single", "https://www.dropbox.com/s/ud9fnx07bv724v2/arrow_up_single.png?dl=1");
            if (loadOrder.Count > 0)
            {
                Puts($"Loading {loadOrder.Count} images into ImageLibrary");
                if (ImageLibrary != null && ImageLibrary.IsLoaded) ImageLibrary.Call("ImportImageList", this.Name, loadOrder, 0ul, config.general_settings.replace_on_reload, new Action(SkillTreeImagesReady));
            }
            else
            {
                NextTick(() => SkillTreeImagesReady());
            }
            LoadBuffs();
            UpdateScoreBoard(true);

            cmd.AddChatCommand(config.ultimate_settings.ultimate_mining.find_node_cmd, this, "TriggerMiningUltimateFromCMD");
            cmd.AddChatCommand(config.ultimate_settings.ultimate_harvesting.gene_chat_command, this, "SetPlantGenes");

            if (!string.IsNullOrEmpty(config.xp_settings.xp_display_col_modified)) ModifiedCol = config.xp_settings.xp_display_col_modified;
            else ModifiedCol = "00b6ff";

            if (!string.IsNullOrEmpty(config.xp_settings.xp_display_col_xp_event_modified)) STXPEventModifiedCol = config.xp_settings.xp_display_col_xp_event_modified;
            else STXPEventModifiedCol = "c900ff";

            if (!string.IsNullOrEmpty(config.xp_settings.xp_display_col_unmodified)) UnmodifiedCol = config.xp_settings.xp_display_col_unmodified;
            else UnmodifiedCol = "ffffff";

            CheckHarvestingBlacklist = config.buff_settings.harvest_yield_blacklist.Count > 0;

            if (!config.ultimate_settings.ultimate_mining.trigger_on_item_change) Unsubscribe(nameof(OnActiveItemChanged));

            SetupRaidUltimateStatics();

            UWB_Anchor_Min = config.buff_settings.underwaterSettings.anchor_min;
            UWB_Anchor_Max = config.buff_settings.underwaterSettings.anchor_max;
            UWB_Offset_Min = config.buff_settings.underwaterSettings.offset_min;
            UWB_Offset_Max = config.buff_settings.underwaterSettings.offset_max;

            if (config.misc_settings.log_player_xp_gain)
            {
                LogTimer = timer.Every(60f, () => AddLogs());
            }

            if (!config.buff_settings.clone_yield) Unsubscribe(nameof(CanTakeCutting));

            if (!config.thirdPartyPluginSettings.survivalArenaSettings.disable_skinning_ultimate_buff_on_join && !config.thirdPartyPluginSettings.paintballSettings.disable_skinning_ultimate_buff_on_join) Unsubscribe(nameof(EMOnEventJoined));

            if (!config.buff_settings.prevent_flyhack_kick_fall_damage) Unsubscribe(nameof(OnPlayerViolation));

            foreach (var kvp in config.trees)
            {
                foreach (var node in kvp.Value.nodes)
                {
                    if (!string.IsNullOrEmpty(node.Value.required_skill))
                    {
                        var maxLevel = FindNodeMaxLevel(node.Value.required_skill);
                        if (maxLevel > 0 && !TrackedRequiredNodes.ContainsKey(node.Value.required_skill))
                        {
                            TrackedRequiredNodes.Add(node.Value.required_skill, maxLevel);
                        }
                    }
                }
            }
            Puts($"Tracking {TrackedRequiredNodes.Count} required nodes.");

            Subscribe(nameof(OnPluginLoaded));
            foreach (var tree in config.trees)
                if (tree.Value.enabled)
                    Trees.Add(tree.Key);
        }

        int FindNodeMaxLevel(string searchName)
        {
            foreach (var kvp in config.trees)
            {
                foreach (var node in kvp.Value.nodes)
                {
                    if (node.Key == searchName)
                    {
                        return node.Value.max_level;
                    }
                }
            }
            return 0;
        }

        int GetNodeMaxLevel(string nodeName)
        {
            if (!TrackedRequiredNodes.TryGetValue(nodeName, out var level))
            {
                return 0;
            }
            return level;
        }

        Dictionary<string, int> TrackedRequiredNodes = new Dictionary<string, int>();

        Dictionary<ulong, StringBuilder> Logs = new Dictionary<ulong, StringBuilder>();
        void AddLogs()
        {
            foreach (var kvp in Logs)
            {
                LogToFile($"XP_Logs_{kvp.Key}", kvp.Value.ToString(), this, false, true);
            }
            Logs.Clear();
        }

        void AddXPLog(BasePlayer player, string text)
        {
            if (!Logs.TryGetValue(player.userID, out var sb)) Logs.Add(player.userID, sb = new StringBuilder());
            sb.AppendLine(text);
        }

        Dictionary<string, ulong> ArrowSkins = new Dictionary<string, ulong>()
        {
            ["arrow_down_double"] = 2873060319,
            ["arrow_left_double"] = 2873060538,
            ["arrow_right_double"] = 2873060617,
            ["arrow_up_double"] = 2873060659,
            ["arrow_down_single"] = 2873060760,
            ["arrow_left_single"] = 2873060807,
            ["arrow_right_single"] = 2873060847,
            ["arrow_up_single"] = 2873060907
        };

        private bool ImagesLoaded;

        private void SkillTreeImagesReady()
        {
            loadOrder.Clear();
            loadOrder = null;
            ImagesLoaded = true;
            Puts($"Loaded all images for SkillTree.");
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (buffDetails.ContainsKey(player.userID) && buffDetails[player.userID].ContainsBuff(Buff.ExtraPockets) && pcdData.pEntity.ContainsKey(player.userID) && pcdData.pEntity[player.userID].extra_pockets_button) SendExtraPocketsButton(player);
            }
        }

        void OnPlayerConnected(BasePlayer player) => HandleNewConnection(player);

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            DoClear(player, config.buff_settings.removePermissionsOnDisconnect);
            LoggingOff(player, true);
        }

        void DoClear(BasePlayer player, bool removePerms)
        {
            UpdatePlayerData(player.userID, removePerms);
            TreeData.Remove(player.userID);
            //if (buffDetails.ContainsKey(player.userID)) buffDetails[player.userID].buff_values.Clear();
            Interface.Oxide.CallHook("STOnUnloadPlayerData", player);
            buffDetails.Remove(player.userID);
            notifiedPlayers.Remove(player.userID);
            player.metabolism.calories.max = 500f;
            player.metabolism.hydration.max = 250f;
            player.SendNetworkUpdate();
            RemoveFromAllBuffs(player.userID);
            RemoveAnimalBuff(player);
            try { DestroyRegen(player); } catch { Puts($"Error: Failed to remove regen from {player.displayName} [{player.userID}]"); }
            try { DestroyAwareness(player); } catch { Puts($"Error: Failed to remove awareness from {player.displayName} [{player.userID}]"); }
            try { DestroyWaterBreathing(player); } catch { Puts($"Error: Failed to remove Water breathing from {player.displayName} [{player.userID}]"); }
            try { DestroyRaidBehaviour(player); } catch { Puts($"Error: Failed to remove Raid behaviour from {player.displayName} [{player.userID}]"); }
            try { DestroyInstantUntie(player); } catch { Puts($"Error: Failed to remove Instant untie from {player.displayName} [{player.userID}]"); }
            try { DestroyComfortSkill(player); } catch { Puts($"Error: Failed to remove Comfort from {player.displayName} [{player.userID}]"); Puts($"Error: Failed to remove regen from {player.displayName} [{player.userID}]"); }
            try { DestroyMobileWorkbench(player); } catch { Puts($"Error: Failed to remove Mobile workbench from {player.displayName} [{player.userID}]"); }
            RemovePerms(player.UserIDString, removePerms);
        }

        // UserIDString, Node name, List of perms.
        void RemovePerms(string id, bool removePerms)
        {
            Dictionary<string, Dictionary<string, string>> perms;
            if (Tracked_perms.TryGetValue(id, out perms))
            {
                if (removePerms)
                {
                    foreach (var node in perms.Values)
                    {
                        foreach (var perm in node.Keys)
                        {
                            permission.RevokeUserPermission(id, perm.Trim());
                        }
                    }
                }                
                Tracked_perms.Remove(id);
            }
        }

        #endregion

        #region Experience

        [ChatCommand("updatexptable")]
        void UpdateXPTable(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;
            if (config.level == null) config.level = new Configuration.ExperienceInfo();
            config.level.CalculateTable(config.general_settings.max_player_level > 0 ? config.general_settings.max_player_level : 100);
            SaveConfig();
            PrintToChat(player, "Updated xp table.");
        }

        [ConsoleCommand("updatexptable")]
        void UpdateXPTableConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;
            if (config.level == null) config.level = new Configuration.ExperienceInfo();
            config.level.CalculateTable(config.general_settings.max_player_level > 0 ? config.general_settings.max_player_level : 100);
            SaveConfig();
            Puts("Updated xp table.");
        }

        int CheckLevel(BasePlayer player)
        {
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData)) return 0;
            var level = config.level.GetLevel(playerData.xp);
            // If we are max level, we exit the method with the max level.
            if (config.general_settings.max_player_level > 0 && playerData.current_level >= config.general_settings.max_player_level) return config.general_settings.max_player_level;
            //We run the following block of code if our current level is less than the calculated level of our xp.
            if (playerData.current_level < level)
            {
                var pointsPerLevel = GetPointsPerLevel(player.UserIDString);
                var max_skill_points = GetMaxSkillPoints(player);
                // If the configured max level is 0 OR our new level is less than/equal to the max level, we run the following code block.
                if (config.general_settings.max_player_level == 0 || level <= config.general_settings.max_player_level)
                {

                    // We check to see if the highest level achieved by the player is less than the new level.
                    Player.Message(player, string.Format(lang.GetMessage("LevelEarn", this, player.UserIDString), playerData.achieved_level < level ? (pointsPerLevel * (level - playerData.current_level)) : 0, level), config.misc_settings.ChatID);
                    if (config.notification_settings.discordSettings.send_level_up) SendDiscordMsg(string.Format(lang.GetMessage("LevelEarnDiscord", this), player.displayName, player.UserIDString, level));
                    if (playerData.achieved_level < level)
                    {
                        // After confirming the achieved level is < level, we check to see if the player has hit the maximum number of skill points, or if config max skill points is 0, then award them with skill points.
                        if (max_skill_points == 0 || (playerData.current_level * pointsPerLevel + GetStartingSkillPoints(player.UserIDString) < max_skill_points)) playerData.available_points += pointsPerLevel * (level - playerData.current_level);
                        // We set this current level as the maximum level achieved. This is to prevent skill points being awarded if they have reached this level before and somehow lost xp/level.
                        playerData.achieved_level = level;
                    }
                    // Increases the current level of the player to the new level.
                    Interface.CallHook("STOnPlayerLevel", player, playerData.current_level, level);
                    int currentLevel = playerData.current_level;
                    playerData.current_level = level;
                    if (playerData.prestige_level == 0 || !config.prestige_settings.ignore_level_rewards) GiveLevelRewards(player, level, level - currentLevel);

                    if (config.notification_settings.notifySettings.level_up_notification.Key != null)
                    {
                        var str = string.Format(lang.GetMessage(config.notification_settings.notifySettings.level_up_notification.Key, this, player.UserIDString), level, playerData.available_points);
                        SendNotify(player, str, config.notification_settings.notifySettings.level_up_notification.Value);
                    }
                    if (config.notification_settings.notificationSystemSettings.SendLevelUp)
                    {
                        SendNotificationSystemMsg(player.userID, string.Format(lang.GetMessage("NSLevelUpTitle", this, player.UserIDString), level), string.Format(lang.GetMessage("NSLevelUpBody", this, player.UserIDString), level, pointsPerLevel, playerData.available_points));
                    }
                }
                // Otherwise we assume we are hitting max level.
                else
                {
                    // We check the amount of levels the player gained from max level.
                    var levels_gained = config.general_settings.max_player_level - playerData.current_level;
                    Player.Message(player, string.Format(lang.GetMessage("LevelEarn", this, player.UserIDString), pointsPerLevel * levels_gained, config.general_settings.max_player_level), config.misc_settings.ChatID);
                    if (config.notification_settings.discordSettings.send_level_up) SendDiscordMsg(string.Format(lang.GetMessage("LevelEarnDiscord", this), player.displayName, player.UserIDString, config.general_settings.max_player_level));
                    // We check to see if the highest level achieved by the player is less than max level.
                    if (playerData.achieved_level < config.general_settings.max_player_level)
                    {
                        // After confirming the achieved level is < max level, we check to see if the player has hit the maximum number of skill points, or if config max skill points is 0, then award them with skill points.
                        if (max_skill_points == 0 || (playerData.current_level * pointsPerLevel < max_skill_points)) playerData.available_points += pointsPerLevel * levels_gained;
                        // We set this current level as the maximum level achieved. This is to prevent skill points being awarded if they have reached this level before and somehow lost xp/level.
                        playerData.achieved_level = config.general_settings.max_player_level;
                        //We set the players level to max level.
                        playerData.current_level = config.general_settings.max_player_level;
                        if (playerData.prestige_level == 0 || !config.prestige_settings.ignore_level_rewards) GiveLevelRewards(player, config.general_settings.max_player_level, levels_gained);
                        if (config.notification_settings.notifySettings.level_up_notification.Key != null)
                        {
                            var str = string.Format(lang.GetMessage(config.notification_settings.notifySettings.level_up_notification.Key, this, player.UserIDString), config.general_settings.max_player_level, playerData.available_points);
                            SendNotify(player, str, config.notification_settings.notifySettings.level_up_notification.Value);
                        }

                        if (config.notification_settings.notificationSystemSettings.SendLevelUpMax)
                        {
                            SendNotificationSystemMsg(player.userID, string.Format(lang.GetMessage("NSLevelUpTitleMax", this, player.UserIDString), config.general_settings.max_player_level), string.Format(lang.GetMessage("NSLevelUpBodyMax", this, player.UserIDString), config.general_settings.max_player_level, pointsPerLevel, playerData.available_points) + (config.prestige_settings.enabled ? lang.GetMessage("NSPrestigeUnlocked", this, player.UserIDString) : null));
                        }
                    }
                }
                // Sends a network effect ot the player only if configured to.
                if (!string.IsNullOrEmpty(config.effect_settings.level_effect)) EffectNetwork.Send(new Effect(config.effect_settings.level_effect, player.transform.position, player.transform.position), player.net.connection);
            }
            // We assume the players current level is higher than it should be and adjust it back to the new level. This could be due to an xp change.
            else if (playerData.current_level != level && (config.general_settings.max_player_level == 0 || config.general_settings.max_player_level <= level)) playerData.current_level = level;
            return level;
        }

        void SendNotify(BasePlayer player, string message, int type)
        {
            if (UINotify == null || !UINotify.IsLoaded || string.IsNullOrEmpty(message)) return;
            UINotify.Call("SendNotify", player.userID.Get(), type, message);
        }

        void SendNotificationSystemMsg(ulong id, string title, string message, List<(string, bool)> commands = null)
        {
            if (NotificationSystem == null || !NotificationSystem.IsLoaded) return;
            //void Add(ulong id, string title, string body, int itemID, ulong picID = 0, string sprite = null, List<string> commands = null)
            NotificationSystem.Call("Add", id, title, message, 1414245162, config.notification_settings.notificationSystemSettings.icon, null, commands);
        }

        void GiveRewards(BasePlayer player, int level)
        {
            try
            {
                LevelReward _rewards;
                if (config.general_settings.level_rewards.TryGetValue(level, out _rewards))
                {
                    foreach (var reward in _rewards.reward_commands)
                    {
                        string[] command_string = reward.Key.Split(' ');
                        if (command_string != null && command_string.Length > 0)
                        {
                            if (command_string.Length == 1)
                            {
                                try
                                {
                                    var str = reward.Key.Replace("{name}", player.displayName);
                                    str = str.Replace("{id}", player.UserIDString);
                                    //rust.RunServerCommand(str);
                                    Server.Command(str);
                                }
                                catch
                                {
                                    //LogToFile("CommandFailureLog", $"[{DateTime.Now}] Failed to run command for {player.displayName}[{player.userID}] - Command: {reward.Key}", this, true);
                                }
                            }

                            else
                            {
                                string command = command_string[0];
                                List<string> args = Pool.Get<List<string>>();
                                foreach (var arg in command_string.Skip(1))
                                {
                                    if (arg.Contains("{id}")) args.Add(arg.Replace("{id}", player.UserIDString));
                                    else if (arg.Contains("{name}")) args.Add(arg.Replace("{name}", player.displayName));
                                    else args.Add(arg);
                                }
                                if (command.Equals("say", StringComparison.OrdinalIgnoreCase))
                                {
                                    try
                                    {
                                        Server.Command(command, string.Join(" ", args));
                                    }
                                    catch
                                    {
                                        //LogToFile("CommandFailureLog", $"[{DateTime.Now}] Failed to run command for {player.displayName}[{player.userID}] - Command: {command} {string.Join(" ", args)}", this, true);
                                    }
                                }
                                else
                                {
                                    try
                                    {
                                        Server.Command(command + " " + string.Join(" ", args));
                                    }
                                    catch
                                    {
                                        //LogToFile("CommandFailureLog", $"[{DateTime.Now}] Failed to run command for {player.displayName}[{player.userID}] - Command: {command} {string.Join(" ", args)}", this, true);
                                    }
                                }

                                if (!string.IsNullOrEmpty(reward.Value)) Player.Message(player, reward.Value, config.misc_settings.ChatID);
                                Pool.FreeUnmanaged(ref args);
                            }
                        }
                    }
                }
                if (SkillTreeXPEvent != null && SkillTreeXPEvent.IsLoaded)
                {
                    SkillTreeXPEventRunning = Convert.ToBoolean(SkillTreeXPEvent.Call("IsXPEventRunning"));
                }
            }
            catch (Exception ex)
            {
                Puts($"Encountered an error while trying to award {player.displayName} [{player.userID}] with level rewards. Error: {ex.Message}");
            }
        }

        void RunResetCommands(string playerID, int level_achieved)
        {
            if (config.general_settings.level_rewards == null || config.general_settings.level_rewards.Count == 0) return;
            foreach (var level in config.general_settings.level_rewards)
            {
                if (level.Key > level_achieved || level.Value.reward_commands == null || level.Value.reset_commands == null) continue;
                foreach (var _command in level.Value.reset_commands)
                {
                    string error = string.Empty;
                    try
                    {
                        error = "RunResetCommands Error 1";
                        var command_string = _command.Split(' ');
                        if (command_string == null || command_string.Length < 2) continue;

                        error = "RunResetCommands Error 2";
                        string command = command_string[0];
                        List<string> args = Pool.Get<List<string>>();
                        foreach (var arg in command_string.Skip(1))
                        {
                            if (arg.Contains("{id}")) args.Add(arg.Replace("{id}", playerID));
                            else if (arg.Contains("{name}"))
                            {
                                string name = null;
                                foreach (var player in BasePlayer.allPlayerList)
                                {
                                    if (player.UserIDString == playerID)
                                    {
                                        name = player.displayName;
                                        break;
                                    }
                                }
                                args.Add(arg.Replace("{name}", name ?? playerID));
                            }
                            else args.Add(arg);
                        }

                        error = "RunResetCommands Error 3";
                        if (args == null || args.Count < 1)
                        {
                            error = "RunResetCommands Error 4";
                            try
                            {
                                Server.Command(command);
                            }
                            catch
                            {
                                //LogToFile("CommandFailureLog", $"[{DateTime.Now}] Failed to run command for {player.displayName}[{player.userID}] - Command: {command}", this, true);
                            }
                        }
                        else if (command.Equals("say", StringComparison.OrdinalIgnoreCase))
                        {
                            error = "RunResetCommands Error 5";
                            try
                            {
                                Server.Command(command, string.Join(" ", args));
                            }
                            catch
                            {
                                //LogToFile("CommandFailureLog", $"[{DateTime.Now}] Failed to run command for {player.displayName}[{player.userID}] - Command: {command} args: {string.Join(" ", args)}", this, true);
                            }
                        }
                        else
                        {
                            error = "RunResetCommands Error 6";
                            try
                            {
                                Server.Command(command + " " + string.Join(" ", args));
                            }
                            catch
                            {
                                //LogToFile("CommandFailureLog", $"[{DateTime.Now}] Failed to run command for {player.displayName}[{player.userID}] - Command: {command} args: {string.Join(" ", args)}", this, true);
                            }
                        }

                        Pool.FreeUnmanaged(ref args);
                    }
                    catch (Exception ex)
                    {
                        LogToFile("RunResetCommands_Errors", error + $"Exception: {ex.Message}", this, true, true);
                    }
                }
            }
        }

        [ConsoleCommand("stgiveitem")]
        void STGiveItem(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, perm_admin)) return;
            //stgiveitem <id> <shortname> <quantity> <skinID> <displayName>
            if (arg.Args == null || arg.Args.Length < 4)
            {
                arg.ReplyWith(lang.GetMessage("stgiveitemUsage", this, player?.UserIDString ?? null));
                return;
            }
            if (!arg.Args[0].IsSteamId())
            {
                arg.ReplyWith(string.Format(lang.GetMessage("stgiveitemInvalidID", this, player?.UserIDString ?? null), arg.Args[0]));
                return;
            }
            var target = FindPlayerByID(arg.Args[0], player ?? null);
            if (target == null)
            {
                arg.ReplyWith(string.Format(lang.GetMessage("stgiveitemNoPlayerFound", this, player?.UserIDString ?? null), arg.Args[0]));
                return;
            }
            var def = ItemManager.FindItemDefinition(arg.Args[1]);
            if (def == null || string.IsNullOrEmpty(def.shortname))
            {
                arg.ReplyWith(string.Format(lang.GetMessage("stgiveitemInvalidShortname", this, player?.UserIDString ?? null), arg.Args[1]));
                return;
            }

            if (!arg.Args[2].IsNumeric())
            {
                arg.ReplyWith(string.Format(lang.GetMessage("stgiveitemQuantityInvalid", this, player?.UserIDString ?? null), arg.Args[2]));
                return;
            }
            var quantity = Convert.ToInt32(arg.Args[2]);
            quantity = Math.Max(quantity, 1);

            if (!arg.Args[3].IsNumeric())
            {
                arg.ReplyWith(string.Format(lang.GetMessage("stgiveitemSkinInvalid", this, player?.UserIDString ?? null), arg.Args[3]));
                return;
            }

            var skinID = Convert.ToUInt64(arg.Args[3]);

            string displayName = null;
            if (arg.Args.Length > 4) displayName = string.Join(" ", arg.Args.Skip(4));
            var item = ItemManager.CreateByName(arg.Args[1], quantity, skinID);
            if (!string.IsNullOrEmpty(displayName)) item.name = displayName;
            target.GiveItem(item);
            arg.ReplyWith($"Gave {item.amount}x {item.name ?? item.info.displayName.english} to {target.displayName}");
        }

        void GiveLevelRewards(BasePlayer player, int newLevel, int levelsGained = 1)
        {
            if (levelsGained == 0) return;
            else if (levelsGained == 1) GiveRewards(player, newLevel);
            else
            {
                int startLevel = newLevel - levelsGained;
                for (int i = startLevel + 1; i < newLevel + 1; i++)
                {
                    GiveRewards(player, i);
                }
            }
        }

        #endregion

        #region Night time xp announcement

        bool IsInvoking = false;
        void SetupNightBonusAnnouncement()
        {
            if (!config.xp_settings.night_settings.announce_at_night || !NTAnnouncementRequired()) return;
            ServerMgr.Instance.InvokeRepeating(nameof(CheckforNightTime), 30, 30);
            IsInvoking = true;
        }

        bool NTAnnouncementRequired()
        {
            return
                config.xp_settings.night_settings.night_xp_gain_modifier != 1 ||
                config.xp_settings.night_settings.night_mining_yield_modifier != 1 ||
                config.xp_settings.night_settings.night_skinning_yield_modifier != 1 ||
                config.xp_settings.night_settings.night_woodcutting_yield_modifier != 1;
        }

        bool WasNight = false;
        void CheckforNightTime()
        {
            if (TOD_Sky.Instance.IsNight)
            {
                if (WasNight) return;
                WasNight = true;
                
                foreach (var player in BasePlayer.activePlayerList)                
                    player.SendConsoleCommand("gametip.showgametip", lang.GetMessage("NightXPStartAnnounce", this, player.UserIDString));

                ServerMgr.Instance.Invoke(() =>
                {
                    foreach (var player in BasePlayer.activePlayerList)
                        player.SendConsoleCommand("gametip.hidegametip");
                }, config.xp_settings.night_settings.announcement_duration);
            }
            else
            {
                if (!WasNight) return;
                WasNight = false;

                foreach (var player in BasePlayer.activePlayerList)
                    player.SendConsoleCommand("gametip.showgametip", lang.GetMessage("NightXPStopAnnounce", this, player.UserIDString));

                ServerMgr.Instance.Invoke(() =>
                {
                    foreach (var player in BasePlayer.activePlayerList)
                        player.SendConsoleCommand("gametip.hidegametip");
                }, config.xp_settings.night_settings.announcement_duration);
            }
        }

        #endregion

        #region Helpers      

        List<ItemDefinition> ItemDefinitions;
        List<ItemDefinition> GetCleanItemDefinitions()
        {
            if (ItemDefinitions != null) return ItemDefinitions;

            ItemDefinitions = new List<ItemDefinition>();
            foreach (var def in GetCleanItemDefinitions())
            {
                if (def.steamItem == null && def.steamDlc == null) ItemDefinitions.Add(def);
            }

            return ItemDefinitions;
        }

        void SendPlayerMessage(BasePlayer player, string message, MessageType type)
        {
            if (type == MessageType.None) return;
            if (type == MessageType.Chat) Player.Message(player, message, config.misc_settings.ChatID);
            SendMessage(player, message, GetMessageCol(type));

        }

        string GetMessageCol(MessageType type)
        {
            switch (type)
            {
                case MessageType.CUISuccess: return config.misc_settings.messageSettings.cuiCols.CUISuccess;
                case MessageType.CUIWarn: return config.misc_settings.messageSettings.cuiCols.CUIWarn;
                default: return config.misc_settings.messageSettings.cuiCols.CUINormal;
            }
        }

        List<Item> AllItems(BasePlayer player)
        {
            List<Item> result = Pool.Get<List<Item>>();

            if (player.inventory.containerMain?.itemList != null)
                result.AddRange(player.inventory.containerMain.itemList);

            if (player.inventory.containerBelt?.itemList != null)
                result.AddRange(player.inventory.containerBelt.itemList);

            if (player.inventory.containerWear?.itemList != null)
                result.AddRange(player.inventory.containerWear.itemList);

            return result;
        }

        int GetPointsPerLevel(string userid)
        {
            int result = config.general_settings.points_per_level;
            foreach (var kvp in config.general_settings.points_per_level_override)
            {
                if (kvp.Value <= result || !permission.UserHasPermission(userid, "skilltree." + kvp.Key)) continue;
                result = kvp.Value;
            }
            return result;
        }

        string FormatUserIDFromPath(string path)
        {
            var s = path.Split(Path.DirectorySeparatorChar);
            return s[s.Length - 1].Split('.')[0];
        }

        bool CanCombatUltimateTrigger(BasePlayer player, HitInfo info, Rust.DamageType damageType)
        {
            if (!config.ultimate_settings.ultimate_combat.weapon_blacklist.IsNullOrEmpty() && info.WeaponPrefab != null && config.ultimate_settings.ultimate_combat.weapon_blacklist.Contains(info.WeaponPrefab.ShortPrefabName)) return false;
            if (damageType == Rust.DamageType.Heat && !config.ultimate_settings.ultimate_combat.heal_from_fire_damage) return false;
            return true;
        }

        private static List<T> FindResourceEntitiesOfType<T>(Vector3 pos, float radius, int m = -1) where T : EntityComponent<BaseEntity>
        {
            int hits = Physics.OverlapSphereNonAlloc(pos, radius, Vis.colBuffer, m, QueryTriggerInteraction.Collide);
            List<T> entities = new List<T>();
            for (int i = 0; i < hits; i++)
            {
                var entity = Vis.colBuffer[i]?.ToBaseEntity();
                if (entity is T) entities.Add(entity as T);
                Vis.colBuffer[i] = null;
            }
            return entities;
        }

        private static List<T> FindEntitiesOfType<T>(Vector3 pos, float radius, int m = -1) where T : BaseEntity
        {
            int hits = Physics.OverlapSphereNonAlloc(pos, radius, Vis.colBuffer, m, QueryTriggerInteraction.Collide);
            List<T> entities = Pool.Get<List<T>>();
            for (int i = 0; i < hits; i++)
            {
                var entity = Vis.colBuffer[i]?.ToBaseEntity();
                if (entity is T) entities.Add(entity as T);
                Vis.colBuffer[i] = null;
            }
            return entities;
        }

        private static List<BasePlayer> FindNearbyTeamMates(BasePlayer player, float distance)
        {
            if (player.Team == null || player.Team.members.Count == 0)
            {
                var list = Pool.Get<List<BasePlayer>>();
                list.Add(player);
                return list;
            }
            if (distance < 500) return FindEntitiesOfType<BasePlayer>(player.transform.position, distance);
            List<BasePlayer> result = Pool.Get<List<BasePlayer>>();
            foreach (var member in player.Team.members)
            {
                var p = BasePlayer.FindByID(member);
                if (p == null || !InRange(player.transform.position, p.transform.position, distance)) continue;
                result.Add(p);
            }
            return result;
        }

        void GiveItem(BasePlayer player, Item item)
        {
            if (item == null) return;
            if (player == null)
            {
                item.Remove();
                return;
            }

            try
            {
                if (player.inventory.containerMain.itemList != null)
                {
                    var moved = false;
                    int amount = item.amount;
                    foreach (var _item in player.inventory.containerMain.itemList)
                    {
                        if (_item.info.stackable < 2) continue;
                        if (_item.skin == item.skin && _item.info.shortname == item.info.shortname)
                        {
                            if ((item.name != null || _item.name != null) && item.name != _item.name) continue;
                            if (item.MoveToContainer(player.inventory.containerMain, _item.position)) moved = true;
                        }
                        if (moved)
                        {
                            player.Command("note.inv", new object[] { item.info.itemid, amount, item.name != null ? item.name : String.Empty, (int)BaseEntity.GiveItemReason.PickedUp });
                            return;
                        }

                    }

                    foreach (var _item in player.inventory.containerBelt.itemList)
                    {
                        if (_item.info.stackable < 2) continue;
                        if (_item.skin == item.skin && _item.info.shortname == item.info.shortname)
                        {
                            if ((item.name != null || _item.name != null) && item.name != _item.name) continue;
                            if (item.MoveToContainer(player.inventory.containerBelt, _item.position)) moved = true;
                        }
                        if (moved)
                        {
                            player.Command("note.inv", new object[] { item.info.itemid, amount, item.name != null ? item.name : String.Empty, (int)BaseEntity.GiveItemReason.PickedUp });
                            return;
                        }

                    }

                    player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
                }
            }
            catch
            {
                player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
            }

        }

        void LoggingOff(BasePlayer player, bool saveData)
        {
            PlayerInfo pi;
            if (!pcdData.pEntity.TryGetValue(player.userID, out pi)) return;
            pi.logged_off = DateTime.Now;
            if (saveData) SavePlayerData(player);

            if (ScoreBoard.data != null && ScoreBoard.data.TryGetValue(player.userID, out var score))
            {
                score.xp = pi.xp;
                score.name = player.displayName;
            }
            pcdData.pEntity.Remove(player.userID);
        }

        void LoggedOn(BasePlayer player, PlayerInfo pi)
        {
            if (pi == null && !pcdData.pEntity.TryGetValue(player.userID, out pi))
            {
                SetupPlayer(player.userID, player.displayName);
                pi = pcdData.pEntity[player.userID];
            }
            if (pi.logged_off == DateTime.MinValue)
            {
                pi.logged_off = DateTime.Now;
                return;
            }
            if (config.rested_xp_settings.rested_xp_enabled)
            {
                var offlineHours = Convert.ToInt32((DateTime.Now - pi.logged_off).TotalHours);
                if (offlineHours > 0)
                {
                    pi.xp_bonus_pool += GetModifiedRestedXP(player, offlineHours * config.rested_xp_settings.rested_xp_per_hour);
                    if (config.rested_xp_settings.rested_xp_pool_max > 0 && pi.xp_bonus_pool > config.rested_xp_settings.rested_xp_pool_max) pi.xp_bonus_pool = config.rested_xp_settings.rested_xp_pool_max;
                    Player.Message(player, string.Format(lang.GetMessage("RestedNotification", this, player.UserIDString), config.rested_xp_settings.rested_xp_rate * 100, Math.Round(pi.xp_bonus_pool, config.xp_settings.xp_rounding)), config.misc_settings.ChatID);
                }
            }
            pi.logged_off = DateTime.Now;
        }

        double GetModifiedRestedXP(BasePlayer player, double rested_xp)
        {
            var mod = 0f;
            foreach (var perm in config.rested_xp_settings.rested_xp_modifier_perm_mod)
            {
                if (perm.Value > mod && permission.UserHasPermission(player.UserIDString, perm.Key))
                    mod = perm.Value;
            }

            return rested_xp + (rested_xp * mod);
        }

        [HookMethod("GiveSkillPoints")]
        public void GiveSkillPoints(BasePlayer player, int amount)
        {
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - GiveSkillPoints. [Online = {player.IsConnected}]", this, true);
                var data = GetOfflinePlayerInfo(player.UserIDString);
                if (data == null) return;
                data.available_points += amount;
                data.non_level_related_points_given += amount;
                WriteJson(player.UserIDString, JsonConvert.SerializeObject(data));
                return;
            }
            playerData.available_points += amount;
            playerData.non_level_related_points_given += amount;
            Player.Message(player, string.Format(lang.GetMessage("ReceivedSP", this, player.UserIDString), amount, playerData.available_points));
        }

        float DefaultBoatSpeed(string shortname)
        {
            if (shortname == "rhib") return 6000f;
            else if (shortname == "tugboat") return 200000f;
            else return 2400f;
        }

        BasePlayer FindPlayerByID(string id, BasePlayer searchingPlayer = null, bool consoleMsg = true)
        {
            if (!id.IsSteamId()) return null;
            var player = BasePlayer.activePlayerList.Where(x => x.UserIDString == id).FirstOrDefault();
            if (player == null)
            {
                if (searchingPlayer != null) PrintToChat(searchingPlayer, $"No player found matching ID: {id}");
                else if (consoleMsg) Puts($"No player found matching ID: {id}");
            }
            return player ?? null;
        }

        private BasePlayer FindPlayerByName(string Playername, BasePlayer SearchingPlayer = null, bool consoleMsg = true)
        {
            var lowered = Playername;
            var targetList = BasePlayer.allPlayerList.Where(x => x.displayName.Contains(lowered, System.Globalization.CompareOptions.IgnoreCase)).OrderBy(x => x.displayName.Length);
            if (targetList.Count() == 1)
            {
                return targetList.First();
            }
            if (targetList.Count() > 1)
            {
                if (targetList.First().displayName.Equals(Playername, StringComparison.OrdinalIgnoreCase))
                {
                    return targetList.First();
                }
                if (SearchingPlayer != null)
                {
                    PrintToChat(SearchingPlayer, string.Format(lang.GetMessage("MorePlayersFound", this, SearchingPlayer.UserIDString), String.Join(",", targetList.Select(x => x.displayName))));
                }
                else if (consoleMsg) Puts(string.Format(lang.GetMessage("MorePlayersFound", this), String.Join(",", targetList.Select(x => x.displayName))));
                return null;
            }
            if (targetList.Count() == 0)
            {
                if (SearchingPlayer != null)
                {
                    PrintToChat(SearchingPlayer, string.Format(lang.GetMessage("NoMatch", this, SearchingPlayer.UserIDString), Playername));
                }
                else if (consoleMsg) Puts(string.Format(lang.GetMessage("NoMatch", this), Playername));
                return null;
            }
            return null;
        }

        bool RollSuccessful(float luck)
        {
            var roll = UnityEngine.Random.Range(0f, 100f);
            return (roll >= 100f - (luck * 100));
        }

        double GetXPModifier(string id, PlayerInfo pi, out bool modified, bool noMod = false)
        {
            modified = false;
            if (noMod) return 1;
            bool hasModifier = false;
            double result = 0;
            // Checks each permission that you have created in the config for xp override.
            foreach (var perm in config.xp_settings.xp_perm_modifier)
            {
                // If the permissions value is greater than the value stored in result, result is set to the new value.
                if (permission.UserHasPermission(id, perm.Key.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase) ? perm.Key : "skilltree." + perm.Key) && perm.Value > result)
                {
                    result = perm.Value;
                    hasModifier = true;
                }
            }
            // If we don't have any special perms, we set the mod to default (1.0)
            if (!hasModifier) result = 1;
            if (config.rested_xp_settings.rested_xp_enabled && pi.xp_bonus_pool > 0)
            {
                // If rested XP is enabled, then we add the rested xp value on top of our result.
                result += config.rested_xp_settings.rested_xp_rate;
                modified = true;
            }
            if (TOD_Sky.Instance.IsNight && config.xp_settings.night_settings.night_xp_gain_modifier != 1)
            {
                // If night time xp gains are enabled, we add (or remove) that value onto our result as well.
                result += config.xp_settings.night_settings.night_xp_gain_modifier - 1;
                modified = true;
            }

            if (config.prestige_settings.apply_bonus_multiplicatively) result *= pi.prestige_xp_mod;
            else result += pi.prestige_xp_mod - 1;

            return result;
        }

        bool IsGodMode(BasePlayer player)
        {
            return player.IsGod();
        }

        bool IsSkillTreeXPEventLoaded = false;

        void OnPluginLoaded(Plugin name)
        {
            if (name == SkillTreeXPEvent) IsSkillTreeXPEventLoaded = true;
        }

        void OnPluginUnloaded(Plugin name)
        {
            if (name == SkillTreeXPEvent) IsSkillTreeXPEventLoaded = false;
            else PluginXPModifiers.Remove(name.Name);
        }

        [HookMethod("SetXPEventState")]
        public void SetXPEventState(bool enabled)
        {
            SkillTreeXPEventRunning = enabled;
        }

        public Dictionary<string, float> PluginXPModifiers = new Dictionary<string, float>();

        double GetHighestPluginModifiers(double xp)
        {
            if (PluginXPModifiers.Count == 0) return xp;
            float highest = 0;
            foreach (var kvp in PluginXPModifiers)
                if (kvp.Value > highest)
                    highest = kvp.Value;

            return xp * highest;
        }

        [HookMethod("AddGlobalXPModifier")]
        public void AddGlobalXPModifier(string pluginName, float modifier)
        {
            PluginXPModifiers[pluginName] = modifier;
        }

        [HookMethod("RemoveGlobalXPModifier")]
        public void RemoveGlobalXPModifier(string pluginName)
        {
            PluginXPModifiers.Remove(pluginName);
        }

        [HookMethod("AwardXP")]
        public void AwardXP(BasePlayer player, double value, string plugin, bool noMod = false)
        {
            if (DisabledXP.Contains(player.userID)) return;
            bool isModified = false;
            var hook = Interface.CallHook("STCanGainXP", player, plugin, value);
            if (hook != null)
            {
                if (hook is bool) return;
                else if (hook is double)
                {
                    value = (double)hook;
                    isModified = true;
                }
                if (value == 0) return;
            }

            AwardXP(player, value, null, noMod, true, null, isModified);
        }

        public bool SkillTreeXPEventRunning = false;

        [HookMethod("AwardXP")]
        public void AwardXP(BasePlayer player, double value, BaseEntity source = null, bool noMod = false, bool hookAlreadyCalled = false, string source_string = null, bool isModified = false)
        {
            if (player == null || player.IsNpc || !player.userID.IsSteamId() || value == 0) return;
            if (!permission.UserHasPermission(player.UserIDString, "skilltree.xp")) return;
            bool xpEventModified = false;
            if (IsSkillTreeXPEventLoaded && SkillTreeXPEventRunning)
            {
                var modifiedXP = Convert.ToDouble(SkillTreeXPEvent.Call("GetEventXP", player, source, value, source_string));
                if (modifiedXP > 0)
                {
                    value = modifiedXP;
                    xpEventModified = true;
                }
            }

            if (!hookAlreadyCalled)
            {
                if (DisabledXP.Contains(player.userID)) return;
                var hook = Interface.CallHook("STCanGainXP", player, source, value, source_string);
                if (hook != null)
                {
                    if (hook is bool) return;
                    else if (hook is double)
                    {                        
                        value = (double)hook;
                        isModified = true;
                    }
                    if (value == 0) return;
                }
            }
            if (!config.xp_settings.allow_godemode_xp && IsGodMode(player)) return;
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - AwardXP. [Online = {player.IsConnected}]", this, true);
                return;
            }

            bool modified;
            var moddedXp = (value * GetXPModifier(player.UserIDString, playerData, out modified, noMod));
            if (!modified && isModified) modified = true;
            var exp = GetHighestPluginModifiers(moddedXp);

            if (config.xp_settings.xPCapSettings.cap > 0)
            {
                exp = CheckXPCap(exp, playerData);
                playerData.gained_today += exp;
                if (playerData.gained_today >= config.xp_settings.xPCapSettings.cap && !playerData.notifiedOfCap)
                {
                    PrintToChat(player, string.Format(lang.GetMessage("HitXPCapNotification", this, player.UserIDString), config.xp_settings.xPCapSettings.resetTime));
                    playerData.notifiedOfCap = true;
                }
            }

            if (config.xp_settings.scaleXP && source != null && source.networkEntityScale)
            {
                var vector = source.transform.localScale;
                if (vector.x != 1 || vector.y != 1 || vector.z != 1)
                {
                    var scale = source.transform.localScale.x;
                    exp = exp * scale;
                }                
            }

            /* XP Sharing
             * - If source_string != "shared", we would check to see if player has shared xp buff
             * - If buff exists, we would do FindEntitiesOfType<BasePlayer>()
             * - Any hits would be filtered out for non-team members
             * - AwardXP would be called with source set to null and source_string set to "shared"
             * - may need to feed hookAlreadyCalled to it as well for performance so it doesnt call the hook multiple times each xp cycle.
             * 
             * This should prevent infinite xp loops.
             * 
             */

            if (exp <= 0) return;

            HandleSharedXP(player, config.buff_settings.xpShareSettings.modifiedXP ? exp : value, source, !config.buff_settings.xpShareSettings.modifiedXP, source_string);

            double excessXP = GetXPAfterDebtCheck(player, playerData, exp);

            if (config.misc_settings.log_player_xp_gain) AddXPLog(player, $"Gained {excessXP} from: {(source != null ? source.ShortPrefabName : !string.IsNullOrEmpty(source_string) ? source_string : "no source provided")}");
            playerData.xp += excessXP;
            if (playerData.xp_bonus_pool > 0) playerData.xp_bonus_pool -= excessXP;
            if (playerData.xp_drops)
            {
                DisplayXPMenu(player, exp, xpEventModified ? 2 : modified ? 1 : 0);
            }
            CheckLevel(player);
            if (playerData.xp_hud) UpdateXP(player, playerData);
            if (permission.UserHasPermission(player.UserIDString, "skilltree.chat") && !notifiedPlayers.Contains(player.userID))
            {
                if (config.chat_commands.chat_cmd.Count > 1) Player.Message(player, string.Format(lang.GetMessage("AccessReminder", this, player.UserIDString), config.chat_commands.chat_cmd.First()), config.misc_settings.ChatID);
                notifiedPlayers.Add(player.userID);
            }
        }

        double CheckXPCap(double xp, PlayerInfo playerData)
        {
            if (playerData.nextXPCapReset != pcdData.nextXPCapReset)
            {
                playerData.nextXPCapReset = pcdData.nextXPCapReset;
                playerData.gained_today = 0;
                playerData.notifiedOfCap = false;
            }
            if (playerData.gained_today + xp > config.xp_settings.xPCapSettings.cap) return Math.Max(config.xp_settings.xPCapSettings.cap - playerData.gained_today, 0);
            return xp;
        }

        void HandleSharedXP(BasePlayer player, double value, BaseEntity source = null, bool noMod = false, string source_string = null)
        {
            if (source_string == SharedXP) return;
            if (source_string == "SkillExtractors") return;
            if (player.Team == null || !GetBuffDetails(player.userID, out var bd) || !bd.GetBuff(Buff.XP_Share, out var shareMod)) return;

            var shared = FindNearbyTeamMates(player, config.buff_settings.xpShareSettings.Distance);
            foreach (var _player in shared)
            {
                if (_player == player || !_player.IsConnected || _player.IsDead() || _player.Team == null || _player.Team.teamID != player.Team.teamID) continue;
                AwardXP(_player, value * shareMod, source, noMod, true, SharedXP);
            }

            Pool.FreeUnmanaged(ref shared);
        }

        [HookMethod("AwardXP")]
        public void AwardXP(ulong userid, double value, string plugin, bool noMod = false)
        {
            bool isModified = false;
            var hook = Interface.CallHook("STCanGainXP", userid, plugin, value);
            if (hook != null)
            {
                if (hook is bool) return;
                else if (hook is double)
                {
                    value = (double)hook;
                    isModified = true;
                }
                if (value == 0) return;
            }
            var player = BasePlayer.activePlayerList.FirstOrDefault(x => x.userID == userid);
            if (player != null && player.IsConnected) AwardXP(player, value, null, noMod, true, plugin, isModified);
            else AssignPendingXP(userid, value, noMod);
        }

        void AssignPendingXP(ulong userid, double amount, bool noMod)
        {
            if (!permission.UserHasPermission(userid.ToString(), "skilltree.xp")) return;
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(userid, out playerData)) return;
            if (noMod) playerData.pending_xp_without_bonus += amount;
            else playerData.pending_xp_with_bonus += amount;
            if (config.xp_settings.pending_xp_cap > 0)
            {
                if (playerData.pending_xp_without_bonus > config.xp_settings.pending_xp_cap) playerData.pending_xp_without_bonus = config.xp_settings.pending_xp_cap;
                if (playerData.pending_xp_with_bonus > config.xp_settings.pending_xp_cap) playerData.pending_xp_with_bonus = config.xp_settings.pending_xp_cap;
            }
        }

        double GetXPAfterDebtCheck(BasePlayer player, PlayerInfo playerData, double xp)
        {
            if (playerData.xp_debt <= 0) return xp;
            var currentDebt = playerData.xp_debt;
            if (currentDebt - xp > 0)
            {
                playerData.xp_debt -= xp;
                return 0;
            }

            double excess = xp - currentDebt;
            playerData.xp_debt -= xp - excess;

            return excess;
        }

        void IncreaseCalories(BasePlayer player, float modifier)
        {
            player.metabolism.calories.max = 500 + (500 * modifier);
            player.metabolism.hydration.max = 250 + (250 * modifier);
            player.SendNetworkUpdate();
        }

        bool LevelUpNode(BasePlayer player, string tree, string name)
        {
            TreeInfo ti;
            if (!TreeData.TryGetValue(player.userID, out ti))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - LevelUpNode. [Online = {player.IsConnected}]", this, true);
                return false;
            }
            var max_skill_points = GetMaxSkillPoints(player);
            if (max_skill_points > 0 && ti.total_points_spent >= max_skill_points)
            {
                SendPlayerMessage(player, lang.GetMessage("MaxSP", this, player.UserIDString), config.misc_settings.messageSettings.FailLevelUpMaxPoints);
                return false;
            }
            NodesInfo nsi = ti.trees[tree];
            NodeInfo ni;
            if (!nsi.nodes.TryGetValue(name, out ni)) return false;
            if (ni.level_current >= ni.level_max)
            {
                SendPlayerMessage(player, lang.GetMessage("MaxedNode", this, player.UserIDString), config.misc_settings.messageSettings.FailLevelUpMaxNode);
                return false;
            }
            if (nsi.point_requirements.TryGetValue(ni.tier, out var req) && nsi.points_spent < req)
            {
                SendPlayerMessage(player, string.Format(lang.GetMessage("NotEnoughPointsSpent", this, player.UserIDString), req - nsi.points_spent), config.misc_settings.messageSettings.FailLevelUpMinPointsSpent);
                return false;
            }
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData))
            {
                SetupPlayer(player.userID);
                playerData = pcdData.pEntity[player.userID];
            }

            if (nsi.min_level > 0)
            {
                var min_Level = GetLevelRequirement(player, tree, nsi.min_level);
                if (playerData.current_level < min_Level)
                {
                    SendPlayerMessage(player, string.Format(lang.GetMessage("FailMinLevel", this, player.UserIDString), nsi.min_level), config.misc_settings.messageSettings.FailLevelUpMinLevel);
                    return false;
                }
            }

            if (nsi.min_points > 0)
            {
                var min_Points = GetPointRequirement(player, tree, nsi.min_points);
                var totalPointsSpent = 0;
                foreach (var t in ti.trees)
                    totalPointsSpent += t.Value.points_spent;

                if (totalPointsSpent < min_Points)
                {
                    SendPlayerMessage(player, string.Format(lang.GetMessage("FailMinPointsSpent", this, player.UserIDString), nsi.min_points), config.misc_settings.messageSettings.FailLevelUpMinPointsSpent);
                    return false;
                }
            }

            if ((nsi.min_prestige > 0 && playerData.prestige_level < nsi.min_prestige))
            {
                SendPlayerMessage(player, string.Format(lang.GetMessage("FailMinPrestige", this, player.UserIDString), nsi.min_prestige), config.misc_settings.messageSettings.FailLevelUpMinPrestigeForTree);
                return false;
            }

            if (ni.min_prestige > 0 && ni.min_prestige > playerData.prestige_level)
            {
                SendPlayerMessage(player, string.Format(lang.GetMessage("FailMinPrestigeNode", this, player.UserIDString), ni.min_prestige), config.misc_settings.messageSettings.FailLevelUpMinPrestige);
                return false;
            }

            if (ni.min_level > 0 && ni.min_level > playerData.current_level)
            {
                SendPlayerMessage(player, string.Format(lang.GetMessage("FailMinLevelNode", this, player.UserIDString), ni.min_level), config.misc_settings.messageSettings.FailLevelUpMinLevelOnNode);
                return false;
            }

            if (!string.IsNullOrEmpty(ni.permission_required) && !permission.UserHasPermission(player.UserIDString, ni.permission_required))
            {
                SendPlayerMessage(player, string.Format(lang.GetMessage("FailPermission", this, player.UserIDString), ni.permission_required), config.misc_settings.messageSettings.FailLevelUpMinLevelOnNode);
                return false;
            }

            if (!string.IsNullOrEmpty(ni.required_skill) && (!playerData.buff_values.TryGetValue(ni.required_skill, out var skillLevel) || skillLevel < GetNodeMaxLevel(ni.required_skill)))
            {
                SendPlayerMessage(player, string.Format(lang.GetMessage("FailPreReqNode", this, player.UserIDString), lang.GetMessage(ni.required_skill, this, player.UserIDString)), config.misc_settings.messageSettings.FailLevelMissingSkill);
                return false;
            }

            if (!string.IsNullOrEmpty(ni.excluded_skill) && (playerData.buff_values.ContainsKey(ni.excluded_skill)))
            {
                SendPlayerMessage(player, string.Format(lang.GetMessage("ExcludedNode", this, player.UserIDString), lang.GetMessage(ni.excluded_skill, this, player.UserIDString)), config.misc_settings.messageSettings.FailLevelExcludedSkill);
                return false;
            }

            if (ni.exclusions.Count > 0)
            {
                foreach (var kvp in playerData.buff_values.Keys)
                    if (ni.exclusions.Contains(kvp))
                    {
                        SendPlayerMessage(player, string.Format(lang.GetMessage("ExcludedNode", this, player.UserIDString), lang.GetMessage(kvp, this, player.UserIDString)), config.misc_settings.messageSettings.FailLevelExcludedSkill);
                        return false;
                    }
            }

            if (playerData.available_points <= 0)
            {
                SendPlayerMessage(player, lang.GetMessage("MaxedSkillPoints", this, player.UserIDString), config.misc_settings.messageSettings.FailLevelUpNoPoints);
                return false;
            }
            if (max_skill_points > 0 && nsi.points_spent >= max_skill_points)
            {
                SendPlayerMessage(player, lang.GetMessage("AssignedMaxedSkillPoints", this, player.UserIDString), config.misc_settings.messageSettings.FailLevelUpMaxPoints);
                return false;
            }
            if (ni.level_current == 0)
            {
                SendPlayerMessage(player, string.Format(lang.GetMessage("UnlockedFirstNode", this, player.UserIDString), lang.GetMessage(name, this, player.UserIDString), ni.level_max), config.misc_settings.messageSettings.NodeLevelUp);
                if (!string.IsNullOrEmpty(config.effect_settings.skill_point_unlock_effect)) EffectNetwork.Send(new Effect(config.effect_settings.skill_point_unlock_effect, player.transform.position, player.transform.position), player.net.connection);
                TriggerStuffOnAbilityUnlock(player, ni.buffInfo.Key, ni.value_per_buff, playerData);
            }
            else
            {
                SendPlayerMessage(player, string.Format(lang.GetMessage("UnlockedNode", this, player.UserIDString), lang.GetMessage(name, this, player.UserIDString), ni.level_current + 1, ni.level_max), config.misc_settings.messageSettings.NodeLevelUp);
                if (!string.IsNullOrEmpty(config.effect_settings.skill_point_level_effect)) EffectNetwork.Send(new Effect(config.effect_settings.skill_point_level_effect, player.transform.position, player.transform.position), player.net.connection);
            }

            ni.level_current++;
            playerData.available_points--;
            nsi.points_spent++;
            ti.total_points_spent++;
            if (!playerData.buff_values.ContainsKey(name)) playerData.buff_values.Add(name, ni.level_current);
            else playerData.buff_values[name] = ni.level_current;
            BuffDetails bd;
            if (!buffDetails.TryGetValue(player.userID, out bd))
            {
                PrintWarning($"{player.userID} does not have buffDetails setup in LevelUpNode. This should never happen.");
                return false;
            }

            bd.AddBuff(ni.buffInfo.Key, ni.value_per_buff);

            //if (!bd.ContainsBuff(ni.buffInfo.Key)) bd.buff_values.Add(ni.buffInfo.Key, ni.level_current * ni.value_per_buff);
            //else bd.buff_values[ni.buffInfo.Key] += ni.value_per_buff;

            switch (ni.buffInfo.Key)
            {
                case Buff.Build_Craft_Ultimate:
                case Buff.Combat_Ultimate:
                case Buff.Harvester_Ultimate:
                case Buff.Medical_Ultimate:
                case Buff.Mining_Ultimate:
                case Buff.Scavengers_Ultimate:
                case Buff.Skinning_Ultimate:
                case Buff.Vehicle_Ultimate:
                case Buff.Woodcutting_Ultimate:
                case Buff.Raiding_Ultimate:
                case Buff.Cooking_Ultimate:
                    HandleUltimateToggle(player, ni.buffInfo.Key, playerData);
                    break;
                case Buff.ExtraPockets:
                    SendExtraPocketsButton(player);
                    break;

                case Buff.Metabolism_Boost: IncreaseCalories(player, bd.GetBuffValue(ni.buffInfo.Key)); break;
                case Buff.HealthRegen: UpdateRegen(player, bd.GetBuffValue(ni.buffInfo.Key)); break;
                case Buff.Awareness: AddAwareness(player, bd.GetBuffValue(ni.buffInfo.Key)); break;
                case Buff.WaterBreathing: UpdateWaterBreathing(player, bd.GetBuffValue(ni.buffInfo.Key)); break;
                case Buff.InstantUntie: UpdateInstantUntie(player); break;
                case Buff.Comfort: AddComfortSkill(player, bd.GetBuffValue(ni.buffInfo.Key)); break;
                case Buff.Human_Workbench: AddWorkbenchSkill(player, Mathf.RoundToInt(Mathf.Clamp(bd.GetBuffValue(ni.buffInfo.Key), 1, 3))); break;
            }
            AddBuffs(player.userID, ni.buffInfo.Key);

            HandlePerms(player, tree, name, ni.level_current);

            return true;
        }

        int GetLevelRequirement(BasePlayer player, string tree, int defaultvalue)
        {
            var lowest = defaultvalue;
            foreach (var perm in config.general_settings.level_requirement_override)
            {
                if (!permission.UserHasPermission(player.UserIDString, perm.Key)) continue;
                int value;
                if (!perm.Value.treeRequirementOverride.TryGetValue(tree, out value)) continue;
                if (value < lowest) lowest = value;
            }
            return lowest;
        }

        int GetPointRequirement(BasePlayer player, string tree, int defaultvalue)
        {
            var lowest = defaultvalue;
            foreach (var perm in config.general_settings.point_requirement_override)
            {
                if (!permission.UserHasPermission(player.UserIDString, perm.Key)) continue;
                int value;
                if (!perm.Value.treeRequirementOverride.TryGetValue(tree, out value)) continue;
                if (value < lowest) lowest = value;
            }
            return lowest;
        }

        void TriggerStuffOnAbilityUnlock(BasePlayer player, Buff buff, float value, PlayerInfo playerData)
        {
            switch (buff)
            {
                case Buff.ExtraPockets:
                    if (playerData.extra_pockets_button) SendExtraPocketsButton(player);
                    return;

                case Buff.Extended_Mag:
                    HandleWeaponMagExtension(player, value);
                    return;
            }

        }

        void HandleWeaponMagExtension(BasePlayer player, float ammoMod)
        {
            var weapon = player.GetHeldEntity() as BaseProjectile;
            if (weapon != null)
            {
                DelayedModsChanged(weapon, Convert.ToInt32(weapon.primaryMagazine.definition.builtInSize * ammoMod));
                if (!ModifiedWeapons.ContainsKey(weapon.net.ID.Value)) ModifiedWeapons.Add(weapon.net.ID.Value, weapon);
            }
        }

        void HandlePerms(BasePlayer player, string tree, string node, int level) => HandlePerms(player.UserIDString, tree, node, level);

        // UserIDString, Node name, List of perms.
        Dictionary<string, Dictionary<string, Dictionary<string, string>>> Tracked_perms = new Dictionary<string, Dictionary<string, Dictionary<string, string>>>();

        void HandlePerms(string id, string tree, string node, int level)
        {
            string error = string.Empty;
            try
            {
                if (config.trees.TryGetValue(tree, out var ti) && ti.nodes.TryGetValue(node, out var ni) && ni.permissions != null)
                {
                    error = "HandlePerms Error 1";
                    if (ni.permissions.perms.Count == 0) return;

                    error = "HandlePerms Error 2";
                    if (level > 0 && !ni.permissions.perms.ContainsKey(level)) return;
                    error = "HandlePerms Error 3";

                    if (!Tracked_perms.TryGetValue(id, out var playerPerms)) Tracked_perms.Add(id, playerPerms = new Dictionary<string, Dictionary<string, string>>());
                    error = "HandlePerms Error 4";
                    if (playerPerms == null) playerPerms = new Dictionary<string, Dictionary<string, string>>();
                    error = "HandlePerms Error 5";

                    if (!playerPerms.TryGetValue(node, out var tracked_perms)) playerPerms.Add(node, tracked_perms = new Dictionary<string, string>());
                    error = "HandlePerms Error 6";

                    foreach (var perm in ni.permissions.perms)
                    {
                        error = "HandlePerms Error 7";
                        foreach (var str in perm.Value.perms_list)
                        {
                            error = "HandlePerms Error 8";
                            //Puts($"Revoked permission {str} from {id}.");
                            permission.RevokeUserPermission(id, str.Key.Trim());
                            tracked_perms.Remove(str.Key);
                        }
                    }
                    error = "HandlePerms Error 9";

                    if (level > 0)
                    {
                        error = "HandlePerms Error 10";
                        foreach (var perm in ni.permissions.perms[level].perms_list)
                        {
                            error = "HandlePerms Error 11";
                            //Puts($"Granted permission {perm} to {id}.");
                            permission.GrantUserPermission(id, perm.Key.Trim(), null);
                            tracked_perms.Add(perm.Key, perm.Value);
                        }
                    }
                    error = "HandlePerms Error 12";
                }
            }
            catch (Exception e)
            {
                LogToFile($"HandlePerms_Error", $"ID: {id}. Error: {error}. Ex: {e.Message}", this);
                Puts($"ID: {id}. Error: {error}. Ex: {e.Message}");
            }
        }

        Buff GetBuffType(string name)
        {
            if (BuffTypes.ContainsKey(name)) return BuffTypes[name];
            else return 0;
        }

        int GetMaxSkillPoints(BasePlayer player)
        {
            var highest = config.general_settings.max_skill_points;
            if (highest == 0) return 0;
            foreach (var perm in config.general_settings.max_skill_points_override)
            {
                if (perm.Value == 0 && permission.UserHasPermission(player.UserIDString, "skilltree." + perm.Key)) return 0;
                if (perm.Value > highest && permission.UserHasPermission(player.UserIDString, "skilltree." + perm.Key)) highest = perm.Value;
            }
            return highest;
        }

        [HookMethod("GetTotalRespecCost")]
        public double GetTotalRespecCost(BasePlayer player)
        {
            var cost = GetRespecCost(player);
            if (cost <= 0) return cost;

            TreeInfo ti;
            if (!TreeData.TryGetValue(player.userID, out ti) || ti.trees.IsNullOrEmpty())
            {
                return 0;
            }

            var totalPoints = 0;
            foreach (var t in ti.trees)
            {
                totalPoints += t.Value.points_spent;
            }

            return Math.Round(totalPoints * cost, 2);
        }

        int GetPointsToRespec(BasePlayer player, PlayerInfo playerData, string tree)
        {
            var result = 0;
            foreach (var skill in config.trees[tree].nodes)
            {
                if (playerData.buff_values.TryGetValue(skill.Key, out var value)) result += value;
            }
            return result;
        }

        public double GetRespecCost(BasePlayer player)
        {
            var lowest = config.general_settings.respec_cost;
            if (lowest == 0) return 0;
            foreach (var perm in config.general_settings.respec_cost_override)
            {
                if (!permission.UserHasPermission(player.UserIDString, "skilltree." + perm.Key)) continue;
                if (perm.Value == 0) return 0;
                if (perm.Value < lowest) lowest = perm.Value;
            }
            if (config.general_settings.respec_multiplier > 0)
            {
                PlayerInfo pi;
                if (!pcdData.pEntity.TryGetValue(player.userID, out pi)) return lowest;
                lowest += Convert.ToDouble(lowest * pi.respec_multiplier);
            }
            return lowest;
        }

        double GetXPLoss(BasePlayer player, double lossValue, double amountToCalculateFrom)
        {
            if (!config.xp_settings.xp_loss_settings.allow_xp_loss) return 0;
            if (permission.UserHasPermission(player.UserIDString, "skilltree.noxploss")) return 0;

            double modifier = 1;
            foreach (var perm in config.xp_settings.xp_loss_settings.xp_loss_override)
            {
                if (perm.Value < modifier && HasPermission(player.UserIDString, perm.Key))
                    modifier = perm.Value;
            }

            switch (config.xp_settings.xp_loss_settings.xp_loss_type)
            {
                case XPLossType.XpValue: return Math.Max(lossValue * modifier, 0);
                default: return Math.Max(amountToCalculateFrom * lossValue * modifier, 0);
            }
        }

        bool HasPermission(string id, string perm)
        {
            if (!perm.StartsWith("skilltree.")) return permission.UserHasPermission(id, "skilltree." + perm);
            return permission.UserHasPermission(id, perm);
        }

        void UpdateInstancedData(BasePlayer player)
        {
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;

            CheckPrestigeGroups(player, playerData.prestige_level, false);

            TreeInfo ti;
            if (!TreeData.TryGetValue(player.userID, out ti) && !player.IsNpc && player.userID.IsSteamId()) TreeData.Add(player.userID, ti = new TreeInfo());
            if (ti == null)
            {
                PlayerDataLogs += $"TI was null for {player.userID}. This should never happen.";
                return;
            }

            if (!GetBuffDetails(player.userID, out var bd)) buffDetails.Add(player.userID, bd = new BuffDetails(player));
            foreach (var cfg in config.trees)
            {
                if (!cfg.Value.enabled) continue;

                if (!HasTreeAccess(player.UserIDString, cfg.Key))
                {
                    RefundTreePoints(player, cfg.Key);
                    continue;
                }
                NodesInfo ni;
                if (!ti.trees.TryGetValue(cfg.Key, out ni)) ti.trees.Add(cfg.Key, ni = new NodesInfo());
                ni.min_level = cfg.Value.min_level;
                ni.min_points = cfg.Value.min_points;
                ni.min_prestige = cfg.Value.min_prestige;

                foreach (var req in cfg.Value.point_requirements)
                {
                    ni.point_requirements[req.Key] = req.Value;
                }
                foreach (var node in cfg.Value.nodes)
                {
                    if (!node.Value.enabled)
                    {
                        int spentPoints = 0;
                        if (playerData.buff_values.TryGetValue(node.Key, out spentPoints))
                        {
                            playerData.available_points += spentPoints;
                            playerData.buff_values.Remove(node.Key);
                        }
                        continue;
                    }
                    
                    NodeInfo nodeData;
                    if (!ni.nodes.TryGetValue(node.Key, out nodeData)) ni.nodes.Add(node.Key, nodeData = new NodeInfo());
                    nodeData.buffInfo = node.Value.buff_info;
                    nodeData.level_max = node.Value.max_level;
                    nodeData.tier = node.Value.tier;
                    nodeData.permission_required = node.Value.required_permission;
                    nodeData.value_per_buff = node.Value.value_per_buff;
                    if (node.Value.min_prestige > 0)
                    {
                        nodeData.min_prestige = node.Value.min_prestige;
                    }
                    if (node.Value.min_level > 0)
                    {
                        nodeData.min_level = node.Value.min_level;
                    }
                    if (!string.IsNullOrEmpty(node.Value.required_skill))
                    {
                        nodeData.required_skill = node.Value.required_skill;
                    }
                    if (!string.IsNullOrEmpty(node.Value.excluded_skill))
                    {
                        nodeData.excluded_skill = node.Value.excluded_skill;
                    }
                    switch (nodeData.buffInfo.Key)
                    {
                        case Buff.Build_Craft_Ultimate:
                            nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), config.ultimate_settings.ultimate_buildCraft.success_chance < 100 ? string.Format(lang.GetMessage("Build_Craft_Ultimate_DescriptionAddition", this, player.UserIDString), config.ultimate_settings.ultimate_buildCraft.success_chance) : "");
                            break;

                        case Buff.Harvester_Ultimate:
                            nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), config.ultimate_settings.ultimate_harvesting.cooldown > 0 ? string.Format(lang.GetMessage("Harvesting_Ultimate_DescriptionAddition", this, player.UserIDString), config.ultimate_settings.ultimate_harvesting.cooldown) : "");
                            break;

                        case Buff.Mining_Ultimate:
                            nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), Math.Round(config.ultimate_settings.ultimate_mining.distance_from_player, 0));
                            break;

                        case Buff.Woodcutting_Ultimate:
                            nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), Math.Round(config.ultimate_settings.ultimate_woodcutting.distance_from_player, 0)) + (config.ultimate_settings.ultimate_woodcutting.cooldown_between_uses > 0 ? string.Format(lang.GetMessage("Buff.Cooldown", this, player.UserIDString), config.ultimate_settings.ultimate_woodcutting.cooldown_between_uses, lang.GetMessage("Seconds", this, player.UserIDString)) : null);
                            break;

                        case Buff.Skinning_Ultimate:
                            nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), config.ultimate_settings.ultimate_skinning.enabled_buffs.FirstOrDefault(x => x.Value > 0).Value > 0 ? string.Format(string.Join("</color>, <color=#42f105>", config.ultimate_settings.ultimate_skinning.enabled_buffs.Where(x => x.Value > 0).Select(x => lang.GetMessage(x.Key.ToString().ToLower(), this, player.UserIDString)))) : "");
                            break;

                        case Buff.Medical_Ultimate:
                            nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), Math.Round(config.ultimate_settings.ultimate_medical.resurrection_chance, 0));
                            break;

                        case Buff.Combat_Ultimate:
                            string formattedString = "";
                            var active = 0;
                            if (config.ultimate_settings.ultimate_combat.scientists_enabled) active++;
                            if (config.ultimate_settings.ultimate_combat.players_enabled) active++;
                            if (config.ultimate_settings.ultimate_combat.scientists_enabled) active++;

                            if (config.ultimate_settings.ultimate_combat.scientists_enabled)
                            {
                                formattedString += lang.GetMessage("CombatUltimateScientists", this, player.UserIDString);
                                if (active == 2) formattedString += " and ";
                                if (active == 3) formattedString += ", ";
                            }
                            if (config.ultimate_settings.ultimate_combat.animals_enabled)
                            {
                                formattedString += lang.GetMessage("CombatUltimateAnimals", this, player.UserIDString);
                                if (active == 3) formattedString += " and ";
                            }
                            if (config.ultimate_settings.ultimate_combat.players_enabled) formattedString += lang.GetMessage("CombatUltimatePlayers", this, player.UserIDString);

                            nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), config.ultimate_settings.ultimate_combat.health_scale * 100, formattedString);
                            break;

                        case Buff.Scavengers_Ultimate:
                            nodeData.description = lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString);
                            break;

                        case Buff.Raiding_Ultimate:
                            nodeData.description = lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString);
                            break;

                        case Buff.Vehicle_Ultimate:
                            nodeData.description = nodeData.buffInfo.Value == BuffType.IO ?
                                string.Format(lang.GetMessage($"{nodeData.buffInfo.Key}_IO", this, player.UserIDString), node.Value.value_per_buff * 100) :
                                string.Format(lang.GetMessage($"{nodeData.buffInfo.Key}_Percentage", this, player.UserIDString), node.Value.value_per_buff * 100);
                            break;

                        case Buff.Cooking_Ultimate:
                            string message = lang.GetMessage("Cooking_Ultimate_Description", this, player.UserIDString) + lang.GetMessage("CookingUltimateDescriptionSize", this, player.UserIDString);
                            foreach (var buff in config.ultimate_settings.ultimate_cooking.tea_mods)
                            {
                                message += string.Format(lang.GetMessage("CookingUltimateMod", this, player.UserIDString), lang.GetMessage(buff.Key.ToString(), this, player.UserIDString), buff.Value.modifier * 100);
                            }
                            message += String.Format(lang.GetMessage("CookingUltimateDescriptionBottom", this, player.UserIDString), config.ultimate_settings.ultimate_cooking.command, config.ultimate_settings.ultimate_cooking.buff_cooldown);
                            nodeData.description = message;
                            break;

                        case Buff.Boat_Speed:
                            if (config.buff_settings.boat_turbo_on_mount) nodeData.description = string.Format(lang.GetMessage("BoatSpeedAuto", this, player.UserIDString), nodeData.value_per_buff * 100);
                            else nodeData.description = GetStandardNodeDescription(player, nodeData.buffInfo.Key, nodeData.buffInfo.Value, nodeData.value_per_buff);
                            break;

                        case Buff.Forager:
                            nodeData.description = string.Format(lang.GetMessage("Forager", this, player.UserIDString), config.buff_settings.forager_settings.distance);
                            break;

                        case Buff.Sonar:
                            var sonarNames = GetSonarNames(player);
                            nodeData.description = string.Format(lang.GetMessage("Sonar", this, player.UserIDString), config.buff_settings.sonar_settings.distance) + string.Format(lang.GetMessage("Buff.Sonar.Description", this, player.UserIDString), config.buff_settings.sonar_settings.command, config.buff_settings.sonar_settings.cooldown, "<color=#00d6d9>" + string.Join("</color>, <color=#00d6d9>", sonarNames) + "</color>");
                            Pool.FreeUnmanaged(ref sonarNames);
                            break;

                        case Buff.Woodcutting_Hotspot:
                            if (nodeData.buffInfo.Value == BuffType.Percentage) nodeData.description = string.Format(lang.GetMessage("Woodcutting_Hotspot_Percentage", this, player.UserIDString), nodeData.value_per_buff * 100);
                            else nodeData.description = lang.GetMessage("Woodcutting_Hotspot_IO", this, player.UserIDString);
                            break;

                        case Buff.Mining_Hotspot:
                            if (nodeData.buffInfo.Value == BuffType.Percentage) nodeData.description = string.Format(lang.GetMessage("Mining_Hotspot_Percentage", this, player.UserIDString), nodeData.value_per_buff * 100);
                            else nodeData.description = lang.GetMessage("Mining_Hotspot_IO", this, player.UserIDString);
                            break;

                        case Buff.Comfort: nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), nodeData.value_per_buff * 100) + "\n" + string.Format(lang.GetMessage("Buff_Distance", this, player.UserIDString), config.buff_settings.comfortSettings.Distance); break;
                        case Buff.Heal_Share: nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), nodeData.value_per_buff * 100) + "\n" + string.Format(lang.GetMessage("Buff_Distance", this, player.UserIDString), config.buff_settings.healShareSettings.Distance); break;
                        case Buff.XP_Share: nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), nodeData.value_per_buff * 100) + "\n" + string.Format(lang.GetMessage("Buff_Distance", this, player.UserIDString), config.buff_settings.xpShareSettings.Distance); break;
                        case Buff.Tea_Share: nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), nodeData.value_per_buff * 100) + "\n" + string.Format(lang.GetMessage("Buff_Distance", this, player.UserIDString), config.buff_settings.teaShareSettings.Distance); break;
                        case Buff.Metabolism_Share: nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), nodeData.value_per_buff * 100) + "\n" + string.Format(lang.GetMessage("Buff_Distance", this, player.UserIDString), config.buff_settings.metabolismShareSettings.Distance); break;
                        case Buff.Human_Workbench: nodeData.description = lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString) + "\n" + string.Format(lang.GetMessage("Buff_Distance", this, player.UserIDString), config.buff_settings.mobileWorkbenchSettings.Distance); break;
                        case Buff.Double_Bandage_Heal: nodeData.description = lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString) + "\n" + (config.buff_settings.Double_Bandage_Heal_Cooldown > 0 ? string.Format(lang.GetMessage("Buff.Cooldown", this, player.UserIDString), config.buff_settings.Double_Bandage_Heal_Cooldown, lang.GetMessage("Seconds", this, player.UserIDString)) : null); break;
                        case Buff.Wounded_Resist: nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), nodeData.value_per_buff * 100) + "\n" + (config.buff_settings.Double_Bandage_Heal_Cooldown > 0 ? string.Format(lang.GetMessage("Buff.Cooldown", this, player.UserIDString), config.buff_settings.Double_Bandage_Heal_Cooldown, lang.GetMessage("Seconds", this, player.UserIDString)) : null); break;
                        case Buff.Harvesting_Luck: nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), nodeData.value_per_buff * 100) + "\n" + (config.buff_settings.harvesting_luck_settings.Harvesting_luck_works_with_grown ? "" : lang.GetMessage("GrownEnabled", this, player.UserIDString)); break;

                        case Buff.Awareness: nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), nodeData.value_per_buff) + "\n" + string.Format(lang.GetMessage("AwarenessDescription", this, player.UserIDString), GetAwarenessString(player.UserIDString)); break;
                        case Buff.Shield_Reflect: nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), nodeData.value_per_buff * 100) + string.Format(lang.GetMessage("Shield_Reflect_Info", this, player.UserIDString), config.buff_settings.shield_ReflectSettings.bulletReflectMod * 100, config.buff_settings.shield_ReflectSettings.arrowReflectMod * 100); break;
                        case Buff.Craft_Refund: nodeData.description = string.Format(lang.GetMessage(nodeData.buffInfo.Key.ToString(), this, player.UserIDString), nodeData.value_per_buff * 100) + (config.tools_black_white_list_settings.craft_refund_blacklist.Count > 0 ? string.Format(lang.GetMessage("Craft_Refund_Blacklist", this, player.UserIDString), string.Join(", ", config.tools_black_white_list_settings.craft_refund_blacklist)) : null); break;
                        default:
                            nodeData.description = GetStandardNodeDescription(player, nodeData.buffInfo.Key, nodeData.buffInfo.Value, nodeData.value_per_buff);
                            break;
                    }

                    if (!playerData.buff_values.ContainsKey(node.Key)) nodeData.level_current = 0;
                    else nodeData.level_current = playerData.buff_values[node.Key];
                    ni.points_spent += nodeData.level_current;
                    ti.total_points_spent += nodeData.level_current;

                    SetNodePoints(player, nodeData, bd, playerData, cfg.Key, node.Key);
                }

                

                SetupSkills(player, bd, playerData);

                CheckPoints(player, playerData);
            }

            if (TreeData.TryGetValue(player.userID, out var treeData))
            {
                // Find skills thare are excluded by other skills.
                foreach (var nodes in treeData.trees)
                {
                    foreach (var node in nodes.Value.nodes)
                    {
                        AddExcludedSkills(node.Key, node.Value.exclusions, treeData);
                    }                    
                }

            }

            foreach (var buff in bd.GetBuffs())
                if (playerData.DisabledBuffs.Contains(buff.Key))
                    buff.Value.SetEnabled(player, buff.Key, false);
        }

        void AddExcludedSkills(string nodeName, HashSet<string> exclusions, TreeInfo treeData)
        {
            foreach (var nodes in treeData.trees)
            {
                foreach (var node in nodes.Value.nodes)
                    if (node.Value.excluded_skill == nodeName)
                        exclusions.Add(node.Key);
            }
        }

        void CheckPoints(BasePlayer player, PlayerInfo playerData)
        {
            var point_tally = playerData.available_points;
            if (playerData.buff_values != null)
            {
                foreach (var point in playerData.buff_values)
                {
                    point_tally += point.Value;
                }
            }
            var points_should_have = GetPointsPerLevel(player.UserIDString) * playerData.achieved_level;
            if (point_tally < points_should_have)
            {
                playerData.available_points += points_should_have - point_tally;
                Puts($"{player.userID} had less points than they should. Added {points_should_have - point_tally} points to their pool.");
            }
        }

        bool IsBehaviourSkill(Buff buff)
        {
            switch (buff)
            {
                case Buff.Metabolism_Boost:
                case Buff.HealthRegen:
                case Buff.Awareness:
                case Buff.WaterBreathing:
                case Buff.InstantUntie:
                case Buff.Extended_Mag:
                case Buff.Comfort:
                case Buff.Human_Workbench:
                    return true;

                default: 
                    return false;
            }
        }

        void CheckRemoveBehaviour(BasePlayer player, BuffDetails buffData, PlayerInfo playerData, Buff buff)
        {
            if (!IsBehaviourSkill(buff)) return;
            var value = buffData.GetBuffValue(buff);
            if (value > 0)
            {
                SetupSkills(player, buffData, playerData);
                return;
            }
            switch (buff)
            {
                case Buff.HealthRegen: try { DestroyRegen(player); } catch { } return;
                case Buff.Awareness: try { DestroyAwareness(player); } catch { } return;
                case Buff.WaterBreathing: try { DestroyWaterBreathing(player); } catch { } return;
                case Buff.Raiding_Ultimate: try { DestroyRaidBehaviour(player); } catch { } return;
                case Buff.InstantUntie: try { DestroyInstantUntie(player); } catch { } return;
                case Buff.Comfort: try { DestroyComfortSkill(player); } catch { } return;
                case Buff.Human_Workbench: try { DestroyMobileWorkbench(player); } catch { } return;
                case Buff.Metabolism_Boost:
                    player.metabolism.calories.max = 500f;
                    player.metabolism.hydration.max = 250f;
                    player.SendNetworkUpdate();
                    return;
            }
        }

        void SetupSkills(BasePlayer player, BuffDetails bd, PlayerInfo playerData)
        {
            float value;
            if (bd.GetBuff(Buff.Metabolism_Boost, out value)) IncreaseCalories(player, value);
            if (bd.GetBuff(Buff.HealthRegen, out value)) UpdateRegen(player, value);
            if (bd.GetBuff(Buff.Awareness, out value)) AddAwareness(player, value);
            if (bd.GetBuff(Buff.WaterBreathing, out value)) UpdateWaterBreathing(player, value);
            if (bd.ContainsBuff(Buff.InstantUntie)) UpdateInstantUntie(player);
            if (bd.GetBuff(Buff.Extended_Mag, out value)) HandleWeaponMagExtension(player, value);
            if (bd.GetBuff(Buff.Comfort, out value)) AddComfortSkill(player, value);
            if (bd.GetBuff(Buff.Human_Workbench, out value)) AddWorkbenchSkill(player, Mathf.RoundToInt(Mathf.Clamp(value, 1, 3)));

            List<ItemInfo> items = Pool.Get<List<ItemInfo>>();
            items.AddRange(playerData.pouch_items);
            foreach (var item in items)
            {
                if (item.amount < 1) playerData.pouch_items.Remove(item);
            }
            Pool.FreeUnmanaged(ref items);
        }

        void SetNodePoints(BasePlayer player, NodeInfo nodeData, BuffDetails bd, PlayerInfo playerData, string tree, string node)
        {
            if (nodeData.level_current == 0) return;
            bd.AddBuff(nodeData.buffInfo.Key, nodeData.level_current * nodeData.value_per_buff);
            AddBuffs(player.userID, nodeData.buffInfo.Key);
            switch (nodeData.buffInfo.Key)
            {
                case Buff.Build_Craft_Ultimate:
                case Buff.Combat_Ultimate:
                case Buff.Harvester_Ultimate:
                case Buff.Medical_Ultimate:
                case Buff.Mining_Ultimate:
                case Buff.Scavengers_Ultimate:
                case Buff.Skinning_Ultimate:
                case Buff.Vehicle_Ultimate:
                case Buff.Raiding_Ultimate:
                case Buff.Woodcutting_Ultimate:
                    HandleUltimateToggle(player, nodeData.buffInfo.Key, playerData);
                    break;
                case Buff.ExtraPockets:
                    if (playerData.extra_pockets_button) SendExtraPocketsButton(player);
                    break;
            }
            HandlePerms(player, tree, node, nodeData.level_current);

            if (!BuffTypes.ContainsKey(node)) BuffTypes.Add(node, nodeData.buffInfo.Key);
        }

        string GetAwarenessString(string userid)
        {
            List<string> results = Pool.Get<List<string>>();
            try
            {
                if (config.buff_settings.awareness_settings.corpse) results.Add("AwarenessCorpse");
                if (config.buff_settings.awareness_settings.bag) results.Add("AwarenessBag");
                if (config.buff_settings.awareness_settings.animals) results.Add("AwarenessAnimal");
                if (config.buff_settings.awareness_settings.humanNPC) results.Add("AwarenessHumannpc");
                if (config.buff_settings.awareness_settings.droppedItem) results.Add("AwarenessItem");

                if (results.Count == 0) return "";
                if (results.Count == 1) return lang.GetMessage(results[0], this, userid);
                var result = lang.GetMessage(results[0], this, userid);
                foreach (var r in results.Skip(1))
                    result += (", " + lang.GetMessage(r, this, userid));

                return result;
            }
            finally
            {
                Pool.FreeUnmanaged(ref results);
            }

        }

        string GetStandardNodeDescription(BasePlayer player, Buff buff, BuffType buffType, float value)
        {
            if (buffType == BuffType.Percentage) return string.Format(lang.GetMessage(buff.ToString(), this, player.UserIDString), value / 1 * 100);
            else if (buffType == BuffType.IO) return lang.GetMessage(buff.ToString(), this, player.UserIDString);
            else return string.Format(lang.GetMessage(buff.ToString(), this, player.UserIDString), value);
        }

        bool HasTreeAccess(string id, string tree)
        {
            if (!config.general_settings.require_tree_perms || permission.UserHasPermission(id, "skilltree." + tree) || permission.UserHasPermission(id, "skilltree.all")) return true;
            return false;
        }

        void RefundTreePoints(BasePlayer player, string tree)
        {
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;
            List<string> delete = Pool.Get<List<string>>();
            var refund = 0;
            foreach (var node in config.trees[tree].nodes)
            {
                int spent;
                if (playerData.buff_values.TryGetValue(node.Key, out spent))
                {
                    refund += spent;
                    delete.Add(node.Key);
                }
            }
            playerData.available_points += refund;
            if (delete.Count > 0) Puts($"Found {delete.Count} nodes that {player.displayName} does not have permission for - deleting them.");
            foreach (var node in delete)
            {
                playerData.buff_values.Remove(node);
            }

            Pool.FreeUnmanaged(ref delete);
        }

        int GetStartingSkillPoints(string userID)
        {
            int result = config.wipe_update_settings.starting_skill_points;
            foreach (var kvp in config.wipe_update_settings.starting_skill_point_overrides)
            {
                var permString = kvp.Key.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase) ? kvp.Key : "skilltree." + kvp.Key;
                if (permission.UserHasPermission(userID, permString) && kvp.Value > result) result = kvp.Value;
            }
            return result;
        }

        void AddStartingSkillPoints(string useridString, PlayerInfo playerData)
        {
            if (playerData == null && (!ulong.TryParse(useridString, out var userid) || !pcdData.pEntity.TryGetValue(userid, out playerData))) return;
            var startingPoints = GetStartingSkillPoints(useridString);
            var pointsToGive = CalculateStartingPointsToApply(useridString, playerData, startingPoints);
            playerData.available_points += pointsToGive;

        }

        int CalculateStartingPointsToApply(string useridString, PlayerInfo playerData, int startingPoints)
        {
            var totalPoints = playerData.GetTotalSkillPoints - playerData.non_level_related_points_given;
            var minPoints = GetPointsPerLevel(useridString) * playerData.achieved_level;

            if (totalPoints < minPoints + startingPoints)
            {
                return minPoints + startingPoints - totalPoints;
            }
            return 0;
        }

        bool bonus_given;
        void SetupPlayer(ulong id, string name = null, bool create = true)
        {
            if (!id.IsSteamId()) return;
            PlayerInfo playerData;

            if (!pcdData.pEntity.TryGetValue(id, out playerData))
            {
                if (!create)
                {
                    PlayerDataLogs += $"\nData was was not found for {id} during SetupPlayer. We did not create new data.";
                    return;
                }
                PlayerDataLogs += $"\nData was was not found for {id} during SetupPlayer. Creating new data.";
                pcdData.pEntity.Add(id, playerData = new PlayerInfo() { xp_drops = config.xp_settings.enable_xp_drop_by_default, logged_off = DateTime.Now });
            }

            AddStartingSkillPoints(id.ToString(), playerData);

            var pointsPerLevel = GetPointsPerLevel(id.ToString());
            if (playerData.GetTotalSkillPoints < playerData.current_level * pointsPerLevel) playerData.available_points += Math.Abs(playerData.GetTotalSkillPoints - (playerData.current_level * pointsPerLevel));
            if (!bonus_given && id == pcdData.HighestPlayer)
            {
                playerData.available_points += config.wipe_update_settings.bonus_skill_points_amount;
                pcdData.HighestPlayer = 0;
            }
            if (name != null) playerData.name = name;
            if (playerData.prestige_level > 0)
            {
                playerData.prestige_xp_mod = GetPrestigeXPMod(playerData.prestige_level);
            }
            if (config.xp_settings.xPCapSettings.cap > 0)
            {
                if (playerData.nextXPCapReset != pcdData.nextXPCapReset)
                {
                    playerData.nextXPCapReset = pcdData.nextXPCapReset;
                    playerData.gained_today = 0;
                    playerData.notifiedOfCap = false;
                }
            }
        }

        float GetPrestigeXPMod(int level)
        {
            if (!config.prestige_settings.levels.TryGetValue(level, out var prestigeData)) return 1;
            return prestigeData.xp_mod;
        }

        // Only called when a player's data is being removed.
        void UpdatePlayerData(ulong id, bool removePerms)
        {
            SetupPlayer(id, null, false);
            if (!pcdData.pEntity.TryGetValue(id, out var playerData)) return;
            if (GetBuffDetails(id, out var buffData))
            {
                foreach (var buff in buffData.GetBuffs())
                    if (buff.Value.enabled)
                    {
                        if (playerData.DisabledBuffs.Contains(buff.Key)) playerData.DisabledBuffs.Remove(buff.Key);
                    }
                    else
                    {
                        playerData.DisabledBuffs.Add(buff.Key);
                    }
            }
            TreeInfo pi;
            if (TreeData.TryGetValue(id, out pi))
            {
                foreach (var tree in pi.trees)
                {
                    foreach (var node in tree.Value.nodes)
                    {
                        if (removePerms) HandlePerms(id.ToString(), tree.Key, node.Key, 0);
                        if (!playerData.buff_values.ContainsKey(node.Key)) continue;
                        else if (node.Value.level_current > 0) playerData.buff_values[node.Key] = node.Value.level_current;
                    }
                }
            }
        }

        void RespecTree(BasePlayer player, string tree)
        {
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData)) return;
            if (!GetBuffDetails(player.userID, out var buffData, true)) return;
            if (!TreeData.TryGetValue(player.userID, out var ti)) return;
            if (player.isMounted) player.EnsureDismounted();
            int pointsToRefund = 0;
            foreach (var skill in config.trees[tree].nodes)
            {
                if (!playerData.buff_values.TryGetValue(skill.Key, out var points)) continue;

                switch (skill.Value.buff_info.Key)
                {
                    case Buff.HealthRegen: try { DestroyRegen(player); } catch { } break;
                    case Buff.Awareness: try { DestroyAwareness(player); } catch { } break;
                    case Buff.WaterBreathing: try { DestroyWaterBreathing(player); } catch { } break;
                    case Buff.Raiding_Ultimate: try { DestroyRaidBehaviour(player); } catch { } break;
                    case Buff.InstantUntie: try { DestroyInstantUntie(player); } catch { } break;
                    case Buff.Comfort: try { DestroyComfortSkill(player); } catch { } break;
                    case Buff.Human_Workbench: try { DestroyMobileWorkbench(player); } catch { } break;
                    case Buff.Skinning_Ultimate: RemoveAnimalBuff(player); break;
                    case Buff.Metabolism_Boost: player.metabolism.calories.max = 500f; player.metabolism.hydration.max = 250f; break;
                    case Buff.ExtraPockets: HandleExtraPocketsRespec(player, playerData); break;
                    case Buff.Rod_Tension_Bonus:
                        {
                            var rod = player.GetHeldEntity() as BaseFishingRod;
                            if (rod?.net == null || !TrackedRods.ContainsKey(rod.net.ID.Value)) break;
                            ResetRod(rod);
                            break;
                        }

                }
                if (IsUltimate(skill.Value.buff_info.Key)) playerData.ultimate_settings.Remove(skill.Value.buff_info.Key);
                playerData.DisabledBuffs.Remove(skill.Value.buff_info.Key);

                if (skill.Value.permissions?.perms?.Count > 0) HandlePerms(player, tree, skill.Key, 0);

                buffData.RemoveBuff(skill.Value.buff_info.Key, skill.Value.value_per_buff * points);
                pointsToRefund += points;
                playerData.buff_values.Remove(skill.Key);

                RemoveBuff(player.userID, skill.Value.buff_info.Key);
            }
            if (pointsToRefund <= 0 || !ti.trees.TryGetValue(tree, out var nodesData)) return;

            foreach (var node in nodesData.nodes)
                node.Value.level_current = 0;

            ti.total_points_spent -= pointsToRefund;
            nodesData.points_spent = 0;
            playerData.available_points += pointsToRefund;
        }        

        [HookMethod("RespecPlayer")]
        void RespecPlayer(BasePlayer player, PlayerInfo playerData = null)
        {
            var heldItem = player.GetHeldEntity();
            if (heldItem != null)
            {
                var rod = heldItem as BaseFishingRod;
                if (rod != null && TrackedRods.ContainsKey(rod.net.ID.Value))
                {
                    ResetRod(rod);
                }
            }

            if (player.isMounted) player.EnsureDismounted();

            RemoveAnimalBuff(player);
            player.metabolism.calories.max = 500f;
            player.metabolism.hydration.max = 250f;
            player.SendNetworkUpdate();
            try { DestroyRegen(player); } catch { }
            try { DestroyAwareness(player); } catch { }
            try { DestroyWaterBreathing(player); } catch { }
            try { DestroyRaidBehaviour(player); } catch { }
            try { DestroyInstantUntie(player); } catch { }
            try { DestroyComfortSkill(player); } catch { }
            try { DestroyMobileWorkbench(player); } catch { }
            TreeInfo ti;
            if (!TreeData.TryGetValue(player.userID, out ti)) return;
            //TreeData, BuffDetails, PlayerData
            ti.total_points_spent = 0;
            foreach (var tree in ti.trees)
            {
                tree.Value.points_spent = 0;
                foreach (var node in tree.Value.nodes)
                {
                    HandlePerms(player, tree.Key, node.Key, 0);
                    node.Value.level_current = 0;
                }
            }
            BuffDetails bd;
            if (GetBuffDetails(player.userID, out bd))
            {
                bd.ClearBuffs();
            }
            if (playerData != null || pcdData.pEntity.TryGetValue(player.userID, out playerData))
            {
                HandleRespec(player, playerData);
                playerData.DisabledBuffs.Clear();
            }
        }
        void HandleRespec(BasePlayer player, PlayerInfo playerData)
        {
            if (config.ultimate_settings.ultimate_raiding.reset_strike_cooldown_on_respec) playerData.raiding_ultimate_used_time = DateTime.MinValue;
            var pointsBack = 0;
            if (playerData.buff_values.Count > 0)
            {
                foreach (var buff in playerData.buff_values)
                    pointsBack += buff.Value;
                playerData.available_points += pointsBack;
            }
            var pointsPerLevel = GetPointsPerLevel(player.UserIDString);
            if (playerData.available_points < playerData.current_level * pointsPerLevel) playerData.available_points = (playerData.current_level * pointsPerLevel) + GetStartingSkillPoints(player.UserIDString);
            playerData.buff_values.Clear();
            HandleExtraPocketsRespec(player, playerData);
            playerData.ultimate_settings.Clear();
            playerData.DisabledBuffs.Clear();
            if (player.IsConnected) CuiHelper.DestroyUi(player, "ExtraPocketsButton");
            RemoveFromAllBuffs(player.userID);
        }

        void HandleExtraPocketsRespec(BasePlayer player, PlayerInfo playerData)
        {
            if (player.IsConnected && player.IsAlive() && playerData.pouch_items != null & playerData.pouch_items.Count > 0)
            {
                var bag = GenerateBag(player, playerData.pouch_items.Count + 1);
                if (bag.inventory?.itemList != null)
                {
                    List<Item> giveItems = Pool.Get<List<Item>>();
                    giveItems.AddRange(bag.inventory.itemList);

                    foreach (var item in giveItems)
                    {
                        GiveItem(player, item);
                        //player.GiveItem(item);
                    }
                    playerData.pouch_items.Clear();
                    Pool.FreeUnmanaged(ref giveItems);
                    Player.Message(player, lang.GetMessage("PouchItemsRemoved", this, player.UserIDString), config.misc_settings.ChatID);
                }
                CuiHelper.DestroyUi(player, "ExtraPocketsButton");
            }
        }

        #endregion

        #region Menu

        private void SkillTreeBackPanel(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "SkillTreeBackPanel",
                Parent = "Overlay",
                DestroyUi = "SkillTreeBackPanel",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0 0 0 0.98" },
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            CuiHelper.AddUi(player, container);
        }

        Dictionary<string, IconInfo> NodeIconDirectory = new Dictionary<string, IconInfo>();

        class IconInfo
        {
            public string url;
            public ulong iconID;
            public IconInfo(string url, ulong id)
            {
                this.url = url;
                this.iconID = id;
            }
        }

        string AddAdditionalDescription(Buff buff, string userid)
        {
            switch (buff)
            {
                case Buff.Durability: return string.Format(lang.GetMessage("Buff.Durability_Extended.Description", this, userid), string.Join(", ", config.buff_settings.durability_blacklist));

                case Buff.Raiding_Ultimate: return string.Format(lang.GetMessage("Buff.Raiding_Ultimate_Extended.Description", this, userid), config.ultimate_settings.ultimate_raiding.command, config.ultimate_settings.ultimate_raiding.cooldown) + (config.ultimate_settings.ultimate_raiding.require_ammo ? string.Format(lang.GetMessage("Buff.Raiding_Ultimate_Ammo_Extended.Description", this, userid), MissileQuantity) : null);

                case Buff.Trap_Damage_Reduction: return config.buff_settings.raid_perk_settings.trap_damage_reduction_settings.raidable_bases_only && RaidableBases != null && RaidableBases.IsLoaded ? lang.GetMessage("OnlyWorksWithRaidableBases", this, userid) : null;

                case Buff.Trap_Damage_Increase: return config.buff_settings.raid_perk_settings.trap_damage_increase_settings.raidable_bases_only && RaidableBases != null && RaidableBases.IsLoaded ? lang.GetMessage("OnlyWorksWithRaidableBases", this, userid) : null;

                case Buff.Dudless_Explosive: return config.buff_settings.raid_perk_settings.Dudless_Explosiv_settings.raidable_bases_only && RaidableBases != null && RaidableBases.IsLoaded ? lang.GetMessage("OnlyWorksWithRaidableBases", this, userid) : null;

                case Buff.Personal_Explosive_Reduction:
                    string personal_explosive_reduction_string = string.Format(lang.GetMessage("Buff.Personal_Explosive_Reduction_Extended.Description.ReducesFireDamage", this, userid), config.buff_settings.raid_perk_settings.personal_explosive_reduction_settings.fire_damage_reduction);
                    if (config.buff_settings.raid_perk_settings.personal_explosive_reduction_settings.blacklist.Count > 0) personal_explosive_reduction_string += string.Format(lang.GetMessage("UIExcludesList", this, userid), string.Join(", ", config.buff_settings.raid_perk_settings.personal_explosive_reduction_settings.blacklist));
                    return personal_explosive_reduction_string;

                case Buff.Explosion_Radius:
                    string Explosion_Radius_string = null;
                    if (config.buff_settings.raid_perk_settings.Explosion_Radius_settings.raidable_bases_only && RaidableBases != null && RaidableBases.IsLoaded) Explosion_Radius_string += lang.GetMessage("OnlyWorksWithRaidableBases", this, userid);
                    if (config.buff_settings.raid_perk_settings.Explosion_Radius_settings.blacklist.Count > 0) Explosion_Radius_string += string.Format(lang.GetMessage("UIExcludesList", this, userid), string.Join(", ", config.buff_settings.raid_perk_settings.Explosion_Radius_settings.blacklist));
                    return Explosion_Radius_string;

                case Buff.Double_Explosion_Chance:
                    string Double_Explosion_Chance_string = null;
                    if (config.buff_settings.raid_perk_settings.Double_Explosion_chance_settings.raidable_bases_only && RaidableBases != null && RaidableBases.IsLoaded) Double_Explosion_Chance_string += lang.GetMessage("OnlyWorksWithRaidableBases", this, userid);
                    if (config.buff_settings.raid_perk_settings.Double_Explosion_chance_settings.blacklist.Count > 0) Double_Explosion_Chance_string += string.Format(lang.GetMessage("UIExcludesList", this, userid), string.Join(", ", config.buff_settings.raid_perk_settings.Double_Explosion_chance_settings.blacklist));
                    if (!config.ultimate_settings.ultimate_raiding.allow_doubling) Double_Explosion_Chance_string += lang.GetMessage("Buff.Double_Explosion_Chance_Extended.Description", this, userid);
                    return Double_Explosion_Chance_string;

                case Buff.Lock_Picker:
                    string Lock_Picker_string = config.buff_settings.raid_perk_settings.Lock_Picker_settings.raidable_bases_only && RaidableBases != null && RaidableBases.IsLoaded ? lang.GetMessage("OnlyWorksWithRaidableBases", this, userid) : null;
                    Lock_Picker_string += string.Format(lang.GetMessage("Buff.Lock_Picker_Extended.Description.Command", this, userid), config.buff_settings.raid_perk_settings.Lock_Picker_settings.pick_command);
                    Lock_Picker_string += string.Format(lang.GetMessage("Buff.Lock_Picker_Extended.Description.Cooldown", this, userid), config.buff_settings.raid_perk_settings.Lock_Picker_settings.use_delay);
                    return Lock_Picker_string;

                case Buff.Mining_Yield:
                    string miningString = string.Empty;
                    if (config.tools_black_white_list_settings.power_tool_modifier.mining_yield_modifier != 1) miningString += string.Format(lang.GetMessage("Buff.Mining_Yield_Extended.Description", this, userid), config.tools_black_white_list_settings.power_tool_modifier.mining_yield_modifier < 1 ? "-" : "+", (1 - config.tools_black_white_list_settings.power_tool_modifier.mining_yield_modifier) * 100);
                    return miningString;

                case Buff.Woodcutting_Luck:
                case Buff.Woodcutting_Coal:
                case Buff.Instant_Chop:
                case Buff.Regrowth:
                    return config.tools_black_white_list_settings.power_tool_modifier.woodcutting_luck_modifier != 1 ? string.Format(lang.GetMessage("WoodcuttingLuckModifierDescription", this, userid), config.tools_black_white_list_settings.power_tool_modifier.woodcutting_luck_modifier < 1 ? "-" : "+", (1 - config.tools_black_white_list_settings.power_tool_modifier.woodcutting_luck_modifier) * 100) : null;

                case Buff.Instant_Mine:
                case Buff.Smelt_On_Mine:
                case Buff.Node_Spawn_Chance:
                case Buff.Mining_Luck:
                    return config.tools_black_white_list_settings.power_tool_modifier.mining_luck_modifier != 1 ? string.Format(lang.GetMessage("MiningLuckModifierDescription", this, userid), config.tools_black_white_list_settings.power_tool_modifier.mining_luck_modifier < 1 ? "-" : "+", (1 - config.tools_black_white_list_settings.power_tool_modifier.mining_luck_modifier) * 100) : null;


                case Buff.Skinning_Luck:
                case Buff.Skin_Cook:
                case Buff.Instant_Skin:
                    return config.tools_black_white_list_settings.power_tool_modifier.skinning_luck_modifier != 1 ? string.Format(lang.GetMessage("SkinningLuckModifierDescription", this, userid), config.tools_black_white_list_settings.power_tool_modifier.skinning_luck_modifier < 1 ? "-" : "+", (1 - config.tools_black_white_list_settings.power_tool_modifier.skinning_luck_modifier) * 100) : null;

                case Buff.Woodcutting_Yield:
                    string woodcuttingString = string.Empty;
                    if (config.tools_black_white_list_settings.power_tool_modifier.woodcutting_yield_modifier != 1) woodcuttingString += string.Format(lang.GetMessage("Buff.Woodcutting_Yield.Description", this, userid), config.tools_black_white_list_settings.power_tool_modifier.woodcutting_yield_modifier < 1 ? "-" : "+", (1 - config.tools_black_white_list_settings.power_tool_modifier.woodcutting_yield_modifier) * 100);
                    return woodcuttingString;

                case Buff.Skinning_Yield:
                    string skinningString = string.Empty;
                    if (config.tools_black_white_list_settings.power_tool_modifier.skinning_yield_modifier != 1) skinningString += string.Format(lang.GetMessage("Buff.Skinning_Yield_Extended.Description", this, userid), config.tools_black_white_list_settings.power_tool_modifier.skinning_yield_modifier < 1 ? "-" : "+", (1 - config.tools_black_white_list_settings.power_tool_modifier.skinning_yield_modifier) * 100);
                    return skinningString;

                case Buff.AnimalTracker: return config.buff_settings.track_delay > 0 ? string.Format(lang.GetMessage("Buff.Cooldown", this, userid), config.buff_settings.track_delay, lang.GetMessage("Seconds", this, userid)) : null;

                case Buff.HealthRegen: return config.buff_settings.health_regen_combat_delay > 0 ? string.Format(lang.GetMessage("Buff.HealthRegen.Delay", this, userid), config.buff_settings.health_regen_combat_delay) : null;

                case Buff.PVP_Critical: return string.Format(lang.GetMessage("Buff.PVP_Critical.Amount", this, userid), config.buff_settings.pvp_critical_modifier * 100);

                case Buff.Loot_Pickup:
                    string Loot_Pickup_string = null;
                    if (config.buff_settings.lootPickupBuffMeleeOnly) Loot_Pickup_string += lang.GetMessage("Buff.Loot_Pickup.MeleeOnly", this, userid);
                    if (config.buff_settings.loot_pickup_buff_max_distance > 0) Loot_Pickup_string += string.Format(lang.GetMessage("Buff.Loot_Pickup.Distance", this, userid), config.buff_settings.loot_pickup_buff_max_distance);
                    return Loot_Pickup_string;

                case Buff.Animal_Damage_Resist: return string.Format(lang.GetMessage("Buff.Animal_Damage_Resist.Animals", this, userid), FormatAnimalNames(config.buff_settings.animals, userid));

                case Buff.ExtraPockets: return config.buff_settings.bag_cooldown_time > 0 ? string.Format(lang.GetMessage("Buff.Cooldown", this, userid), config.buff_settings.bag_cooldown_time, lang.GetMessage("Seconds", this, userid)) : null;

                case Buff.Harvest_Wild_Yield: return config.buff_settings.harvest_yield_blacklist.Count > 0 ? string.Format(lang.GetMessage("Buff.Excluded", this, userid), string.Join(", ", config.buff_settings.harvest_yield_blacklist)) : null;

                case Buff.Harvester_Ultimate: return string.Format(lang.GetMessage("Harvesting_Ultimate_Command", this, userid), config.ultimate_settings.ultimate_harvesting.gene_chat_command);

                case Buff.Forager: return string.Format(lang.GetMessage("Buff.Forager.Description", this, userid), config.buff_settings.forager_settings.command, config.buff_settings.forager_settings.cooldown);

                case Buff.Trap_Spotter: return string.Format(lang.GetMessage("Buff.Trap_Spotter.Description", this, userid), config.buff_settings.raid_perk_settings.Trap_Spotter_settings.command, config.buff_settings.raid_perk_settings.Trap_Spotter_settings.cooldown) + (config.buff_settings.raid_perk_settings.Trap_Spotter_settings.raidable_bases_only && RaidableBases != null && RaidableBases.IsLoaded ? lang.GetMessage("OnlyWorksWithRaidableBases", this, userid) : null);
                case Buff.Loot_Spotter: return string.Format(lang.GetMessage("Buff.Loot_Spotter.Description", this, userid), config.buff_settings.raid_perk_settings.Loot_Spotter_settings.command, config.buff_settings.raid_perk_settings.Loot_Spotter_settings.cooldown) + (config.buff_settings.raid_perk_settings.Loot_Spotter_settings.raidable_bases_only && RaidableBases != null && RaidableBases.IsLoaded ? lang.GetMessage("OnlyWorksWithRaidableBases", this, userid) : null);

                case Buff.UnderwaterDamageBonus: return "\n" + string.Format(lang.GetMessage("UnderwaterDamageBonusPVP", this, userid), config.buff_settings.UnderwaterDamageBonus_pvp);
                case Buff.Mining_Ultimate: return "\n" + string.Format(lang.GetMessage("Mining_Ultimate_Command", this, userid), config.ultimate_settings.ultimate_mining.find_node_cmd);
                default: return null;
            }
        }

        List<string> GetSonarNames(BasePlayer player)
        {
            List<string> result = Pool.Get<List<string>>();
            if (config.buff_settings.sonar_settings.show_scientists) result.Add(lang.GetMessage(SonarType.Scientist.ToString(), this, player.UserIDString));
            if (config.buff_settings.sonar_settings.show_tugboats) result.Add(lang.GetMessage(SonarType.Tugboat.ToString(), this, player.UserIDString));
            if (config.buff_settings.sonar_settings.show_sharks) result.Add(lang.GetMessage(SonarType.Shark.ToString(), this, player.UserIDString));
            if (config.buff_settings.sonar_settings.show_dive_sites) result.Add(lang.GetMessage(SonarType.DiveSite.ToString(), this, player.UserIDString));
            if (config.buff_settings.sonar_settings.show_players) result.Add(lang.GetMessage(SonarType.Player.ToString(), this, player.UserIDString));
            return result;
        }

        string FormatAnimalNames(HashSet<string> stringArray, string userid)
        {
            var result = string.Empty;
            foreach (var animal in stringArray)
            {
                if (string.IsNullOrEmpty(result)) result = lang.GetMessage(animal, this, userid);
                else result += ", " + lang.GetMessage(animal, this, userid);
            }

            return result;
        }

        [ConsoleCommand("stsendplayersettingsmenu")]
        void SendPlayerSettings(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            SkillTree_PlayerMenu(player);
        }

        [ConsoleCommand("stsendbuffsettingsmenu")]
        void SendBuffSettings(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            SendPlayerSettingsMenu(player);
        }

        [ConsoleCommand("stsendpresetsettingsmenu")]
        void SendPresetSettings(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            SendPresetMenu(player);
        }

        [ConsoleCommand("stsendultimatesettingsmenu")]
        void SendUltimateSettingsMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            SkillTree_UltimateMenu(player);
        }

        #endregion

        #region Navigation Menu

        private void NavigationMenu(BasePlayer player)
        {
            if (!config.general_settings.show_navigation_buttons) return;

            TreeInfo ti;
            if (!TreeData.TryGetValue(player.userID, out ti))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - SendSkillTreeMenu. [Online = {player.IsConnected}]", this, true);
                return;
            }
            if (ti.trees == null || ti.trees.Count == 0)
            {
                CuiHelper.DestroyUi(player, "SkillTreeBackPanel");
                Player.Message(player, "You do not have any tree permissions. Please apply permission skilltree.<category> if you want to allocate individual trees, or skilltree.all if you want players to access all categories.", config.misc_settings.ChatID);
                return;
            }
            List<string> trees = Pool.Get<List<string>>();
            trees.AddRange(ti.trees.Keys);

            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "1 1 1 0" },
                RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-30.175 -32", OffsetMax = "29.825 -12" }
            }, "Overlay", "NavigationMenu");

            var elementCount = trees.Count < 12 ? trees.Count : 12;
            var totalLength = 0 - ((elementCount * 80) + (elementCount * 10));
            var startOffsetModifier = totalLength / 2;
            var count = 0;
            var row = 0;

            for (int i = 0; i < trees.Count; i++)
            {
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0.1686275 0.1686275 0.1686275 1" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{startOffsetModifier + (count * 10) + (count * 80)} {-10 - (row * 5) - (row * 20)}", OffsetMax = $"{startOffsetModifier + (count * 10) + 80 + (count * 80)} {10 - (row * 5) - (row * 20)}" }
                }, "NavigationMenu", $"Tree_{i}");

                container.Add(new CuiButton
                {
                    Button = { Color = "0.3568628 0.3568628 0.3568628 0.8784314", Command = $"navigatetotree {i} {trees[i]}" },
                    Text = { Text = lang.GetMessage(trees[i], this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-38 -8", OffsetMax = "38 8" }
                }, $"Tree_{i}", "Button");

                count++;
                if (count > 12)
                {
                    row++;
                    count = 0;
                }
            }

            Pool.FreeUnmanaged(ref trees);
            CuiHelper.DestroyUi(player, "NavigationMenu");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("navigatetotree")]
        void NavigateToTree(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            if (!int.TryParse(arg.Args[0], out var index)) return;
            var tree = string.Join("_", arg.Args.Skip(1));
            SendBaseMenu(player, tree, config.general_settings.respecType == RespecType.Tree);
            var container = new CuiElementContainer();
            TreeNavButtons(player, index, container);
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region XPMenu

        string UnmodifiedCol;
        string ModifiedCol;
        string STXPEventModifiedCol;

        void DisplayXPMenu(BasePlayer player, double xp, int modifiedType)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "XP_Tick",
                Parent = "Overlay",
                Components = {
                    new CuiTextComponent { Text = string.Format(lang.GetMessage("popupxpstring", this, player.UserIDString), modifiedType == 2 ? STXPEventModifiedCol : modifiedType == 1 ? ModifiedCol : UnmodifiedCol, Math.Round(xp, config.xp_settings.xp_rounding)), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-50 244", OffsetMax = "50 268" }
                }
            });

            CuiHelper.DestroyUi(player, "XP_Tick");
            CuiHelper.AddUi(player, container);

            ServerMgr.Instance.Invoke(() => CuiHelper.DestroyUi(player, "XP_Tick"), config.xp_settings.xp_display_time);
        }

        #endregion

        #region respec confirmation menu

        void ConfirmRespec(BasePlayer player, double cost, string tree)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0 0 0 0.9907843" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0.011 0.009", OffsetMax = "0.011 0.339" }
            }, "Overlay", "respec_confirmation");

            string text = lang.GetMessage("UIAreYouSure", this, player.UserIDString);
            if (config.general_settings.respec_multiplier > 0)
            {
                PlayerInfo pi;
                if (pcdData.pEntity.TryGetValue(player.userID, out pi)) text += string.Format(lang.GetMessage("RespecMultiplierMsg", this, player.UserIDString), Mathf.Min(pi.respec_multiplier + config.general_settings.respec_multiplier, config.general_settings.respec_multiplier_max > 0 ? config.general_settings.respec_multiplier_max : pi.respec_multiplier + config.general_settings.respec_multiplier) * 100);
            }

            container.Add(new CuiElement
            {
                Name = "respec_confirmation_title",
                Parent = "respec_confirmation",
                Components = {
                    new CuiTextComponent { Text = text, Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-117.039 63.5", OffsetMax = "117.039 163.5" }
                }
            });

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.2358491 0.2358491 0.2358491 0.3176471" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-117.039 -16", OffsetMax = "-59.039 16" }
            }, "respec_confirmation", "respec_confirmation_bttn_panel_yes");

            container.Add(new CuiElement
            {
                Name = "respec_confirmation_bttn_text_yes",
                Parent = "respec_confirmation_bttn_panel_yes",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("ButtonYes", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-29 -16", OffsetMax = "29 16" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = $"dorespec {cost} {tree}" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-29 -16", OffsetMax = "29 16" }
            }, "respec_confirmation_bttn_text_yes", "respec_confirmation_bttn_yes");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.2358491 0.2358491 0.2358491 0.3176471" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "59.039 -16", OffsetMax = "117.039 16" }
            }, "respec_confirmation", "respec_confirmation_bttn_panel_no");

            container.Add(new CuiElement
            {
                Name = "respec_confirmation_bttn_text_no",
                Parent = "respec_confirmation_bttn_panel_no",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("ButtonNo", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-29 -16", OffsetMax = "29 16" }
                }
            });

            var cost_string = lang.GetMessage("UICost", this, player.UserIDString);
            if (config.general_settings.respec_currency.Equals("scrap", StringComparison.OrdinalIgnoreCase)) cost_string = string.Format(cost_string, $"{cost} {lang.GetMessage("UIScrap", this, player.UserIDString)}");
            else if (config.general_settings.respec_currency.Equals("economics", StringComparison.OrdinalIgnoreCase)) cost_string = string.Format(cost_string, $"{lang.GetMessage("UIDollars", this, player.UserIDString)}{cost}");
            else if (config.general_settings.respec_currency.Equals("srp", StringComparison.OrdinalIgnoreCase)) cost_string = string.Format(cost_string, $"{cost} {lang.GetMessage("UIPoints", this, player.UserIDString)}");
            else if (config.general_settings.respec_currency.Equals("shoppystock", StringComparison.OrdinalIgnoreCase)) cost_string = string.Format(cost_string, $"{cost} {lang.GetMessage("UIShoppyStock", this, player.UserIDString)}");
            else if (config.general_settings.respec_currency.Equals("custom", StringComparison.OrdinalIgnoreCase)) cost_string = string.Format(cost_string, $"{cost} {config.general_settings.respec_currency_custom.displayName}");

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = $"closerecpecconfirmation {tree}" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-29 -16", OffsetMax = "29 16" }
            }, "respec_confirmation_bttn_text_no", "respec_confirmation_bttn_no");

            container.Add(new CuiElement
            {
                Name = "respec_confirmation_cost",
                Parent = "respec_confirmation",
                Components = {
                    new CuiTextComponent { Text = cost_string, Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-68.137 28.482", OffsetMax = "68.137 63.5" }
                }
            });

            CuiHelper.DestroyUi(player, "respec_confirmation");
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Menu commands

        [ConsoleCommand("respecconfirmation")]
        void SendConfirmation(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            var cost = Convert.ToDouble(arg.Args[0]);
            var tree = arg.Args[1];
            //CuiHelper.DestroyUi(player, "SkillTree");
            ConfirmRespec(player, cost, tree);
        }

        [ConsoleCommand("closerecpecconfirmation")]
        void CloseRespecConfirmation(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            CuiHelper.DestroyUi(player, "respec_confirmation");          
        }      

        bool PaidForRespec(BasePlayer player, double cost)
        {
            if (cost <= 0) return true;
            var bypassCost = permission.UserHasPermission(player.UserIDString, perm_respec_bypass);
            if (bypassCost)
            {
                cost = 0;
                return true;
            }
            if (cost <= 0) return true;
            if (config.general_settings.respec_currency.Equals("scrap", StringComparison.OrdinalIgnoreCase))
            {
                var found = 0;
                var allItems = AllItems(player);
                foreach (var item in allItems)
                {
                    if (item.info.shortname == "scrap") found += item.amount;
                    if (found >= cost) break;
                }
                if (found < cost)
                {
                    SendPlayerMessage(player, lang.GetMessage("RespecNoScrap", this, player.UserIDString), config.misc_settings.messageSettings.RespecFail);
                    return false;
                }
                found = 0;

                foreach (var item in allItems)
                {
                    if (item.info.shortname != "scrap") continue;
                    if (item.amount + found == cost)
                    {
                        item.Remove();
                        break;
                    }
                    if (item.amount + found < cost)
                    {
                        found += item.amount;
                        item.Remove();
                    }
                    else
                    {
                        item.UseItem(Convert.ToInt32(cost) - found);
                        break;
                    }
                }
                Pool.FreeUnmanaged(ref allItems);
            }
            else if (config.general_settings.respec_currency.Equals("economics", StringComparison.OrdinalIgnoreCase))
            {
                if (Economics == null)
                {
                    SendPlayerMessage(player, lang.GetMessage("EconNotLoaded", this, player.UserIDString), config.misc_settings.messageSettings.RespecFail);
                    return false;
                }
                var playerBalance = Convert.ToDouble(Economics?.Call("Balance", player.userID.Get()));
                if (playerBalance < cost)
                {
                    SendPlayerMessage(player, lang.GetMessage("EconNoCash", this, player.UserIDString), config.misc_settings.messageSettings.RespecFail);
                    return false;
                }
                if (!Convert.ToBoolean(Economics?.Call("Withdraw", player.userID.Get(), cost)))
                {
                    SendPlayerMessage(player, lang.GetMessage("EconErrorCash", this, player.UserIDString), config.misc_settings.messageSettings.RespecFail);
                    return false;
                }
            }
            else if (config.general_settings.respec_currency.Equals("srp", StringComparison.OrdinalIgnoreCase))
            {
                if (ServerRewards == null)
                {
                    SendPlayerMessage(player, lang.GetMessage("SRNotLoaded", this, player.UserIDString), config.misc_settings.messageSettings.RespecFail);
                    return false;
                }
                var balance = Convert.ToInt32(ServerRewards.Call("CheckPoints", player.userID.Get()));
                if (balance < cost)
                {
                    SendPlayerMessage(player, lang.GetMessage("SRNoPoints", this, player.UserIDString), config.misc_settings.messageSettings.RespecFail);
                    return false;
                }
                var intCost = Convert.ToInt32(cost);
                if (!Convert.ToBoolean(ServerRewards?.Call("TakePoints", player.userID.Get(), intCost)))
                {
                    SendPlayerMessage(player, lang.GetMessage("SRPointError", this, player.UserIDString), config.misc_settings.messageSettings.RespecFail);
                    return false;
                }
            }
            else if (config.general_settings.respec_currency.Equals("shoppystock", StringComparison.OrdinalIgnoreCase))
            {
                if (ShoppyStock == null)
                {
                    SendPlayerMessage(player, lang.GetMessage("shoppystockNotLoaded", this, player.UserIDString), config.misc_settings.messageSettings.RespecFail);
                    return false;
                }
                var balance = Convert.ToInt32(ShoppyStock?.Call("GetCurrencyAmount", config.general_settings.shoppyStockInfo.shopName, player) ?? 0);
                if (balance < cost)
                {
                    SendPlayerMessage(player, lang.GetMessage("shoppystockNotEnough", this, player.UserIDString), config.misc_settings.messageSettings.RespecFail);
                    return false;
                }
                var intCost = Convert.ToInt32(cost);
                if (!Convert.ToBoolean(ShoppyStock?.Call("TakeCurrency", config.general_settings.shoppyStockInfo.shopName, player, intCost)))
                {
                    SendPlayerMessage(player, lang.GetMessage("shoppystockCurrencyError", this, player.UserIDString), config.misc_settings.messageSettings.RespecFail);
                    return false;
                }
            }
            else if (config.general_settings.respec_currency.Equals("custom", StringComparison.OrdinalIgnoreCase))
            {
                var allItems = AllItems(player);
                var found = 0;
                foreach (var item in allItems)
                {
                    if (item.skin == config.general_settings.respec_currency_custom.skin && item.info.shortname == config.general_settings.respec_currency_custom.shortname) found += item.amount;
                    if (found > cost) break;
                }
                if (found < cost)
                {
                    SendPlayerMessage(player, string.Format(lang.GetMessage("RespecNoCustom", this, player.UserIDString), config.general_settings.respec_currency_custom.displayName), config.misc_settings.messageSettings.RespecFail);
                    return false;
                }
                found = 0;
                foreach (var item in allItems)
                {
                    if (item.skin != config.general_settings.respec_currency_custom.skin || item.info.shortname != config.general_settings.respec_currency_custom.shortname) continue;
                    if (item.amount + found == cost)
                    {
                        item.Remove();
                        break;
                    }
                    if (item.amount + found < cost)
                    {
                        found += item.amount;
                        item.Remove();
                    }
                    else
                    {
                        item.UseItem(Convert.ToInt32(cost) - found);
                        break;
                    }
                }

                Pool.FreeUnmanaged(ref allItems);
            }
            return true;
        }

        #endregion

        #region Chat commands        



        [ChatCommand("resetxpbars")]
        void ResetXPBars(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, perm_admin)) return;
            if (args == null || args.Length == 0 || !bool.TryParse(args[0], out var onlineOnly))
            {
                PrintToChat(player, "Usage: /resetxpbars <true/false: online players only>");
                return;
            }

            foreach (var kvp in pcdData.pEntity)
            {
                kvp.Value.xp_bar_offset = Vector2.zero;
            }

            foreach (var p in BasePlayer.activePlayerList)
            {
                PlayerInfo pi;
                if (!pcdData.pEntity.TryGetValue(p.userID, out pi)) continue;
                UpdateXP(p, pi);
            }

            if (onlineOnly)
            {
                Player.Message(player, "Reset all xp bars for online players to default settings.", config.misc_settings.ChatID);
                return;
            }

            Player.Message(player, "Starting reset of offline xp bars.", config.misc_settings.ChatID);
            if (Offline_XPBarUpdate != null) ServerMgr.Instance.StopCoroutine(Offline_XPBarUpdate);
            Offline_XPBarUpdate = ServerMgr.Instance.StartCoroutine(UpdateOfflineXPBars(player));
        }

        Coroutine Offline_XPBarUpdate;
        bool IsResettingXPBar = false;
        IEnumerator UpdateOfflineXPBars(BasePlayer admin)
        {
            var count = 0;
            IsResettingXPBar = true;
            foreach (var file in Directory.GetFiles(NewDirectory))
            {
                count++;
                try
                {
                    var userid = FormatUserIDFromPath(file);
                    if (BasePlayer.Find(userid)) continue;
                    var obj = JsonConvert.DeserializeObject<PlayerInfo>(File.ReadAllText(file));
                    obj.xp_bar_offset = Vector2.zero;
                    File.WriteAllText(file, JsonConvert.SerializeObject(obj));
                }
                catch { }
                if (count > 50)
                {
                    count = 0;
                    yield return CoroutineEx.waitForEndOfFrame;
                }
            }
            IsResettingXPBar = false;
            if (admin != null && admin.IsConnected) Player.Message(admin, "Reset all xp bars for offline players to default settings.", config.misc_settings.ChatID);
            else Puts($"Finished resetting xp bars.");
        }

        [ChatCommand("resetxpbar")]
        void ResetXPBar(BasePlayer player)
        {
            PlayerInfo pi;
            if (!pcdData.pEntity.TryGetValue(player.userID, out pi))
            {
                Player.Message(player, "No data detected. Please reconnect to the server.", config.misc_settings.ChatID);
                return;
            }

            pi.xp_bar_offset = Vector2.zero;
            UpdateXP(player, pi);

            Player.Message(player, "Your xp bar has been reset to default settings.", config.misc_settings.ChatID);
        }

        [ChatCommand("resetallresteddata")]
        void ResetAllRestedData(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, perm_admin)) return;

            foreach (var kvp in pcdData.pEntity)
            {
                kvp.Value.xp_bonus_pool = 0;
                kvp.Value.logged_off = DateTime.Now;
            }
        }

        [ChatCommand("movebar")]
        void MoveBar(BasePlayer player)
        {
            if (!config.xp_settings.allow_move_xp_bar)
            {
                Player.Message(player, lang.GetMessage("MoveXPDisabled", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }
            UpdateXP(player, null, true);
            player.ShowToast(GameTip.Styles.Blue_Normal, lang.GetMessage("MoveBarInstructions", this, player.UserIDString), true);
        }

        void SendMenuCMD(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, "skilltree.chat"))
            {
                Player.Message(player, lang.GetMessage("NoPermsChat", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }
            SkillTreeBackPanel(player);
            NavigationMenu(player);
            SendBaseMenu(player);
        }

        [ChatCommand("togglebc")]
        void ToggleBetterChat(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, perm_toggle_bc))
            {
                PrintToChat(player, "You do not have the skilltree.togglebc permission.");
                return;
            }
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - ToggleBetterChat. [Online = {player.IsConnected}]", this, true);
                return;
            }
            if (playerData.better_chat_enabled)
            {
                Player.Message(player, lang.GetMessage("BCToggleOff", this, player.UserIDString), config.misc_settings.ChatID);
                playerData.better_chat_enabled = false;
            }

            else
            {
                Player.Message(player, lang.GetMessage("BCToggleOff", this, player.UserIDString), config.misc_settings.ChatID);
                playerData.better_chat_enabled = true;
            }
        }

        [ChatCommand("togglexpdrops")]
        void ToggleXPDrops(BasePlayer player)
        {
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - ToggleXPDrops. [Online = {player.IsConnected}]", this, true);
                return;
            }
            if (playerData.xp_drops) playerData.xp_drops = false;
            else playerData.xp_drops = true;
        }

        [ChatCommand("togglexphud")]
        void ToggleXPHud(BasePlayer player)
        {
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - ToggleXPHud. [Online = {player.IsConnected}]", this, true);
                return;
            }
            if (playerData.xp_hud)
            {
                playerData.xp_hud = false;
                CuiHelper.DestroyUi(player, "SkillTreeXPBar");
            }
            else
            {
                UpdateXP(player, playerData);
                playerData.xp_hud = true;
            }
        }

        [ChatCommand("sttogglenotifications")]
        void ToggleNotifications(BasePlayer player)
        {
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - ToggleNotifications. [Online = {player.IsConnected}]", this, true);
                return;
            }
            if (playerData.notifications)
            {
                Player.Message(player, lang.GetMessage("notificationsOff", this, player.UserIDString), config.misc_settings.ChatID);
                playerData.notifications = false;
            }

            else
            {
                Player.Message(player, lang.GetMessage("notificationsOn", this, player.UserIDString), config.misc_settings.ChatID);
                playerData.notifications = true;
            }

        }

        [ConsoleCommand("givexp")]
        void GiveXPConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;

            if (arg.Args == null || arg.Args.Length < 2)
            {
                arg.ReplyWith(lang.GetMessage("GiveXPUsageConsole", this, player?.UserIDString ?? null));
                return;
            }

            bool ignoreXPMods;
            bool foundBoolArg = false;
            if (!Boolean.TryParse(arg.Args.Last(), out ignoreXPMods)) ignoreXPMods = false;
            else foundBoolArg = true;

            double xp;
            if (!double.TryParse(arg.Args[arg.Args.Length - 1], out xp))
            {
                if (!double.TryParse(arg.Args[arg.Args.Length - 2], out xp))
                {
                    arg.ReplyWith(lang.GetMessage("GiveXPUsageConsole", this, player?.UserIDString ?? null));
                    return;
                }
            }

            var name = String.Join(" ", arg.Args.Take(arg.Args.Length - (foundBoolArg ? 2 : 1)));
            var target = name.IsNumeric() ? FindPlayerByID(name, player ?? null) : FindPlayerByName(name, player ?? null);
            if (target == null)
            {
                if (config.xp_settings.givexp_offline && ulong.TryParse(name, out var userid)) GiveXPOffline(userid, xp);
                return;
            }
            AwardXP(target, xp, null, ignoreXPMods, false, "console");
            PrintToChat(target, string.Format(lang.GetMessage("GaveXP", this, target.UserIDString), xp, player != null ? player.displayName : "Console"));
            arg.ReplyWith(string.Format(lang.GetMessage("ReceivedXP", this), target.displayName, xp));
        }

        void GiveXPOffline(ulong id, double xp)
        {
            if (xp == 0) return;
            var obj = OpenOfflinePlayerData(id, out var file);
            if (obj == null) return;
            obj.pending_xp_with_bonus += xp;
            File.WriteAllText(file, JsonConvert.SerializeObject(obj));
        }

        [ConsoleCommand("givexpdebt")]
        void GiveXPDebt(ConsoleSystem.Arg arg)
        {
            var admin = arg.Player();
            if (admin != null && !permission.UserHasPermission(admin.UserIDString, perm_admin)) return;

            if (arg.Args == null || arg.Args.Length < 2)
            {
                arg.ReplyWith(lang.GetMessage("GiveXPDebtUsageConsole", this, admin?.UserIDString ?? null));
                return;
            }

            double xp;
            if (!double.TryParse(arg.Args[arg.Args.Length - 1], out xp))
            {
                if (!double.TryParse(arg.Args[arg.Args.Length - 2], out xp))
                {
                    arg.ReplyWith(lang.GetMessage("GiveXPDebtUsageConsole", this, admin?.UserIDString ?? null));
                    return;
                }
            }

            var name = String.Join(" ", arg.Args.Take(arg.Args.Length -  1));
            var target = name.IsNumeric() ? FindPlayerByID(name, admin ?? null) : FindPlayerByName(name, admin ?? null);
            if (target == null)
            {
                if (config.xp_settings.givexpdebt_offline && ulong.TryParse(name, out var userid)) GiveXPDebtOffline(userid, xp);
                return;
            }

            if (!pcdData.pEntity.TryGetValue(target.userID, out var playerData))
            {
                arg.ReplyWith($"Could not find data for player: {target.displayName}");
                return;
            }

            playerData.xp_debt += xp;
            UpdateXP(target, playerData);
            if (admin != null) arg.ReplyWith($"Gave {target.displayName} +{xp} xp debt.");
        }

        void GiveXPDebtOffline(ulong id, double xp)
        {
            if (xp == 0) return;
            var obj = OpenOfflinePlayerData(id, out var file);
            if (obj == null) return;
            obj.xp_debt += xp;
            File.WriteAllText(file, JsonConvert.SerializeObject(obj));
        }

        PlayerInfo OpenOfflinePlayerData(ulong id, out string path)
        {
            path = null;
            if (!id.IsSteamId()) return null;
            foreach (var file in Directory.GetFiles(NewDirectory))
            {
                if (!ulong.TryParse(FormatUserIDFromPath(file), out var fileID) || fileID != id) continue;
                var obj = JsonConvert.DeserializeObject<PlayerInfo>(File.ReadAllText(file));

                path = file;
                return obj;
            }
            return null;
        }

        [ChatCommand("givexp")]
        void GiveXPCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;
            if (args.Length == 0)
            {
                Player.Message(player, lang.GetMessage("GiveXPUsage", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }
            if (!args.Last().IsNumeric())
            {
                Player.Message(player, lang.GetMessage("XPLastArg", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }
            var xp = Convert.ToDouble(args.Last());
            var name = String.Join(" ", args.Take(args.Length - 1));
            var target = FindPlayerByName(name, player);
            if (target == null) return;
            AwardXP(target, xp, null, false, false, "chat command");
            PrintToChat(target, string.Format(lang.GetMessage("GaveXP", this, target.UserIDString), xp, player.displayName));
            Player.Message(player, string.Format(lang.GetMessage("ReceivedXP", this, player.UserIDString), target.displayName, xp), config.misc_settings.ChatID);
        }



        [ConsoleCommand("givesp")]
        void GiveSkillPointsConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;

            if (arg.Args.IsNullOrEmpty() || arg.Args.Length < 2 || !arg.Args.Last().IsNumeric())
            {
                arg.ReplyWith(lang.GetMessage("GiveSPUsage", this));
                return;
            }
            var amount = Convert.ToInt32(arg.Args.Last());
            var name = String.Join(" ", arg.Args.Take(arg.Args.Length - 1));
            var target = name.IsNumeric() ? FindPlayerByID(name, player ?? null) : FindPlayerByName(name, player ?? null);
            if (target == null)
            {
                if (config.xp_settings.givesp_offline && ulong.TryParse(name, out var userid)) GiveSPOffline(userid, amount);
                return;
            }
            GiveSkillPoints(target, amount);
            arg.ReplyWith(string.Format(lang.GetMessage("GaveSP", this), amount, target.displayName));
        }

        void GiveSPOffline(ulong id, int amount)
        {
            if (amount == 0) return;
            if (!id.IsSteamId()) return;
            foreach (var file in Directory.GetFiles(NewDirectory))
            {
                if (!ulong.TryParse(FormatUserIDFromPath(file), out var fileID) || fileID != id) continue;
                var obj = JsonConvert.DeserializeObject<PlayerInfo>(File.ReadAllText(file));
                obj.available_points += amount;
                File.WriteAllText(file, JsonConvert.SerializeObject(obj));
            }
        }

        [ConsoleCommand("givesptoall")]
        void GiveSkillPointsToAllConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;

            bool onlineOnly;
            int amount;
            if (arg.Args == null || arg.Args.Length < 2 || !int.TryParse(arg.Args[0], out amount) || amount < 1 || !Boolean.TryParse(arg.Args[1], out onlineOnly))
            {
                arg.ReplyWith("Usage: givesptoall <amount> <online only: true/false>");
                return;
            }

            foreach (var p in BasePlayer.activePlayerList)
            {
                GiveSkillPoints(p, amount);
            }

            if (onlineOnly)
            {
                arg.ReplyWith($"Added {amount} skill points to all online players.");
                return;
            }

            if (IsGivingOfflineSP)
            {
                arg.ReplyWith("Still currently giving skill points to players.");
                return;
            }
            arg.ReplyWith($"Starting routine to give {amount}x skill points to all players.");
            if (OfflineSP_Routine != null) ServerMgr.Instance.StopCoroutine(OfflineSP_Routine);
            OfflineSP_Routine = ServerMgr.Instance.StartCoroutine(GiveOfflinePlayersSP(amount, arg));
        }

        Coroutine OfflineSP_Routine;
        bool IsGivingOfflineSP = false;
        IEnumerator GiveOfflinePlayersSP(int amount, ConsoleSystem.Arg arg)
        {
            var count = 0;
            IsGivingOfflineSP = true;
            foreach (var file in Directory.GetFiles(NewDirectory))
            {
                count++;
                try
                {
                    var userid = FormatUserIDFromPath(file);
                    if (BasePlayer.Find(userid)) continue;
                    var obj = JsonConvert.DeserializeObject<PlayerInfo>(File.ReadAllText(file));
                    obj.available_points += amount;
                    File.WriteAllText(file, JsonConvert.SerializeObject(obj));
                }
                catch { }
                if (count > 50)
                {
                    count = 0;
                    yield return CoroutineEx.waitForEndOfFrame;
                }
            }
            IsGivingOfflineSP = false;
            Puts($"Finished giving offline players SP.");
        }

        [ConsoleCommand("givexptoall")]
        void GiveXPToAllConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;

            bool onlineOnly;
            double amount;
            if (arg.Args == null || arg.Args.Length < 2 || !double.TryParse(arg.Args[0], out amount) || amount <= 0 || !Boolean.TryParse(arg.Args[1], out onlineOnly))
            {
                arg.ReplyWith("Usage: givexptoall <amount> <online only: true/false> <Optional: no mods: true/false");
                return;
            }

            bool noMod = false;
            if (arg.Args.Length == 3) Boolean.TryParse(arg.Args[2], out noMod);

            foreach (var p in BasePlayer.activePlayerList)
            {
                AwardXP(p, amount, null, noMod, false, "command");
            }

            if (onlineOnly)
            {
                arg.ReplyWith($"Added {amount} xp to all online players.");
                return;
            }
            if (IsGivingOfflineXP)
            {
                arg.ReplyWith("Still currently giving xp to players.");
                return;
            }
            arg.ReplyWith($"Starting routine to give {amount}x xp to all players.");
            if (OfflineXP_Routine != null) ServerMgr.Instance.StopCoroutine(OfflineXP_Routine);
            OfflineXP_Routine = ServerMgr.Instance.StartCoroutine(GiveOfflinePlayersXP(amount, noMod));
        }

        Coroutine OfflineXP_Routine;
        bool IsGivingOfflineXP = false;
        IEnumerator GiveOfflinePlayersXP(double amount, bool noMod)
        {
            var count = 0;
            IsGivingOfflineXP = true;
            foreach (var file in Directory.GetFiles(NewDirectory))
            {
                count++;
                try
                {
                    var userid = FormatUserIDFromPath(file);
                    var obj = JsonConvert.DeserializeObject<PlayerInfo>(File.ReadAllText(file));
                    if (noMod)
                    {
                        obj.pending_xp_without_bonus += amount;
                        if (config.xp_settings.pending_xp_cap > 0 && obj.pending_xp_without_bonus > config.xp_settings.pending_xp_cap) obj.pending_xp_without_bonus = config.xp_settings.pending_xp_cap;
                    }
                    else
                    {
                        obj.pending_xp_with_bonus += amount;
                        if (config.xp_settings.pending_xp_cap > 0 && obj.pending_xp_with_bonus > config.xp_settings.pending_xp_cap) obj.pending_xp_with_bonus = config.xp_settings.pending_xp_cap;
                    }

                    File.WriteAllText(file, JsonConvert.SerializeObject(obj));
                }
                catch { }
                if (count > 25)
                {
                    count = 0;
                    yield return CoroutineEx.waitForEndOfFrame;
                }
            }
            IsGivingOfflineXP = false;
            Puts($"Finished giving offline players xp.");
        }

        [ChatCommand("givesp")]
        void GiveSkillPoints(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;
            if (args.Length < 2 || !args.Last().IsNumeric())
            {
                Player.Message(player, lang.GetMessage("GiveSPUsage", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }
            var amount = Convert.ToInt32(args.Last());
            var target = FindPlayerByName(String.Join(" ", args.Take(args.Length - 1)), player);
            if (target == null) return;

            GiveSkillPoints(target, amount);
            Player.Message(player, string.Format(lang.GetMessage("GaveSP", this, player.UserIDString), amount, target.displayName), config.misc_settings.ChatID);
        }

        [ConsoleCommand("resetdata")]
        void ResetXPConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                arg.ReplyWith(lang.GetMessage("ResetXPUsage", this));
                return;
            }
            var name = String.Join(" ", arg.Args);
            var target = name.IsNumeric() ? FindPlayerByID(name, player ?? null) : FindPlayerByName(name, player ?? null);
            if (target == null) return;
            HandleDataReset(target);
            arg.ReplyWith(string.Format(lang.GetMessage("ResetData", this), target.displayName));
        }

        [ChatCommand("resetdata")]
        void ResetXP(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;
            if (args.Length == 0)
            {
                Player.Message(player, lang.GetMessage("ResetXPUsage", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }
            var target = FindPlayerByName(string.Join(" ", args), player);
            if (target == null) return;
            HandleDataReset(target);
            Player.Message(player, string.Format(lang.GetMessage("ResetData", this, player.UserIDString), target.displayName), config.misc_settings.ChatID);
        }

        void HandleDataReset(BasePlayer target)
        {
            if (target == null || target.IsNpc || !target.userID.IsSteamId()) return;
            DoClear(target, true);

            PlayerInfo pi;
            if (pcdData.pEntity.TryGetValue(target.userID, out pi))
            {
                RemovePrestigeGroup(target.UserIDString, pi.prestige_level);
                RunResetCommands(target.UserIDString, Math.Max(pi.current_level, pi.achieved_level));
            }
            if (TreeData.ContainsKey(target.userID)) TreeData.Remove(target.userID);
            buffDetails.Remove(target.userID);
            LoggingOff(target, false);

            File.Delete(NewDirectory + $"{target.userID}.json");

            HandleNewConnection(target);
            LoadBuffs();
        }

        [ConsoleCommand("stresetalldata")]
        void ResetAllDataConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;

            ResetAllDataCommand(player, true);
        }

        void ResetAllDataCommand(BasePlayer player = null, bool fromConsole = true)
        {
            foreach (var p in BasePlayer.activePlayerList)
            {
                DoClear(p, true);
                LoggingOff(p, true);
            }

            List<string> files = Pool.Get<List<string>>();
            files.AddRange(Directory.GetFiles(NewDirectory));

            foreach (var user in files)
            {
                var id = FormatUserIDFromPath(user);

                RemovePerms(id, true);
                var obj = JsonConvert.DeserializeObject<PlayerInfo>(File.ReadAllText(user));
                if (obj != null) RunResetCommands(id, obj.prestige_level > 0 ? GetHighestLevelReward : Math.Max(obj.current_level, obj.achieved_level));
            }
            Pool.FreeUnmanaged(ref files);

            buffDetails.Clear();
            pcdData.pEntity.Clear();
            TreeData.Clear();
            ClearPrestigeGroup();
            DeleteAllPlayerFiles();
            if (fromConsole)
            {
                if (player == null) Puts("Reset all data.");
                else PrintToConsole(player, "Reset all data.");
            }
            else PrintToChat(player, "Reset all data.");

            if (BasePlayer.activePlayerList != null && BasePlayer.activePlayerList.Count > 0)
            {
                foreach (var p in BasePlayer.activePlayerList)
                {
                    HandleNewConnection(p);
                }
            }
            SaveData();
            LoadBuffs();
        }

        void DeleteAllPlayerFiles()
        {
            List<string> files = Pool.Get<List<string>>();
            files.AddRange(Directory.GetFiles(NewDirectory));
            foreach (var file in files)
            {
                File.Delete(file);
            }
            Pool.FreeUnmanaged(ref files);
        }

        [ChatCommand("stresetalldata")]
        void ResetAllData(BasePlayer player = null)
        {
            if (player != null && !permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;
            ResetAllDataCommand(player, false);
        }

        int GetHighestLevelReward
        {
            get
            {
                var result = 0;
                foreach (var level in config.general_settings.level_rewards)
                    if (level.Key > result) result = level.Key;

                return result;
            }
        }

        [ConsoleCommand("strespecplayer")]
        void ResetSkillsConsoleSingle(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                arg.ReplyWith("Usage: strespecplayer <target name/ID>");
                return;
            }

            var target = FindPlayerByName(string.Join(" ", arg.Args), null, false) ?? FindPlayerByID(arg.Args[0], null, false);
            if (target == null)
            {
                arg.ReplyWith($"No player found that matched {string.Join(" ", arg.Args)}");
                //arg.ReplyWith($"{string.Join(", ", BasePlayer.activePlayerList.Select(x=>x.displayName))}");
                return;
            }

            if (pcdData.pEntity.TryGetValue(target.userID, out var playerData))
            {
                RespecPlayer(target, playerData);

                arg.ReplyWith($"Respeced: {target.displayName}.");
                return;
            }

            playerData = LoadPlayerData(target.UserIDString);
            if (playerData == null)
            {
                arg.ReplyWith($"No player data found for {target.displayName}");
                return;
            }

            HandleRespec(target, playerData);
            arg.ReplyWith($"Respeced: {target.displayName}.");
        }

        [ConsoleCommand("strespecallplayers")]
        void ResetSkillsCMD(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;

            ResetSkills(player);
            arg.ReplyWith("Respecced all players.");
        }

        void ResetSkills(BasePlayer player = null)
        {
            if (BasePlayer.activePlayerList != null && BasePlayer.activePlayerList.Count > 0)
            {
                foreach (var p in BasePlayer.activePlayerList)
                {
                    DoClear(p, true);
                    LoggingOff(p, true);
                }
            }
            buffDetails.Clear();
            TreeData.Clear();
            List<string> files = Pool.Get<List<string>>();
            files.AddRange(Directory.GetFiles(NewDirectory));
            foreach (var file in files)
            {
                try
                {
                    var obj = JsonConvert.DeserializeObject<PlayerInfo>(File.ReadAllText(file));
                    if (obj == null) continue;
                    int pointCount = 0;
                    foreach (var buff in obj.buff_values)
                    {
                        pointCount += buff.Value;
                    }
                    obj.available_points += pointCount;
                    var userid = FormatUserIDFromPath(file);
                    var pointsPerLevel = GetPointsPerLevel(userid);
                    if (pointsPerLevel * obj.current_level > obj.available_points) obj.available_points = pointsPerLevel * obj.current_level;
                    obj.buff_values.Clear();
                    obj.ultimate_settings.Clear();

                    RemovePerms(userid, true);
                    //kvp.Value.available_points = config.general_settings.points_per_level * kvp.Value.current_level;
                    File.WriteAllText(file, JsonConvert.SerializeObject(obj));
                }
                catch { }

            }

            Pool.FreeUnmanaged(ref files);

            if (BasePlayer.activePlayerList != null && BasePlayer.activePlayerList.Count > 0)
            {
                foreach (var p in BasePlayer.activePlayerList)
                {
                    HandleNewConnection(p);
                    Player.Message(p, lang.GetMessage("PointsRefunded", this, p.UserIDString), config.misc_settings.ChatID);
                }
            }
            if (player != null) Player.Message(player, lang.GetMessage("PointsRefundedAll", this, player.UserIDString), config.misc_settings.ChatID);

            SaveData();
            LoadBuffs();
        }

        #endregion

        #region API   

        [HookMethod("STGetExtraPocketsItems")]
        List<object[]> STGetExtraPocketsItems(ulong id)
        {
            if (!pcdData.pEntity.TryGetValue(id, out var playerData))
                playerData = OpenOfflinePlayerData(id, out var fileName);

            if (playerData == null || playerData.pouch_items.Count == 0) return null;

            List<object[]> result = new List<object[]>();
            foreach (var item in playerData.pouch_items)
            {
                result.Add(item.ToObject());
            }
            return result;
        }

        void OnInstantGatherTrigger(BasePlayer player, ResourceDispenser dispenser, string pluginName)
        {
            if (pluginName == this.Name) return;
            if (!GetBuffDetails(player.userID, out var bd)) return;
            float value;
            float teaMod = 0;
            switch (dispenser.gatherType)
            {
                case ResourceDispenser.GatherType.Ore:
                    value = bd.GetBuffValue(Buff.Mining_Yield);
                    teaMod = player.modifiers.GetValue(Modifier.ModifierType.Ore_Yield, 0);
                    break;
                case ResourceDispenser.GatherType.Tree:
                    value = bd.GetBuffValue(Buff.Woodcutting_Yield);
                    teaMod = player.modifiers.GetValue(Modifier.ModifierType.Wood_Yield, 0);
                    break;
                case ResourceDispenser.GatherType.Flesh:
                    value = bd.GetBuffValue(Buff.Skinning_Yield);
                    break;

                default:
                    value = 0;
                    break;
            }

            if (value == 0) return;
            if (config.misc_settings.prevent_tea_bonus_on_yields) teaMod = 0;
            foreach (var r in dispenser.containedItems)
            {
                if (r.amount < 1) continue;
                //var amount_to_give = Convert.ToInt32(Math.Round((item != null && r.itemDef != null && item.info.shortname == r.itemDef.shortname ? r.amount - item.amount : r.amount) * value, 0, MidpointRounding.AwayFromZero));
                var amount = r.amount * value;
                amount += amount * teaMod;
                if (amount < 1) continue;

                player.GiveItem(ItemManager.CreateByItemID(r.itemDef.itemid, Mathf.FloorToInt(amount)));
            }
        }

        [HookMethod("STGetMaxLevel")]
        public int STGetMaxLevel()
        {
            return config.general_settings.max_player_level;
        }

        [HookMethod("GetSkillTreeData")]
        public object GetSkillTreeData()
        {
            var sTStats = new Dictionary<ulong, (string Name, double XP, int PrestigeLevel, int CurrentLevel, double XPDebt)>();
            var dataFiles = Directory.GetFiles(NewDirectory, "*.json", SearchOption.TopDirectoryOnly);

            foreach (var file in dataFiles)
            {
                try
                {
                    var playerId = Path.GetFileNameWithoutExtension(file);
                    if (!ulong.TryParse(playerId, out ulong playerID))
                    {
                        continue;
                    }

                    var playerInfo = LoadPlayerData(playerId);

                    if (playerInfo != null)
                    {
                        sTStats[playerID] = (
                            playerInfo.name,
                            playerInfo.xp,
                            playerInfo.prestige_level,
                            playerInfo.current_level,
                            playerInfo.xp_debt
                         );
                    }
                }
                catch (Exception ex)
                {
                    PrintWarning($"Exception while processing file {file}: {ex.Message}");
                }
            }
            return sTStats;
        }

        [HookMethod("RemoteUpdatePlayerStats")]
        public void RemoteUpdatePlayerStats(string userid, string json)
        {
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(Convert.ToUInt64(userid), out playerData))
            {
                WriteJson(userid, json);
                Puts($"Overwrote data for {userid}");
                return;
            }
            var player = BasePlayer.Find(userid);
            if (player == null) return;
            DoClear(player, true);
            LoggingOff(player, true);
            WriteJson(player.UserIDString, json);
            Puts($"Overwrote data for {userid}");
            HandleNewConnection(player);

            if (playerData.prestige_level > 0 && config.prestige_settings.ignore_level_rewards) return;
            for (int i = 0; i < playerData.current_level; i++)
            {
                GiveRewards(player, i);
            }
        }

        // Returns the players total buff value for a buff.
        [HookMethod("GetBuffValue")]
        float GetBuffValue(BasePlayer player, string skill)
        {
            if (!player.IsConnected) return 0f;
            Buff buff;
            if (!Enum.TryParse(skill, out buff))
            {
                Puts($"Invalid skill: " + skill);
                return 0f;
            }

            float result;
            BuffDetails buffData;
            if (GetBuffDetails(player.userID, out buffData) && buffData.GetBuff(buff, out result)) return result;

            return 0f;
        }

        [HookMethod("GetXPStats")]
        object[] GetXPStats(ulong id)
        {
            /*
                Returns:    - Current level (int)
                            - Current total xp (double)
                            - XP value that the currently level started at (double)
                            - XP value that the next level will start at (double)
                            - XP Debt
                            - PrestigeLevel
             */

            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(id, out playerData)) return null;

            double currentXP = playerData.xp;
            int currentLevel = playerData.current_level;
            double currentLevelStartXP = config.level.GetLevelStartXP(currentLevel);
            double nextLevelStartXP = config.level.GetLevelStartXP(currentLevel + 1);
            double xpDebt = playerData.xp_debt;
            int prestigeLevel = playerData.prestige_level;

            var result = new object[] { currentLevel, currentXP, currentLevelStartXP, nextLevelStartXP, xpDebt, prestigeLevel };
            return result;
        }

        [HookMethod("GetPrestigeLevel")]
        object GetPrestigeLevel(ulong id)
        {
            if (!pcdData.pEntity.TryGetValue(id, out var playerData)) return null;
            return playerData.prestige_level;
        }

        object ELOnModifyBoatSpeed(BasePlayer player, MotorRowboat boat)
        {
            if (Boats.ContainsKey(boat.net.ID.Value))
            {
                return true;
            }
            return null;
        }

        void EMOnEventJoined(BasePlayer player, string eventName)
        {
            if (string.IsNullOrEmpty(eventName)) return;
            switch (eventName.ToUpper())
            {
                case "SURVIVALARENA":
                    if (!config.thirdPartyPluginSettings.survivalArenaSettings.disable_skinning_ultimate_buff_on_join) return;
                    break;

                case "PAINTBALL":
                    if (!config.thirdPartyPluginSettings.paintballSettings.disable_skinning_ultimate_buff_on_join) return;
                    break;

                default: return;
            }
            RemoveAnimalBuff(player, true);
        }

        [HookMethod("GetLevelExp")]
        public double GetLevelExp(int level)
        {
            return config.level.GetLevelStartXP(level);
        }

        [HookMethod("GetPlayerLevel")]
        public int GetPlayerLevel(BasePlayer player)
        {
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData) && !GetOfflinePlayerinfo(player.UserIDString, out playerData)) return 0;
            return playerData.current_level;
        }

        [HookMethod("ForceDropPouch")]
        public void ForceDropPouch(BasePlayer player, bool bypassPerm)
        {
            if (!bypassPerm && (permission.UserHasPermission(player.UserIDString, "skilltree.bag.keepondeath") || Interface.CallHook("STOnPouchDrop", player) != null)) return;

            PlayerInfo pi;
            if (pcdData.pEntity.TryGetValue(player.userID, out pi) && pi.pouch_items != null && pi.pouch_items.Count > 0)
            {
                var bag = GenerateBag(player, 42);
                if (bag != null && bag.inventory?.itemList != null && bag.inventory.itemList.Count > 0)
                {
                    var pos = player.transform.position;
                    var rot = player.transform.rotation;
                    ServerMgr.Instance.Invoke(() =>
                    {
                        bag.inventory.Drop("assets/prefabs/misc/item drop/item_drop.prefab", pos, rot, 0);
                        pi.pouch_items.Clear();
                        containers.Remove(bag.inventory.uid.Value);
                        bag.KillMessage();
                    }, 0.1f);
                }
            }
        }

        Dictionary<YieldTypes, float> BaseYieldOverrides = new Dictionary<YieldTypes, float>();

        [HookMethod("SetSkillTreeYields")]
        public void SetSkillTreeYields(Dictionary<int, float> dict)
        {
            foreach (var kvp in dict)
            {
                if (!Enum.IsDefined(typeof(YieldTypes), kvp.Key))
                {
                    Puts($"Attempted to define a yield type that is out of range: {kvp.Key}.");
                    return;
                }
                AssignYield((YieldTypes)kvp.Key, kvp.Value);
            }
        }

        [HookMethod("SetSkillTreeYield")]
        public void SetSkillTreeYield(int type, float multiplier)
        {
            if (!Enum.IsDefined(typeof(YieldTypes), type))
            {
                Puts($"Attempted to define a yield type that is out of range: {type}.");
                return;
            }

            AssignYield((YieldTypes)type, multiplier);
        }

        void AssignYield(YieldTypes type, float modifier)
        {
            if (modifier == 1) BaseYieldOverrides.Remove(type);
            else BaseYieldOverrides[type] = modifier;
        }

        int GetMultipliedItemAmount(Item item)
        {
            return GetMultipliedItemAmount(item.info.shortname, item.amount);
        }

        int GetMultipliedItemAmount(string shortname, float amount)
        {
            if (!config.base_yield_settings.adjust_base_yield) return Mathf.RoundToInt(amount);
            YieldTypes yieldType;
            switch (shortname)
            {
                case "wood":
                    yieldType = YieldTypes.Wood;
                    break;

                case "stones":
                    yieldType = YieldTypes.Stone;
                    break;

                case "metal.ore":
                    yieldType = YieldTypes.Metal;
                    break;

                case "hq.metal.ore":
                    yieldType = YieldTypes.HQM;
                    break;

                case "sulfur.ore":
                    yieldType = YieldTypes.Sulfur;
                    break;

                case "corn":
                    yieldType = YieldTypes.Corn;
                    break;

                case "potato":
                    yieldType = YieldTypes.Potato;
                    break;

                case "wheat":
                    yieldType = YieldTypes.Wheat;
                    break;

                case "sunflower":
                    yieldType = YieldTypes.Sunflower;
                    break;

                case "orchid":
                    yieldType = YieldTypes.Orchid;
                    break;

                case "rose":
                    yieldType = YieldTypes.Orchid;
                    break;

                case "pumpkin":
                    yieldType = YieldTypes.Pumpkin;
                    break;

                case "cloth":
                    yieldType = YieldTypes.Cloth;
                    break;

                case "diesel_barrel":
                    yieldType = YieldTypes.Diesel;
                    break;

                case "fat.animal":
                    yieldType = YieldTypes.AnimalFat;
                    break;

                case "bone.fragments":
                    yieldType = YieldTypes.Bones;
                    break;

                case "leather":
                    yieldType = YieldTypes.Leather;
                    break;

                case "fish.anchovy":
                case "fish.catfish":
                case "fish.herring":
                case "fish.minnows":
                case "fish.orangeroughy":
                case "fish.salmon":
                case "fish.sardine":
                case "fish.smallshark":
                case "fish.troutsmall":
                case "fish.yellowperch":
                    yieldType = YieldTypes.Fish;
                    break;

                case "seed.black.berry":
                case "seed.blue.berry":
                case "seed.green.berry":
                case "seed.red.berry":
                case "seed.white.berry":
                case "seed.yellow.berry":
                case "seed.corn":
                case "seed.hemp":
                case "seed.potato":
                case "seed.pumpkin":
                case "seed.wheat":
                case "seed.sunflower":
                case "seed.orchid":
                case "seed.rose":
                    yieldType = YieldTypes.Seed;
                    break;

                case "mushroom":
                    yieldType = YieldTypes.Mushroom;
                    break;

                case "black.berry":
                case "blue.berry":
                case "green.berry":
                case "red.berry":
                case "white.berry":
                case "yellow.berry":
                    yieldType = YieldTypes.Berry;
                    break;

                case "chicken.raw":
                case "bearmeat":
                case "deermeat.raw":
                case "horsemeat.raw":
                case "humanmeat.raw":
                case "meat.boar":
                case "wolfmeat.raw":
                    yieldType = YieldTypes.Meat;
                    break;

                default: return Mathf.RoundToInt(amount);
            }

            float multiplier;
            if (!BaseYieldOverrides.TryGetValue(yieldType, out multiplier) || multiplier == 1) return Mathf.RoundToInt(amount);

            return Mathf.RoundToInt(amount * multiplier);
        }

        object QuickSortExcluded(BasePlayer player, BaseEntity entity)
        {
            if (entity != null && entity.net != null && containers.ContainsKey(entity.net.ID.Value)) return true;
            return null;
        }

        void OnMealConsumed(BasePlayer player, Item item, int buff_duration)
        {
            BuffDetails bd;
            if (GetBuffDetails(player.userID, out bd) && bd.GetBuff(Buff.Rationer, out var value) && RollSuccessful(value))
            {
                var refunded_item = ItemManager.CreateByName(item.info.shortname, 1, item.skin);
                if (item.name != null) refunded_item.name = item.name;
                GiveItem(player, refunded_item);
                if (config.notification_settings.chatMessageNotificationSettings.Rationed_Proc && NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("Rationed", this, player.UserIDString), item.name ?? item.info.displayName.english), config.misc_settings.ChatID);
            }
        }

        object RecipeCanModifyHorse(RidableHorse horse)
        {
            if (HorseStats.ContainsKey(horse.net.ID.Value)) return true;
            else return null;
        }

        object ELCanModifyHorse(RidableHorse horse, float value)
        {
            if (horse == null) return null;
            var driver = horse.GetDriver();
            if (driver == null) return null;
            BuffDetails bd;
            if (!GetBuffDetails(driver.userID, out bd))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {driver.displayName}[{driver.UserIDString}] - ELCanModifyHorse. [Online = {driver.IsConnected}]", this, true);
                return null;
            }
            if (!bd.GetBuff(Buff.Riding_Speed, out var currentValue)) return null;
            else if (currentValue > value) return true;
            RestoreHorseStats(horse);
            return null;
        }

        void OnBotReSpawnNPCKilled(ScientistNPC npc, string profile, string group, HitInfo info)
        {
            if (npc == null || string.IsNullOrEmpty(profile) || info == null || info.InitiatorPlayer == null || info.InitiatorPlayer.IsNpc || !info.InitiatorPlayer.userID.IsSteamId()) return;
            if (!config.misc_settings.botRespawnSettings.botrespawn_profiles.ContainsKey(profile))
            {
                config.misc_settings.botRespawnSettings.botrespawn_profiles.Add(profile, config.xp_settings.xp_sources.default_botrespawn);
                SaveConfig();
            }
            double xp;
            if (config.misc_settings.botRespawnSettings.botrespawn_profiles.TryGetValue(profile, out xp))
            {
                AwardXP(info.InitiatorPlayer, xp, npc ?? null, false, false, "BotRespawnNPC");
            }
        }

        void HGWinner(BasePlayer player)
        {
            AwardXP(player, config.xp_settings.xp_sources.Win_HungerGames, null, false, false, "Hunger Games Win");
        }

        void SAWinner(BasePlayer player)
        {
            AwardXP(player, config.xp_settings.xp_sources.Win_ScubaArena, null, false, false, "Scuba Arena Win");
        }

        void SKWinner(BasePlayer player)
        {
            AwardXP(player, config.xp_settings.xp_sources.Win_Skirmish, null, false, false, "Skirmish Win");
        }

        void SKWinners(List<BasePlayer> players)
        {
            if (players == null || players.Count == 0) return;
            foreach (var player in players)
            {
                AwardXP(player, config.xp_settings.xp_sources.Win_Skirmish, null, false, false, "Skirmish Win");
            }
        }

        void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
            if (npc.displayName.Equals(config.misc_settings.npc_name, StringComparison.OrdinalIgnoreCase))
            {
                SkillTreeBackPanel(player);
                NavigationMenu(player);
                SendBaseMenu(player);
            }
        }

        private object OnBetterChat(Dictionary<string, object> data)
        {
            var player = (IPlayer)data["Player"];
            if (permission.UserHasPermission(player.Id, "skilltree.notitles")) return null;

            if (!ulong.TryParse(player.Id, out var id)) return null;
            if (!pcdData.pEntity.TryGetValue(id, out var playerData)) return null;
            if (!playerData.better_chat_enabled) return null;

            string title = "";

            title += GetPrestigeBetterChatTitle(id, playerData);

            if (!string.IsNullOrEmpty(config.betterchat_settings.better_title_format))
            {
                var col = config.betterchat_settings.better_title_default_col;
                if (config.general_settings.max_player_level > 0 && playerData.current_level >= config.general_settings.max_player_level) col = config.betterchat_settings.better_title_max_col;

                if (!string.IsNullOrEmpty(title)) title += " ";
                title += string.Format(config.betterchat_settings.better_title_format, col, config.general_settings.max_player_level > 0 && playerData.current_level > config.general_settings.max_player_level ? config.general_settings.max_player_level : playerData.current_level);
            }

            if (string.IsNullOrEmpty(title)) return null;

            var titles = (List<string>)data["Titles"];
            titles.Add(title);
            data["Titles"] = titles;
            return data;
        }

        public class IngredientItemInfo
        {
            public int amount;
            public float spoilTime;
        }

        void OnMealCrafted(BasePlayer player, string name, Dictionary<string, int> ingredients_list, bool isIngredient)
        {
            if ((!config.xp_settings.cooking_award_xp_ingredients && isIngredient) || config.xp_settings.cooking_black_list.Contains(name)) return;
            var ingredient_count = 0;
            foreach (var ingredient in ingredients_list)
            {
                ingredient_count += ingredient.Value;
            }
            AwardXP(player, ingredient_count * config.xp_settings.xp_sources.CookingMealXP, null, false, false, "Cooking Meal Crafted");
        }

        [HookMethod("ST_GetPlayerLevel")]
        public string[] ST_GetPlayerLevel(BasePlayer player)
        {
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData) || !GetOfflinePlayerinfo(player.UserIDString, out playerData)) return new string[] { "0", "0" };
            var level = playerData.current_level;
            if (config.general_settings.max_player_level > 0 && playerData.current_level > config.general_settings.max_player_level) level = config.general_settings.max_player_level;
            return new string[] { level.ToString(), playerData.xp.ToString() };

        }

        private void OnHarborEventWinner(ulong winnerId) => AwardEventWinnerXP(winnerId, config.xp_settings.xp_sources.Harbor_Event_Winner);
        private void OnJunkyardEventWinner(ulong winnerId) => AwardEventWinnerXP(winnerId, config.xp_settings.xp_sources.Junkyard_Event_Winner);
        private void OnSatDishEventWinner(ulong winnerId) => AwardEventWinnerXP(winnerId, config.xp_settings.xp_sources.Satellite_Event_Winner);
        private void OnWaterEventWinner(ulong winnerId) => AwardEventWinnerXP(winnerId, config.xp_settings.xp_sources.Water_Event_Winner);
        private void OnAirEventWinner(ulong winnerId) => AwardEventWinnerXP(winnerId, config.xp_settings.xp_sources.Air_Event_Winner);

        private void OnArcticBaseEventWinner(ulong winnerId) => AwardEventWinnerXP(winnerId, config.xp_settings.xp_sources.ArcticBaseEvent_Winner);
        private void OnGasStationEventWinner(ulong winnerId) => AwardEventWinnerXP(winnerId, config.xp_settings.xp_sources.GasStationEvent_Winner);
        private void OnSputnikEventWin(ulong winnerId) => AwardEventWinnerXP(winnerId, config.xp_settings.xp_sources.SputnikEvent_Winner);
        private void OnShipwreckEventWin(ulong winnerId) => AwardEventWinnerXP(winnerId, config.xp_settings.xp_sources.ShipWreckEvent_Winner);

        private void OnTriangulationWinner(ulong winnerId) => AwardEventWinnerXP(winnerId, config.xp_settings.xp_sources.Triangulation_Winner);
        private void OnSupermarketEventWinner(ulong winnerId) => AwardEventWinnerXP(winnerId, config.xp_settings.xp_sources.SupermarketEvent_Winner);
        private void OnCaravanEventWin(ulong winnerId) => AwardEventWinnerXP(winnerId, config.xp_settings.xp_sources.Caravan_Winner);

        private void OnPowerPlantEventWinner(ulong winnerId) => AwardEventWinnerXP(winnerId, config.xp_settings.xp_sources.PowerPlant_Event_Winner);
        private void OnArmoredTrainEventWin(ulong winnerID) => AwardEventWinnerXP(winnerID, config.xp_settings.xp_sources.Armored_Train_Winner);
        private void OnConvoyEventWin(ulong userId) => AwardEventWinnerXP(userId, config.xp_settings.xp_sources.Convoy_Winner);
        private void OnSurvivalArenaWin(BasePlayer player) => AwardEventWinnerXP(player.userID, config.xp_settings.xp_sources.SurvivalArena_Winner);
        private void OnBossKilled(ScientistNPC boss, BasePlayer attacker) => AwardXP(attacker, config.xp_settings.xp_sources.boss_monster, boss);

        void AwardEventWinnerXP(ulong winnerID, double xp)
        {
            var player = BasePlayer.activePlayerList.FirstOrDefault(x => x.userID == winnerID);
            if (player != null) AwardXP(player, xp, null, false, false, "Event");
        }

        private void OnRaidableBaseCompleted(Vector3 Location, int mode, bool allowPVP, string id, float spawnTime, float despawnTime, float loadTime, ulong ownerid, BasePlayer owner, List<BasePlayer> raiders)
        {
            double xp;
            switch (mode)
            {
                case 0:
                    xp = config.xp_settings.xp_sources.RaidableBaseCompletion_Easy;
                    break;

                case 1:
                    xp = config.xp_settings.xp_sources.RaidableBaseCompletion_Medium;
                    break;

                case 2:
                    xp = config.xp_settings.xp_sources.RaidableBaseCompletion_Hard;
                    break;

                case 3:
                    xp = config.xp_settings.xp_sources.RaidableBaseCompletion_Expert;
                    break;

                case 4:
                    xp = config.xp_settings.xp_sources.RaidableBaseCompletion_Nightmare;
                    break;

                default:
                    xp = 0;
                    break;
            }
            if (raiders != null)
            {
                foreach (var player in raiders)
                {
                    AwardXP(player, xp, "RaidableBases");
                }
            }
        }

        [HookMethod("GetExcessXP")]
        private double GetExcessXP(BasePlayer player)
        {
            PlayerInfo pi;
            if (!pcdData.pEntity.TryGetValue(player.userID, out pi))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - GetExcessXP. [Online = {player.IsConnected}]", this, true);
                return 0;
            }
            return pi.xp - config.level.GetLevelStartXP(pi.current_level);
        }

        [HookMethod("RemoveXP")]
        private void RemoveXP(BasePlayer player, double value)
        {
            PlayerInfo pi;
            if (!pcdData.pEntity.TryGetValue(player.userID, out pi))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - RemoveXP. [Online = {player.IsConnected}]", this, true);
                return;
            }

            var level_start_xp = config.level.GetLevelStartXP(pi.current_level);
            if ((pi.xp - value) - level_start_xp < 0.1) pi.xp = level_start_xp + 0.1;
            else pi.xp -= value;

            CheckLevel(player);
            UpdateXP(player, pi);
        }

        [HookMethod("STGetHorseStats")]
        private object STGetHorseStats(BasePlayer player, ulong id)
        {
            HorseInfo stats;
            if (HorseStats.TryGetValue(id, out stats)) return stats.mod;
            else return null;
        }

        // Do a check when the player mounts the horse, see if the buff is higher than the horses modified value, and if so, modify it with the new value. When getting off the horse, if Cooking or SkillTree still have the horse stored, restore horse stats to their value and let them .

        void OpenExtraPocketsPouch(BasePlayer player)
        {
            OpenBag(player);
        }



        #endregion

        #region XP HUD       

        string GetPumpBarString(BasePlayer player, double levelStartXP, double xp, double cap, bool isDebt = false)
        {
            string xpString;
            switch (config.general_settings.pump_bar_settings.pump_bar_formatting)
            {
                case 2:
                    xpString = string.Format(lang.GetMessage(isDebt ? "PumpBarXPTextDebt" : "PumpBarXPText", this, player.UserIDString), $"{Math.Round(xp - levelStartXP, config.xp_settings.xp_rounding):###,###,##0}", $"{Math.Round(cap - levelStartXP, config.xp_settings.xp_rounding):###,###,##0}");
                    break;

                case 3:
                    xpString = $"{Math.Round((cap - levelStartXP) - (xp - levelStartXP), config.xp_settings.xp_rounding):###,###,##0} ({Math.Round(((xp - levelStartXP) / (cap - levelStartXP)) * 100, config.xp_settings.xp_rounding)}%)";
                    break;

                default:
                    xpString = string.Format(lang.GetMessage(isDebt ? "PumpBarXPTextDebt" : "PumpBarXPText", this, player.UserIDString), $"{Math.Round(xp, config.xp_settings.xp_rounding):###,###,##0}", $"{Math.Round(cap, config.xp_settings.xp_rounding):###,###,##0}");
                    break;
            }
            return xpString;
        }

        void UpdateXP(BasePlayer player, PlayerInfo playerData = null, bool moving = false)
        {
            if (!permission.UserHasPermission(player.UserIDString, "skilltree.xp") || !config.general_settings.pump_bar_settings.enabled) return;
            if (playerData == null)
            {
                if (!pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;
            }

            double pump_length = config.general_settings.pump_bar_settings.offset_default.max_x - config.general_settings.pump_bar_settings.offset_default.min_x;

            var cap = config.level.GetLevelStartXP(playerData.current_level + 1);
            //var xpString = string.Format(lang.GetMessage("PumpBarXPText", this, player.UserIDString), Math.Round(playerData.xp, config.xp_settings.xp_rounding), Math.Round(cap, config.xp_settings.xp_rounding));
            var container = new CuiElementContainer();
            var LevelStartXP = config.level.GetLevelStartXP(playerData.current_level);
            var pump_value = playerData.xp_debt <= 0 ? (((playerData.xp - LevelStartXP) / (cap - LevelStartXP)) * pump_length) - 2.001 : pump_length;
            var xpString = playerData.xp_debt <= 0 ? GetPumpBarString(player, LevelStartXP, playerData.xp, cap) : GetPumpBarString(player, 0, playerData.xp_debt, playerData.xp_debt, true);
            if (pump_value > pump_length) pump_value = pump_length;

            CuiElement main = new CuiElement
            {
                Name = "SkillTreeXPBar",
                Parent = moving ? "Overlay" : "Hud",
                DestroyUi = "SkillTreeXPBar",
                Components =
                {
                    new CuiImageComponent{ Color = "0.4245283 0.4245283 0.4245283 0.5019608" },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = config.general_settings.pump_bar_settings.anchor_default.anchor_min,
                        AnchorMax = config.general_settings.pump_bar_settings.anchor_default.anchor_max,
                        OffsetMin = $"{config.general_settings.pump_bar_settings.offset_default.min_x + playerData.xp_bar_offset.x} {config.general_settings.pump_bar_settings.offset_default.min_y + playerData.xp_bar_offset.y}",
                        OffsetMax = $"{config.general_settings.pump_bar_settings.offset_default.max_x + playerData.xp_bar_offset.x} {config.general_settings.pump_bar_settings.offset_default.max_y + playerData.xp_bar_offset.y}"
                    }
                }
            };
            if (moving)
            {
                main.Components.Add(new CuiDraggableComponent
                {
                    LimitToParent = false,
                    MaxDistance = -1f,
                    AllowSwapping = false,
                    DropAnywhere = true,
                    DragAlpha = 1f,
                    ParentLimitIndex = 1,
                    ParentPadding = "0 0",
                    KeepOnTop = false,
                    PositionRPC = CommunityEntity.DraggablePositionSendType.Relative,
                    MoveToAnchor = true,
                    RebuildAnchor = true
                });
                if (config.xp_settings.force_cursor_on_move)
                    main.Components.Add(new CuiNeedsCursorComponent());
            }
            container.Add(main);

            //130.001 - default value
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = playerData.xp_debt > 0 ? config.general_settings.pump_bar_settings.pump_bar_colour_debt : config.general_settings.pump_bar_settings.pump_bar_colour },
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "2.001 -9", OffsetMax = $"{pump_value} 9" }
            }, "SkillTreeXPBar", "SkillTreeXPBarPump");

            container.Add(new CuiElement
            {
                Name = "SkillTreeXPBarCounter",
                Parent = "SkillTreeXPBar",
                Components = {
                    new CuiTextComponent { Text = xpString, Font = config.general_settings.pump_bar_settings.pump_bar_font, FontSize = config.general_settings.pump_bar_settings.pump_bar_font_size, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.7843137" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-32.125 -11", OffsetMax = "61.858 11" }
                }
            });

            if (playerData.xp_debt > 0)
            {
                container.Add(new CuiElement
                {
                    Name = "SkillTreeXPBarTitle",
                    Parent = "SkillTreeXPBar",
                    Components = {
                    new CuiTextComponent { Text = lang.GetMessage("PumpBarDebtTitleText", this, player.UserIDString), Font = config.general_settings.pump_bar_settings.pump_bar_font, FontSize = config.general_settings.pump_bar_settings.pump_bar_font_size + 2, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.7843137" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    //new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.213 -11", OffsetMax = "-32.125 11" }
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0 -11", OffsetMax = "34 11" }
                }
                });
            }
            else
            {
                var level = config.general_settings.max_player_level > 0 && playerData.current_level > config.general_settings.max_player_level ? config.general_settings.max_player_level : playerData.current_level;
                container.Add(new CuiElement
                {
                    Name = "SkillTreeXPBarTitle",
                    Parent = "SkillTreeXPBar",
                    Components = {
                    new CuiTextComponent { Text = string.Format(lang.GetMessage("PumpBarLevelText", this, player.UserIDString), level), Font = config.general_settings.pump_bar_settings.pump_bar_font, FontSize = config.general_settings.pump_bar_settings.pump_bar_font_size + 2, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.7843137" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0 -11", OffsetMax = "34 11" }
                }
                });
            }

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = "openskilltreemenufrompumpbar" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.209 -11", OffsetMax = "66.211 11" }
            }, "SkillTreeXPBar", "button");

            if (moving)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = "ststopmovingxpbar" },
                    Text = { Text = "X", Font = "robotocondensed-bold.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "0 0 0 1" },
                    RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-0.002 0", OffsetMax = "15.998 16" }
                }, "SkillTreeXPBar", "EndMoveBar");
            }

            if (playerData.prestige_level > 0 && config.general_settings.pump_bar_settings.displayPrestigeImg && config.prestige_settings.levels.TryGetValue(playerData.prestige_level, out var prestigeData))
            {
                container.Add(new CuiElement
                {
                    Name = "PrestigeImg",
                    Parent = "SkillTreeXPBar",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 1", ItemId = 1776460938, SkinId = prestigeData.RankUpPic },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "-21.997 -11", OffsetMax = "0.003 11" }
                }
                });
            }

            CuiHelper.DestroyUi(player, "SkillTreeXPBar");
            CuiHelper.AddUi(player, container);
        }

        private void OnCuiDraggableDrag(BasePlayer player, string name, Vector3 position, CommunityEntity.DraggablePositionSendType type)
        {
            if (name != "SkillTreeXPBar") return;
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData)) return;
            playerData.xp_bar_offset += (Vector2)position;
        }


        [ConsoleCommand("ststopmovingxpbar")]
        void StopMovingXPBar(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            UpdateXP(player);
        }

        [ConsoleCommand("openskilltreemenufrompumpbar")]
        void OpenSkillTreeMenuFromPumpBar(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            SendMenuCMD(player);
        }


        #endregion

        #region Furnace speed

        Dictionary<BaseOven, float> ovens = new Dictionary<BaseOven, float>();

        void OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            float modifier;
            if (!ovens.TryGetValue(oven, out modifier) || !RollSuccessful(modifier)) return;
            List<Item> remove_items = new List<Item>();
            foreach (var item in oven.inventory.itemList.ToList())
            {
                var itemModCookable = item.info.GetComponent<ItemModCookable>();
                if (itemModCookable?.becomeOnCooked == null || item.temperature < itemModCookable.lowTemp || item.temperature > itemModCookable.highTemp || itemModCookable.cookTime < 0) continue;
                var itemToGive = ItemManager.Create(itemModCookable.becomeOnCooked, itemModCookable.amountOfBecome);
                if (!itemToGive.MoveToContainer(oven.inventory))
                    itemToGive.Drop(oven.inventory.dropPosition, oven.inventory.dropVelocity);
                if (item.amount == 1) item.Remove();
                else item.SplitItem(1).Remove();
            }
            foreach (var item in remove_items.ToList())
            {
                item.Remove();
            }
        }

        void OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            if (oven.temperature != BaseOven.TemperatureType.Smelting) return;
            // Checks if the oven is on when the toggle occurs, and if it is, we exit because its being turned off.
            if (oven.IsOn())
            {
                if (ovens.ContainsKey(oven)) ovens.Remove(oven);
                return;
            }
            // See if the player has the buff assigned.
            BuffDetails bd;
            if (GetBuffDetails(player.userID, out bd) && bd.GetBuff(Buff.Smelt_Speed, out var value))
            {
                if (oven.inventory.itemList == null || oven.inventory.itemList.Count == 0) return;
                ovens.Remove(oven);
                ovens.Add(oven, value);
            }
        }

        #endregion

        #region Subscriptions

        public Dictionary<string, Subscription> subscriptions = new Dictionary<string, Subscription>()
        {
            [nameof(OnEntityTakeDamage)] = new Subscription(false, new List<Buff>() { Buff.Animal_Damage_Resist, Buff.Barrel_Smasher, Buff.Fall_Damage_Reduction, Buff.Fire_Damage_Reduction, Buff.Melee_Resist, Buff.No_Cold_Damage, Buff.PVP_Critical, Buff.PVP_Damage, Buff.PVP_Shield, Buff.Radiation_Reduction, Buff.Loot_Pickup, Buff.Human_NPC_Damage, Buff.Human_NPC_Defence, Buff.Animal_NPC_Damage, Buff.Vehicle_Ultimate, Buff.Scavengers_Ultimate, Buff.Combat_Ultimate, Buff.SharkResistance, Buff.UnderwaterDamageBonus, Buff.Skinning_Ultimate, Buff.Trap_Damage_Reduction, Buff.Trap_Damage_Increase, Buff.Personal_Explosive_Reduction, Buff.Extra_Scrap_Barrel, Buff.Component_Barrel, Buff.Electronic_Barrel, Buff.DriverCollisionResistance, Buff.Heli_Damage_Bonus, Buff.Bradley_Damage_Bonus }),
            //[nameof(OnItemUse)] = new Subscription(false, new List<Buff>() { Buff.Rationer }),
            [nameof(OnPlayerRevive)] = new Subscription(false, new List<Buff>() { Buff.Reviver }),
            [nameof(OnPlayerHealthChange)] = new Subscription(false, new List<Buff>() { Buff.Double_Bandage_Heal, Buff.Skinning_Ultimate, Buff.Heal_Share }),
            [nameof(OnLoseCondition)] = new Subscription(false, new List<Buff>() { Buff.Woodcutting_Tool_Durability, Buff.Mining_Tool_Durability, Buff.Skinning_Tool_Durability, Buff.Primitive_Expert, Buff.Durability }),
            [nameof(OnWeaponFired)] = new Subscription(false, new List<Buff>() { Buff.Free_Bullet_Chance }),
            [nameof(OnRecyclerToggle)] = new Subscription(false, new List<Buff>() { Buff.Recycler_Speed, Buff.Recycler_Efficiency }),
            [nameof(OnPlayerAddModifiers)] = new Subscription(false, new List<Buff>() { Buff.Rationer, Buff.Extra_Food_Water, Buff.Iron_Stomach, Buff.Extended_Tea_Duration, Buff.Tea_Share, Buff.Metabolism_Share }),
            [nameof(OnPlayerWound)] = new Subscription(false, new List<Buff>() { Buff.Wounded_Resist }),
            [nameof(OnEntityMounted)] = new Subscription(false, new List<Buff>() { Buff.Riding_Speed, Buff.Heli_Fuel_Rate, Buff.Boat_Fuel_Rate, Buff.Heli_Speed, Buff.BikeEnginePower }),
            [nameof(OnEntityDismounted)] = new Subscription(false, new List<Buff>() { Buff.Boat_Fuel_Rate, Buff.Heli_Fuel_Rate, Buff.Riding_Speed, Buff.Boat_Speed, Buff.Heli_Speed, Buff.Boat_Speed, Buff.BikeEnginePower }),
            [nameof(OnHammerHit)] = new Subscription(false, new List<Buff>() { Buff.Vehicle_Mechanic }),
            [nameof(OnPayForUpgrade)] = new Subscription(false, new List<Buff>() { Buff.Upgrade_Refund }),
            [nameof(OnPlayerInput)] = new Subscription(false, new List<Buff>() { Buff.Boat_Speed }),
            [nameof(OnResearchCostDetermine)] = new Subscription(false, new List<Buff>() { Buff.Research_Refund }),
            [nameof(CanLootEntity)] = new Subscription(false, new List<Buff>() { Buff.Component_Chest, Buff.Electronic_Chest, Buff.Extra_Scrap_Crate, Buff.DeepSeaLooter, Buff.Tea_Looter }),
            [nameof(OnPlayerRespawned)] = new Subscription(false, new List<Buff>() { Buff.Medical_Ultimate, Buff.Spawn_Health }),
            [nameof(OnItemRepair)] = new Subscription(false, new List<Buff>() { Buff.MaxRepair, Buff.Free_Repairs }),
            [nameof(CanUseLockedEntity)] = new Subscription(false, new List<Buff>() { Buff.Lock_Picker }),
            [nameof(OnTreeMarkerHit)] = new Subscription(false, new List<Buff>() { Buff.Woodcutting_Hotspot }),
            [nameof(OnMeleeAttack)] = new Subscription(false, new List<Buff>() { Buff.Mining_Hotspot }),
            [nameof(OnWeaponReload)] = new Subscription(false, new List<Buff>() { Buff.Extended_Mag }),
            [nameof(OnWeaponModChange)] = new Subscription(false, new List<Buff>() { Buff.Extended_Mag }),
            [nameof(OnFishCatch)] = new Subscription(false, new List<Buff>() { Buff.Rod_Tension_Bonus, Buff.Fishing_Luck }),
            [nameof(OnFishingStopped)] = new Subscription(false, new List<Buff>() { Buff.Rod_Tension_Bonus }),
            [nameof(OnTimedExplosiveExplode)] = new Subscription(false, new List<Buff>() { Buff.Double_Explosion_Chance }),
            [nameof(OnMixingTableToggle)] = new Subscription(false, new List<Buff>() { Buff.Cooking_Speed }),
            [nameof(OnRocketLaunched)] = new Subscription(false, new List<Buff>() { Buff.Rocket_Velocity, Buff.Explosion_Radius }),
            [nameof(OnExplosiveThrown)] = new Subscription(false, new List<Buff>() { Buff.Explosion_Radius }),
            [nameof(OnExplosiveDropped)] = new Subscription(false, new List<Buff>() { Buff.Explosion_Radius }),
            [nameof(OnExplosiveDud)] = new Subscription(false, new List<Buff>() { Buff.Dudless_Explosive }),
        };


        public class Subscription
        {
            public bool isSubscribed;
            public List<Buff> buffs;
            public List<ulong> subscribers = new List<ulong>();
            public Subscription(bool isSubscribed, List<Buff> buffs)
            {
                this.isSubscribed = isSubscribed;
                this.buffs = buffs;
            }
            public void Subscribed()
            {
                this.isSubscribed = true;
                if (this.subscribers == null) this.subscribers = new List<ulong>();
            }
            public void Unsubscribed()
            {
                this.isSubscribed = false;
                this.subscribers.Clear();
            }
            public bool Required()
            {
                if (this.subscribers != null && this.subscribers.Count > 0) return true;
                return false;
            }
            public void AddPlayer(ulong id)
            {
                if (this.subscribers == null) this.subscribers = new List<ulong>();
                if (!this.subscribers.Contains(id)) this.subscribers.Add(id);
            }
            public void RemovePlayer(ulong id)
            {
                if (this.subscribers != null)
                {
                    this.subscribers.Remove(id);
                }
            }
        }

        void RemoveFromAllBuffs(ulong id)
        {
            foreach (var sub in subscriptions)
            {
                if (sub.Key == nameof(OnPlayerInput) && !config.chat_commands.use_input_key_boat) continue;
                sub.Value.subscribers.Remove(id);
                if (sub.Value.isSubscribed && !sub.Value.Required())
                {
                    OnUnsubscribe(sub.Key);
                    sub.Value.Unsubscribed();
                    Unsubscribe(sub.Key);
                }
            }

            HandleShieldSubscriptions(id, false);
        }

        void OnUnsubscribe(string hook)
        {
            switch (hook)
            {
                case nameof(OnWeaponReload):
                    ResetWeaponCapacities(false, config.buff_settings.force_unload_extended_mag_weapons_unload);
                    ModifiedWeapons.Clear();
                    break;
            }
        }

        void AddBuffs(ulong id, Buff buff)
        {
            foreach (var sub in subscriptions)
            {
                if (sub.Key == nameof(OnPlayerInput) && !config.chat_commands.use_input_key_boat) continue;
                if (!sub.Value.buffs.Contains(buff)) continue;
                sub.Value.AddPlayer(id);
                if (!sub.Value.isSubscribed)
                {
                    sub.Value.Subscribed();
                    Subscribe(sub.Key);
                }
            }

            switch (buff)
            {
                case Buff.Shield_Reflect:
                    HandleShieldSubscriptions(id, true);
                    break;
            }
        }

        List<ulong> ShieldIDs = new List<ulong>();
        void HandleShieldSubscriptions(ulong id, bool add)
        {
            if (add)
            {
                if (!ShieldIDs.Contains(id))
                {
                    ShieldIDs.Add(id);
                    ShieldPatchActive = true;
                }
            }
            else
            {
                ShieldIDs.Remove(id);
                if (ShieldIDs.Count == 0)
                {
                    ShieldPatchActive = false;
                }

            }
        }

        void RemoveBuff(ulong id, Buff buff)
        {
            foreach (var sub in subscriptions)
            {
                if (sub.Key == nameof(OnPlayerInput) && !config.chat_commands.use_input_key_boat) continue;
                if (!sub.Value.buffs.Contains(buff)) continue;
                sub.Value.RemovePlayer(id);
                if (sub.Value.isSubscribed && !sub.Value.Required())
                {
                    OnUnsubscribe(sub.Key);
                    sub.Value.Unsubscribed();
                    Unsubscribe(sub.Key);
                }
            }

            switch (buff)
            {
                case Buff.Shield_Reflect:
                    HandleShieldSubscriptions(id, false);
                    break;
            }
        }

        void LoadBuffs()
        {
            if (config.buff_settings.boat_turbo_on_mount && !subscriptions[nameof(OnEntityMounted)].buffs.Contains(Buff.Boat_Speed)) subscriptions[nameof(OnEntityMounted)].buffs.Add(Buff.Boat_Speed);
            if (BasePlayer.activePlayerList == null || BasePlayer.activePlayerList.Count == 0 || buffDetails == null || buffDetails.Count == 0)
            {
                foreach (var sub in subscriptions)
                {
                    if (sub.Key == nameof(OnPlayerInput) && !config.chat_commands.use_input_key_boat) continue;
                    Unsubscribe(sub.Key);
                    sub.Value.Unsubscribed();
                }
            }
            else
            {
                foreach (var sub in subscriptions)
                {
                    if (sub.Key == nameof(OnPlayerInput) && !config.chat_commands.use_input_key_boat)
                    {
                        Unsubscribe(nameof(OnPlayerInput));
                        continue;
                    }
                    foreach (var player in buffDetails)
                    {
                        var buffs = player.Value.GetAllBuffs();
                        if (buffs != null || buffs.Count > 0) continue;
                        foreach (var buff in buffs)
                        {
                            if (sub.Value.buffs.Contains(buff.Key))
                            {
                                sub.Value.AddPlayer(player.Key);
                                sub.Value.Subscribed();
                            }
                        }
                    }
                    if (!sub.Value.Required())
                    {
                        sub.Value.Unsubscribed();
                        Unsubscribe(sub.Key);
                    }
                }
            }
        }

        #endregion

        #region Player Menu

        private void SkillTree_PlayerMenu(BasePlayer player)
        {
            PlayerInfo pi;
            if (!pcdData.pEntity.TryGetValue(player.userID, out pi)) return;

            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0 0 0 0.9803922" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0.025 -0.331", OffsetMax = "0.325 0.339" }
            }, "Overlay", "SkillTree_PlayerMenu");

            container.Add(new CuiElement
            {
                Name = "SkillTree_PlayerMenu_Title",
                Parent = "SkillTree_PlayerMenu",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIPlayerSettings", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 26, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-495.24 190.4", OffsetMax = "-180.18 250.4" }
                }
            });

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1132075 0.1073335 0.1073335 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-495.24 132.4", OffsetMax = "-180.18 190.4" }
            }, "SkillTree_PlayerMenu", "SkillTree_PlayerMenu_tgl_pnl_bk_1");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.2264151 0.2264151 0.2264151 0.9607843" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-155.53 -27", OffsetMax = "155.53 27" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_1", "SkillTree_PlayerMenu_tgl_pnl_ft_1");

            container.Add(new CuiElement
            {
                Name = "SkillTree_PlayerMenu_tgl_des_1",
                Parent = "SkillTree_PlayerMenu_tgl_pnl_bk_1",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIToggleXP", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-147 -26", OffsetMax = "52.24 26" }
                }
            });

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1132075 0.1073335 0.1073335 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "66.53 -24", OffsetMax = "152.53 24" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_1", "SkillTree_PlayerMenu_tgl_bttn_pnl_1");

            var textCol = "0.0480598 0.6792453 0.1672014 1";
            if (!pi.xp_drops) textCol = "0.5943396 0.131764 0.1842591 1";

            container.Add(new CuiButton
            {
                Button = { Color = "0.1607843 0.1607843 0.1607843 1", Command = $"dotogglexpdrops" },
                Text = { Text = pi.xp_drops ? lang.GetMessage("ON", this, player.UserIDString) : lang.GetMessage("OFF", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = textCol },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "68.53 -22", OffsetMax = "150.53 22" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_1", "SkillTree_PlayerMenu_tgl_bttn_1");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1132075 0.1073335 0.1073335 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-495.24 54.4", OffsetMax = "-180.18 112.4" }
            }, "SkillTree_PlayerMenu", "SkillTree_PlayerMenu_tgl_pnl_bk_2");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.2264151 0.2264151 0.2264151 0.9607843" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-155.53 -27", OffsetMax = "155.53 27" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_2", "SkillTree_PlayerMenu_tgl_pnl_ft_2");

            container.Add(new CuiElement
            {
                Name = "SkillTree_PlayerMenu_tgl_des_2",
                Parent = "SkillTree_PlayerMenu_tgl_pnl_bk_2",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIToggleXPBar", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-147 -26", OffsetMax = "52.24 26" }
                }
            });

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1132075 0.1073335 0.1073335 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "66.53 -24", OffsetMax = "152.53 24" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_2", "SkillTree_PlayerMenu_tgl_bttn_pnl_2");

            textCol = "0.0480598 0.6792453 0.1672014 1";
            if (!pi.xp_hud) textCol = "0.5943396 0.131764 0.1842591 1";

            container.Add(new CuiButton
            {
                Button = { Color = "0.1607843 0.1607843 0.1607843 1", Command = "dotogglexphud" },
                Text = { Text = pi.xp_hud ? lang.GetMessage("ON", this, player.UserIDString) : lang.GetMessage("OFF", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = textCol },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "68.53 -22", OffsetMax = "150.53 22" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_2", "SkillTree_PlayerMenu_tgl_bttn_2");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1132075 0.1073335 0.1073335 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-495.24 -23.6", OffsetMax = "-180.18 34.4" }
            }, "SkillTree_PlayerMenu", "SkillTree_PlayerMenu_tgl_pnl_bk_3");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.2264151 0.2264151 0.2264151 0.9607843" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-155.53 -27", OffsetMax = "155.53 27" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_3", "SkillTree_PlayerMenu_tgl_pnl_ft_3");

            container.Add(new CuiElement
            {
                Name = "SkillTree_PlayerMenu_tgl_des_3",
                Parent = "SkillTree_PlayerMenu_tgl_pnl_bk_3",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("RepositionBar", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-147 -26", OffsetMax = "52.24 26" }
                }
            });

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1132075 0.1073335 0.1073335 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "66.53 -24", OffsetMax = "152.53 24" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_3", "SkillTree_PlayerMenu_tgl_bttn_pnl_3");

            container.Add(new CuiButton
            {
                Button = { Color = "0.1607843 0.1607843 0.1607843 1", Command = "strepositionhudfrommenu" },
                Text = { Text = lang.GetMessage("UIChange", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "1 0.7984455 0.3066038 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "68.53 -22", OffsetMax = "150.53 22" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_3", "SkillTree_PlayerMenu_tgl_bttn_3");

            textCol = "0.0480598 0.6792453 0.1672014 1";
            if (!pi.extra_pockets_button) textCol = "0.5943396 0.131764 0.1842591 1";

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1132075 0.1073335 0.1073335 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-495.24 -101.6", OffsetMax = "-180.18 -43.6" }
            }, "SkillTree_PlayerMenu", "SkillTree_PlayerMenu_tgl_pnl_bk_4");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.2264151 0.2264151 0.2264151 0.9607843" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-155.53 -27", OffsetMax = "155.53 27" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_4", "SkillTree_PlayerMenu_tgl_pnl_ft_4");

            container.Add(new CuiElement
            {
                Name = "SkillTree_PlayerMenu_tgl_des_4",
                Parent = "SkillTree_PlayerMenu_tgl_pnl_bk_4",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("ToggleBagButton", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-147 -26", OffsetMax = "52.24 26" }
                }
            });

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1132075 0.1073335 0.1073335 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "66.53 -24", OffsetMax = "152.53 24" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_4", "SkillTree_PlayerMenu_tgl_bttn_pnl_4");

            container.Add(new CuiButton
            {
                Button = { Color = "0.1607843 0.1607843 0.1607843 1", Command = "sttoggleextrapocketsbutton" },
                Text = { Text = pi.extra_pockets_button ? lang.GetMessage("ON", this, player.UserIDString) : lang.GetMessage("OFF", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = textCol },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "68.53 -22", OffsetMax = "150.53 22" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_4", "SkillTree_PlayerMenu_tgl_bttn_4");

            textCol = "0.0480598 0.6792453 0.1672014 1";
            if (!pi.notifications) textCol = "0.5943396 0.131764 0.1842591 1";

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1132075 0.1073335 0.1073335 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-495.24 -179.6", OffsetMax = "-180.18 -121.6" }
            }, "SkillTree_PlayerMenu", "SkillTree_PlayerMenu_tgl_pnl_bk_5");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.2264151 0.2264151 0.2264151 0.9607843" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-155.53 -27", OffsetMax = "155.53 27" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_5", "SkillTree_PlayerMenu_tgl_pnl_ft_5");

            container.Add(new CuiElement
            {
                Name = "SkillTree_PlayerMenu_tgl_des_5",
                Parent = "SkillTree_PlayerMenu_tgl_pnl_bk_5",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("ToggleNotifications", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-147 -26", OffsetMax = "52.24 26" }
                }
            });

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1132075 0.1073335 0.1073335 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "66.53 -24", OffsetMax = "152.53 24" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_5", "SkillTree_PlayerMenu_tgl_bttn_pnl_5");

            container.Add(new CuiButton
            {
                Button = { Color = "0.1607843 0.1607843 0.1607843 1", Command = "sttogglenotifications" },
                Text = { Text = pi.notifications ? lang.GetMessage("ON", this, player.UserIDString) : lang.GetMessage("OFF", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = textCol },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "68.53 -22", OffsetMax = "150.53 22" }
            }, "SkillTree_PlayerMenu_tgl_pnl_bk_5", "SkillTree_PlayerMenu_tgl_bttn_5");


            container.Add(new CuiElement
            {
                Name = "SkillTree_PlayerMenu_close",
                Parent = "SkillTree_PlayerMenu",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIClose", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-366.71 -243", OffsetMax = "-308.71 -211" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = $"stcloseplayersettings" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-29 -16", OffsetMax = "29 16" }
            }, "SkillTree_PlayerMenu_close", "SkillTree_PlayerMenu_close_button");

            CuiHelper.DestroyUi(player, "SkillTree_PlayerMenu");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("strepositionhudfrommenu")]
        void MoveBarButton(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, "SkillTree_PlayerMenu");
            CuiHelper.DestroyUi(player, "SkillTree");
            CuiHelper.DestroyUi(player, "SkillTreeBackPanel");
            CuiHelper.DestroyUi(player, "NavigationMenu");
            UpdateXP(player, null, true);
            player.ShowToast(GameTip.Styles.Blue_Normal, lang.GetMessage("MoveBarInstructions", this, player.UserIDString), true);
        }

        [ConsoleCommand("sttoggleextrapocketsbutton")]
        void ToggleExtraPockets(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            PlayerInfo pi;
            if (!pcdData.pEntity.TryGetValue(player.userID, out pi)) return;
            if (pi.extra_pockets_button)
            {
                pi.extra_pockets_button = false;
                SkillTree_PlayerMenu(player);
                CuiHelper.DestroyUi(player, "ExtraPocketsButton");
            }
            else
            {
                if (buffDetails.ContainsKey(player.userID) && buffDetails[player.userID].ContainsBuff(Buff.ExtraPockets))
                {
                    SendExtraPocketsButton(player);
                }
                pi.extra_pockets_button = true;
                SkillTree_PlayerMenu(player);
            }
        }

        [ConsoleCommand("sttogglenotifications")]
        void ToggleNotifications(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            ToggleNotifications(player);
            SkillTree_PlayerMenu(player);
        }

        [ConsoleCommand("dotogglexpdrops")]
        void ToggleXPDropsFromMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            ToggleXPDrops(player);
            SkillTree_PlayerMenu(player);
        }

        [ConsoleCommand("dotogglexphud")]
        void ToggleXPHudFromMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            ToggleXPHud(player);
            SkillTree_PlayerMenu(player);
        }

        [ConsoleCommand("stcloseplayersettings")]
        void ClosePlayerSettings(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            CuiHelper.DestroyUi(player, "SkillTree_PlayerMenu");
        }

        [ConsoleCommand("stclosebuffsettings")]
        void CloseBuffSettings(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            CuiHelper.DestroyUi(player, "SkillTreePlayerSettingsBackPanel");
            CuiHelper.DestroyUi(player, "SkillTree_Buff_Settings");
        }

        #endregion

        #region Buff Menu

        private void SendPlayerSettingsMenu(BasePlayer player)
        {
            SkillTreePlayerSettingsBackPanel(player);
            SkillTree_Buff_Settings(player, null);
        }

        private void SkillTreePlayerSettingsBackPanel(BasePlayer player)
        {
            if (!ImagesLoaded) Player.Message(player, "Still caching images...", config.misc_settings.ChatID);
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0 0 0 0.98" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, "Overlay", "SkillTreePlayerSettingsBackPanel");

            CuiHelper.DestroyUi(player, "SkillTreePlayerSettingsBackPanel");
            CuiHelper.AddUi(player, container);
        }

        bool IsUltimate(Buff buff)
        {
            return (int)buff >= 991;
        }

        private void SkillTree_Buff_Settings(BasePlayer player, BuffDetails buffData)
        {
            if (buffData == null && !GetBuffDetails(player.userID, out buffData)) return;

            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "SkillTree_Buff_Settings",
                Parent = "Overlay",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIBuffSettings", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 26, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-495.065 190.404", OffsetMax = "-180.005 250.404" }
                }
            });

            List<KeyValuePair<Buff, BuffInfo>> buffs = Pool.Get<List<KeyValuePair<Buff, BuffInfo>>>();
            buffs.AddRange(buffData.GetBuffs());
            buffs.RemoveAll(x => config.misc_settings.noSettingsBuffs.Contains(x.Key) || IsUltimate(x.Key));

            var listSize = buffs.Count;

            container.Add(new CuiElement
            {
                Name = "STBuffMenuScrollPanel",
                Parent = "SkillTree_Buff_Settings",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-157.53 {-117.665 - (Math.Min(listSize, 6) * 58)}", OffsetMax = "157.53 -59.665" }
                }
            });

            if (listSize > 7)
            {
                container.Add(new CuiElement
                {
                    Name = "BuffSettingsSB",
                    Parent = "STBuffMenuScrollPanel",
                    Components = {
                    new CuiScrollViewComponent {
                        MovementType = UnityEngine.UI.ScrollRect.MovementType.Elastic,
                        Vertical = true,
                        Inertia = true,
                        Horizontal = false,
                        Elasticity = 0.25f,
                        DecelerationRate = 0.3f,
                        ScrollSensitivity = 24f,
                        ContentTransform = new CuiRectTransform { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 " + ((58 * (listSize)) * -1), OffsetMax = "0 0" },
                        VerticalScrollbar = new CuiScrollbar() { Size = 4f, AutoHide = true }, // Remove this to remove the scroll bar and just have it scrollable with mwheel
                    },
                    new CuiNeedsCursorComponent()
                }
                });
            }


            container.Add(new CuiElement
            {
                Name = "SkillTree_BuffMenu_close",
                Parent = "STBuffMenuScrollPanel",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIClose", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-29 -54.635", OffsetMax = "29 -22.635" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = $"stclosebuffsettings" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-29 -16", OffsetMax = "29 16" }
            }, "SkillTree_BuffMenu_close", "SkillTree_PlayerMenu_close_button");

            if (listSize == 0)
            {
                container.Add(new CuiElement
                {
                    Name = "NoBuffsMSg",
                    Parent = "SkillTree_Buff_Settings",
                    Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UINoSupportedBuffs", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "1 0.8329726 0 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-157.53 -87.668", OffsetMax = "157.53 -29.673" }
                }
                });
                Pool.FreeUnmanaged(ref buffs);

                CuiHelper.DestroyUi(player, "SkillTree_Buff_Settings");
                CuiHelper.AddUi(player, container);
                return;
            }

            var parent = listSize > 7 ? "BuffSettingsSB" : "STBuffMenuScrollPanel";

            var count = 0;
            foreach (var buff in buffs)
            {
                container.Add(new CuiElement
                {
                    Name = $"STBuffMenu_{count}",
                    Parent = parent,
                    Components = {
                        new CuiNeedsCursorComponent(),
                        new CuiImageComponent{ Color = "0.1132075 0.1073335 0.1073335 1" },
                        new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-157.53 {-58.665 - (count * 58)}", OffsetMax = $"157.53 {0 - (count * 58)}" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "STBuffMenuInner",
                    Parent = $"STBuffMenu_{count}",
                    Components = {
                        new CuiNeedsCursorComponent(),
                        new CuiImageComponent{ Color = "0.2264151 0.2264151 0.2264151 0.9607843" },
                        new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-155.53 -27", OffsetMax = "155.53 27" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "STBuffMenuDescription",
                    Parent = $"STBuffMenu_{count}",
                    Components = {
                    new CuiTextComponent { Text = string.Format(lang.GetMessage("BuffSettingDisplayFormat", this, player.UserIDString), lang.GetMessage($"UI{buff.Key}", this, player.UserIDString)), Font = "robotocondensed-bold.ttf", FontSize = 18, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-147 -26", OffsetMax = "52.24 26" }
                }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "0.1607843 0.1607843 0.1607843 1", Command = $"stchangeplayerbuffsettings {buff.Key} {buff.Value.enabled}" },
                    Text = { Text = buff.Value.enabled ? "<color=#53ad2c>Enabled</color>" : "Disabled", Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "0.5943396 0.131764 0.1842591 1" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "68.53 -22", OffsetMax = "150.53 22" }
                }, $"STBuffMenu_{count}", "STBuffMenuButton");

                count++;
            }

            Pool.FreeUnmanaged(ref buffs);

            CuiHelper.DestroyUi(player, "SkillTree_Buff_Settings");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("stchangeplayerbuffsettings")]
        void ChangePlayerBuffSetting(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            if (!Enum.TryParse<Buff>(arg.Args[0], out var buff)) return;
            if (!bool.TryParse(arg.Args[1], out var currentValue)) return;
            if (!GetBuffDetails(player.userID, out var buffData) || !buffData.GetBuffInfo(buff, out var value)) return;
            value.SetEnabled(player, buff, !currentValue);

            SkillTree_Buff_Settings(player, buffData);
        }

        void CheckRequirements(BasePlayer player, Buff buff, float value, bool enable)
        {
            switch (buff)
            {
                case Buff.Awareness:
                    SetAwarenessBlock(player, !enable);
                    return;

                case Buff.Metabolism_Boost:
                    if (enable)
                    {
                        IncreaseCalories(player, value);
                        return;
                    }
                    player.metabolism.calories.max = 500f;
                    player.metabolism.hydration.max = 250f;
                    player.SendNetworkUpdate();
                    return;

                case Buff.HealthRegen:
                    SetRegenBlock(player, !enable);
                    return;

                case Buff.WaterBreathing:
                    SetWaterBreathingBlock(player, !enable);
                    return;

                case Buff.InstantUntie:
                    SetInstantUntieBlock(player, !enable);
                    return;

                case Buff.Comfort:
                    SetComfortBlock(player, !enable);
                    return;

                case Buff.Human_Workbench:
                    SetMobileWorkbenchBlock(player, !enable);
                    return;

                case Buff.Heli_Speed:
                case Buff.Heli_Fuel_Rate:
                case Buff.Boat_Speed:
                case Buff.Boat_Fuel_Rate:
                case Buff.BikeEnginePower:
                case Buff.Riding_Speed:
                    if (!enable) player.EnsureDismounted();
                    return;
            }
        }

        #endregion

        #region Health Regen

        //private static Dictionary<BasePlayer, float> RegenAmount = new Dictionary<BasePlayer, float>();

        bool HasRegen(BasePlayer player)
        {
            return player.GetComponent<Regen>() != null;
        }

        void UpdateRegen(BasePlayer player, float value)
        {
            var gameObject = player.GetComponent<Regen>();
            if (gameObject == null) gameObject = player.gameObject.AddComponent<Regen>();
            gameObject.UpdateRegenRage(value);
            gameObject.name = "SkillTreeRegen";
            if (DisabledPlayers.Contains(player.userID)) gameObject.SetRegenBlock(true);
        }

        static void DestroyRegen(BasePlayer player)
        {
            //if (RegenAmount.ContainsKey(player)) RegenAmount.Remove(player);
            var gameObject = player.GetComponent<Regen>();
            if (gameObject != null) UnityEngine.Object.DestroyImmediate(gameObject);
        }

        //public static Dictionary<ulong, float> took_damage = new Dictionary<ulong, float>();

        void AddRegenDelay(BasePlayer player)
        {
            if (config.buff_settings.health_regen_combat_delay <= 0) return;
            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd) || !bd.ContainsBuff(Buff.HealthRegen)) return;

            var gameObject = player.GetComponent<Regen>();
            if (gameObject == null) return;
            gameObject.AddDamageCooldown(config.buff_settings.health_regen_combat_delay);
        }

        void SetRegenBlock(BasePlayer player, bool shouldBlock)
        {
            if (!buffDetails.TryGetValue(player.userID, out var bd) || !bd.ContainsBuff(Buff.HealthRegen)) return;
            var gameObject = player.GetComponent<Regen>();
            if (gameObject == null) return;
            gameObject.SetRegenBlock(shouldBlock);
        }

        public class Regen : MonoBehaviour
        {
            private BasePlayer player;
            private float regenDelay;
            private float _regenAmount;
            private bool IsBlocked;

            private float damageCooldownTime;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                regenDelay = Time.time + 1f;
                _regenAmount = 0;
            }

            public void FixedUpdate()
            {
                if (player == null || !player.IsConnected)
                {
                    Destroy(this);
                    return;
                }
                if (regenDelay < Time.time)
                {
                    regenDelay = Time.time + 1f;
                    if (damageCooldownTime > Time.time || IsBlocked) return;
                    DoRegen();
                }
            }

            public void SetRegenBlock(bool shouldBlock)
            {
                IsBlocked = shouldBlock;
            }

            public void AddDamageCooldown(float time)
            {
                damageCooldownTime = Time.time + time;
            }

            public void UpdateRegenRage(float value)
            {
                _regenAmount = value;
            }

            public void DoRegen()
            {
                if (!player.IsAlive() || player.health >= player.MaxHealth()) return;
                player._health += _regenAmount;
                player.SendNetworkUpdate();
            }

            private void OnDestroy()
            {
                enabled = false;
                CancelInvoke();
            }
        }

        #endregion

        #region AnimalTracker

        Dictionary<BasePlayer, float> track_delays = new Dictionary<BasePlayer, float>();

        void TrackAnimal(BasePlayer player)
        {
            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - TrackAnimal. [Online = {player.IsConnected}]", this, true);
                return;
            }
            if (!bd.ContainsBuff(Buff.AnimalTracker)) return;

            if (!track_delays.ContainsKey(player)) track_delays.Add(player, Time.time + config.buff_settings.track_delay);
            else if (track_delays[player] < Time.time) track_delays[player] = Time.time + config.buff_settings.track_delay;
            else
            {
                Player.Message(player, string.Format(lang.GetMessage("TrackWait", this, player.UserIDString), Math.Round(track_delays[player] - Time.time, 2)), config.misc_settings.ChatID);
                return;
            }

            var animals = FindEntitiesOfType<BaseEntity>(player.transform.position, 300f);
            animals.RemoveAll(x => x.skinID > 0 || !IsAnimal(x));
            BaseEntity animal = animals.Count > 0 ? animals.OrderBy(x => Vector3.Distance(x.transform.position, player.transform.position)).First() : null;

            if (animal == null)
            {
                Player.Message(player, lang.GetMessage("NoAnimals", this, player.UserIDString), config.misc_settings.ChatID);
                Pool.FreeUnmanaged(ref animals);
                return;
            }

            var distance = Vector3.Distance(player.transform.position, animal.transform.position);
            string text;
            if (distance < 50) text = lang.GetMessage("TrackFresh", this, player.UserIDString);
            else if (distance < 100) text = lang.GetMessage("TrackOlder", this, player.UserIDString);
            else text = lang.GetMessage("TrackOldest", this, player.UserIDString);
            var direction = player.transform.position - animal.transform.position;
            direction.Normalize();
            Player.Message(player, string.Format(text, Direction(direction.ZX2D())), config.misc_settings.ChatID);
            Pool.FreeUnmanaged(ref animals);
        }

        bool IsAnimal(BaseEntity entity)
        {
            return entity is BaseAnimalNPC || entity is Tiger || entity is Panther || entity is Crocodile || entity is WildlifeHazard;
        }

        string Direction(Vector2 dir)
        {
            if (dir.x >= -1.0 && dir.x <= -0.8 && dir.y >= -0.5 && dir.y <= 0.5) return "North";
            if (dir.x >= -1.0 && dir.x <= -0.5 && dir.y >= 0.5 && dir.y <= 1.0) return "North-West";
            if (dir.x >= -0.5 && dir.x <= 0.5 && dir.y >= 0.8 && dir.y <= 1.0) return "West";
            if (dir.x >= 0.5 && dir.x <= 1.0 && dir.y >= 0.5 && dir.y <= 1.0) return "South-West";
            if (dir.x >= -0.5 && dir.x <= 0.5 && dir.y >= -1.0 && dir.y <= -0.8) return "East";
            if (dir.x >= -1.0 && dir.x <= -0.5 && dir.y >= -1.0 && dir.y <= -0.5) return "North-East";
            if (dir.x >= 0.5 && dir.x <= 1.0 && dir.y >= -1.0 && dir.y <= -0.5) return "South-East";
            if (dir.x >= 0.8 && dir.x <= 1.0 && dir.y >= -0.5 && dir.y <= 0.5) return "South";
            return null;
        }

        #endregion

        #region Extra Pockets

        public class ItemInfo
        {
            public string shortname;
            public ulong skin;
            public int amount;
            public float condition;
            public float maxCondition;
            public int ammo;
            public string ammotype;
            public int position;
            public int frequency;
            public Item.Flag flags;
            public KeyInfo instanceData;
            public class KeyInfo
            {
                public int dataInt;
                public int blueprintTarget;
                public int blueprintAmount;
            }
            public int contentsSlots;
            public List<ItemInfo> item_contents;
            public string text;
            public string name;
            public List<ItemOwnershipShare> ownershipShares;
            public int armorSlots;

            public object[] ToObject()
            {
                return new object[]
                {
                    shortname,
                    skin,
                    amount,
                    condition,
                    maxCondition,
                    ammo,
                    ammotype,
                    position,
                    frequency,
                    flags,
                    instanceData,
                    instanceData?.dataInt,
                    instanceData?.blueprintTarget,
                    instanceData?.blueprintAmount,
                    contentsSlots,
                    text,
                    name,
                    ownershipShares,
                    armorSlots
                };
            }
        }

        Dictionary<ulong, float> bagCooldown = new Dictionary<ulong, float>();

        [ChatCommand("pouch")]
        void OpenBagCMD(BasePlayer player)
        {
            OpenBag(player);
        }

        [ConsoleCommand("pouch")]
        void OpenBagConsoleCMD(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            OpenBag(player);
        }

        void OpenBag(BasePlayer player)
        {
            if (player.IsDead() || Interface.CallHook("STOnPouchOpen", player) != null) return;
            BuffDetails bd;
            if (GetBuffDetails(player.userID, out bd) && bd.GetBuff(Buff.ExtraPockets, out var value))
            {
                // Handle cooldown
                if (!bagCooldown.ContainsKey(player.userID)) bagCooldown.Add(player.userID, Time.time + config.buff_settings.bag_cooldown_time);
                else
                {
                    if (bagCooldown[player.userID] < Time.time) bagCooldown[player.userID] = Time.time + config.buff_settings.bag_cooldown_time;
                    else
                    {
                        Player.Message(player, string.Format(lang.GetMessage("BagCooldownMsg", this, player.UserIDString), Math.Round(bagCooldown[player.userID] - Time.time, 2)), config.misc_settings.ChatID);
                        return;
                    }
                }
                player.EndLooting();
                var bag = GenerateBag(player, Convert.ToInt32(value));
                ServerMgr.Instance.Invoke(() =>
                {
                    if (bag != null) bag.PlayerOpenLoot(player, "", false);
                    Interface.CallHook("STOnPouchOpened", player, bag);
                }, 0.1f);
            }
            else
            {
                Player.Message(player, lang.GetMessage("NeedBagBuff", this, player.UserIDString), config.misc_settings.ChatID);
            }
        }

        bool FetchItems(BasePlayer player, ItemContainer container)
        {
            if (player.IsDead() || !player.IsConnected) return false;
            PlayerInfo playerData;
            if (pcdData.pEntity.TryGetValue(player.userID, out playerData))
            {
                if (playerData.pouch_items == null || playerData.pouch_items.Count == 0) return true;
                foreach (var item in playerData.pouch_items)
                {
                    if (item.amount <= 0) continue;
                    try
                    {
                        GetRestoreItem(player, container, item);
                    }
                    catch
                    {
                        Puts($"Failed to restore item for {player.displayName} [{player.userID}]:\n- Container null: {container == null}\n- Name: {item.name ?? "Null"}\n- Shortname: {item.shortname}\n- Skin: {item.skin}\n- Amount: {item.amount}");
                    }
                }
                playerData.pouch_items.Clear();
            }

            return true;
        }

        Item GetRestoreItem(BasePlayer player, ItemContainer container, ItemInfo savedItem)
        {
            var item = ItemManager.CreateByName(savedItem.shortname, savedItem.amount, savedItem.skin);
            if (savedItem.name != null) item.name = savedItem.name;
            if (savedItem.text != null) item.text = savedItem.text;
            item.condition = savedItem.condition;
            item.maxCondition = savedItem.maxCondition;
            if (savedItem.contentsSlots > 0 && item.info.isWearable && item.info.TryGetComponent<ItemModContainerArmorSlot>(out var aSlots))
            {
                aSlots.CreateAtCapacity(savedItem.contentsSlots, item);
            }
            BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon != null)
            {
                if (!string.IsNullOrEmpty(savedItem.ammotype))
                    weapon.primaryMagazine.ammoType = ItemManager.FindItemDefinition(savedItem.ammotype);
                weapon.primaryMagazine.contents = savedItem.ammo;
            }
            FlameThrower flameThrower = item.GetHeldEntity() as FlameThrower;
            if (flameThrower != null) flameThrower.ammo = savedItem.ammo;
            if (savedItem.instanceData != null)
            {
                item.instanceData = new ProtoBuf.Item.InstanceData();
                item.instanceData.ShouldPool = false;
                item.instanceData.dataInt = savedItem.instanceData.dataInt;
                item.instanceData.blueprintTarget = savedItem.instanceData.blueprintTarget;
                item.instanceData.blueprintAmount = savedItem.instanceData.blueprintAmount;
            }
            item.flags = savedItem.flags;
            if (savedItem.item_contents != null && savedItem.item_contents.Count > 0)
            {
                if (item.contents == null)
                {
                    item.contents = new ItemContainer();
                    item.contents.ServerInitialize(null, savedItem.item_contents.Count);
                    item.contents.GiveUID();
                    item.contents.parent = item;
                }
                savedItem.item_contents.RemoveAll(x => x.amount <= 0);

                foreach (var _item in savedItem.item_contents)
                {
                    GetRestoreItem(player, item.contents, _item);
                }
            }
            if (savedItem.ownershipShares != null && savedItem.ownershipShares.Count > 0)
                item.ownershipShares = savedItem.ownershipShares;

            item.MarkDirty();
            if (!item.MoveToContainer(container, savedItem.position)) player.GiveItem(item);
            return item;
        }

        StorageContainer GenerateBag(BasePlayer player, int slots)
        {
            var pos = new Vector3(player.transform.position.x, -100, player.transform.position.z);
            var storage = GameManager.server.CreateEntity(config.buff_settings.bag_prefab, pos) as StorageContainer;
            UnityEngine.Object.DestroyImmediate(storage.GetComponent<GroundWatch>());
            UnityEngine.Object.DestroyImmediate(storage.GetComponent<DestroyOnGroundMissing>());
            storage.Spawn();
            storage.OwnerID = player.userID;

            storage.inventory.capacity = slots;
            storage.inventorySlots = slots;

            FetchItems(player, storage.inventory);
            storage.OwnerID = player.userID;
            containers.Add(storage.inventory.uid.Value, new Containers(storage, player.UserIDString, player.userID));
            return storage;
        }

        //List<StorageContainer> containers = new List<StorageContainer>();

        Dictionary<ulong, Containers> containers = new Dictionary<ulong, Containers>();
        public class Containers
        {
            public StorageContainer container;
            public string userIDString;
            public ulong userID;
            public Containers(StorageContainer container, string userIDString, ulong userID)
            {
                this.container = container;
                this.userIDString = userIDString;
                this.userID = userID;
            }
        }

        private object False = false;
        private object True = true;

        [HookMethod("IsExtraPocketsContainer")]
        public object IsExtraPocketsContainer(ulong uid)
        {
            if (containers.ContainsKey(uid)) return True;
            return False;
        }

        [HookMethod("GetExtraPocketsContainerProvider")]
        public Func<ulong, bool> GetExtraPocketsContainerProvider()
        {
            return new Func<ulong, bool>(uid =>
            {
                if (containers.ContainsKey(uid)) return true;
                return false;
            });
        }

        [HookMethod("GetExtraPocketsOwnerIdProvider")]
        public Func<ulong, string> GetExtraPocketsOwnerIdProvider()
        {
            return new Func<ulong, string>(uid =>
            {
                Containers data;
                if (containers.TryGetValue(uid, out data)) return data.userIDString;
                return null;
            });
        }

        bool StorePlayerItems(BasePlayer player, StorageContainer container)
        {
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData))
            {
                //LogToFile("DataFailure", $"[{DateTime.Now}] Failed to acquire data for {player.displayName}[{player.UserIDString}] - StorePlayerItems. [Online = {player.IsConnected}]", this, true);
                return false;
            }
            List<Item> items = Pool.Get<List<Item>>();
            items.AddRange(container.inventory?.itemList);
            var droppedItemsStr = "";
            foreach (var item in items)
            {
                if (config.tools_black_white_list_settings.white_list.Count > 0)
                {
                    if (!config.tools_black_white_list_settings.white_list.Contains(item.info.shortname))
                    {
                        player.GiveItem(item);
                        droppedItemsStr += $"{item.name ?? item.info.displayName.english}\n";
                    }
                }
                else if (config.tools_black_white_list_settings.black_list.Contains(item.info.shortname))
                {
                    player.GiveItem(item);
                    droppedItemsStr += $"{item.name ?? item.info.displayName.english}\n";
                }
            }

            if (!string.IsNullOrEmpty(droppedItemsStr))
            {
                if (config.tools_black_white_list_settings.white_list.Count > 0) Player.Message(player, string.Format(lang.GetMessage("WhitelistedItemsNotFound", this, player.UserIDString), droppedItemsStr), config.misc_settings.ChatID);
                else Player.Message(player, string.Format(lang.GetMessage("BlacklistedItemsFound", this, player.UserIDString), droppedItemsStr), config.misc_settings.ChatID);
            }

            Pool.FreeUnmanaged(ref items);

            ItemManager.DoRemoves(); // Handles 0 amounts.
            playerData.pouch_items.AddRange(GetItems(player, container.inventory));

            containers.Remove(container.inventory.uid.Value);
            if (!container.IsDestroyed) container.Invoke(container.KillMessage, 0.01f);

            return true;
        }

        List<ItemInfo> GetItems(BasePlayer player, ItemContainer container)
        {
            List<ItemInfo> result = new List<ItemInfo>();
            foreach (var item in container.itemList)
            {
                if (item.amount <= 0) continue;
                result.Add(new ItemInfo()
                {
                    shortname = item.info.shortname,
                    position = item.position,
                    amount = item.amount,
                    ammo = item.GetHeldEntity() is BaseProjectile ? (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents : item.GetHeldEntity() is FlameThrower ? (item.GetHeldEntity() as FlameThrower).ammo : 0,
                    ammotype = (item.GetHeldEntity() as BaseProjectile)?.primaryMagazine.ammoType.shortname ?? null,
                    skin = item.skin,
                    condition = item.condition,
                    maxCondition = item.maxCondition,
                    flags = item.flags,
                    instanceData = item.instanceData != null ? new ItemInfo.KeyInfo()
                    {
                        dataInt = item.instanceData.dataInt,
                        blueprintTarget = item.instanceData.blueprintTarget,
                        blueprintAmount = item.instanceData.blueprintAmount,
                    }
                    : null,
                    name = item.name ?? null,
                    text = item.text ?? null,
                    item_contents = item.contents?.itemList != null ? GetItems(player, item.contents) : null,
                    contentsSlots = item.contents?.capacity ?? 0,
                    ownershipShares = item.ownershipShares
                });
            }
            return result;
        }

        void OnLootEntityEnd(BasePlayer player, StorageContainer container)
        {
            if (player == null || container == null || container.inventory == null) return;
            if (containers.ContainsKey(container.inventory.uid.Value))
            {
                StorePlayerItems(player, container);
            }
        }

        void OnTimedExplosiveExplode(TimedExplosive explosive)
        {
            var player = explosive.creatorEntity as BasePlayer;
            if (player == null) return;

            BuffDetails bd;
            float value;
            if (!GetBuffDetails(player.userID, out bd) || !bd.GetBuff(Buff.Double_Explosion_Chance, out value)) return;
            if (!RollSuccessful(value)) return;
            if (config.buff_settings.raid_perk_settings.Double_Explosion_chance_settings.blacklist.Contains(explosive.ShortPrefabName)) return;
            if (explosive is MLRSRocket && !config.ultimate_settings.ultimate_raiding.allow_doubling) return;
            if (!PassRaidableBasesCheck(explosive, Buff.Double_Explosion_Chance)) return;

            var new_explosive = GameManager.server.CreateEntity(explosive.PrefabName, explosive.transform.position, explosive.transform.rotation) as TimedExplosive;
            if (new_explosive == null) return;
            new_explosive.creatorEntity = player;

            new_explosive.explosionRadius = explosive.explosionRadius;
            new_explosive.minExplosionRadius = explosive.minExplosionRadius;

            var parent = explosive.GetParentEntity();
            if (parent != null)
            {
                new_explosive.DoStick(explosive.transform.position, explosive.transform.localPosition, parent, null);
            }

            ServerMgr.Instance.Invoke(() =>
            {
                if (new_explosive != null)
                {
                    Unsubscribe(nameof(OnTimedExplosiveExplode));
                    new_explosive.Explode();
                    Subscribe(nameof(OnTimedExplosiveExplode));
                }
            }, 0.5f);
        }

        void OnEntityKill(StorageContainer container)
        {
            RemoveContainer(container);
        }

        void OnEntityKill(Workbench workbench)
        {
            WorkbenchSkillOnEntityKill(workbench);
        }

        void OnEntityKill(DudTimedExplosive entity)
        {
            if (entity == null || entity.net == null || entity.creatorEntity is not BasePlayer) return;
            Duds.Remove(entity.net.ID.Value);
        }        

        void RemoveContainer(StorageContainer container)
        {
            if (container == null) return;
            if (container is LootContainer lootContainer)
            {
                RemoveLootContainerFromList(lootContainer);
                return;
            }
            if (container.inventory == null || !containers.ContainsKey(container.inventory.uid.Value)) return;
            var p = BasePlayer.FindByID(container.OwnerID);
            if (p == null) return;
            StorePlayerItems(p, container);
            return;
        }

        void RemoveLootContainerFromList(LootContainer lootContainer)
        {
            if (lootContainer.net == null) return;
            looted_containers.Remove(lootContainer.net.ID.Value);
            looted_crates.Remove(lootContainer.net.ID.Value);
        }

        Dictionary<ulong, DudTimedExplosive> Duds = new Dictionary<ulong, DudTimedExplosive>();

        private object OnExplosiveDud(DudTimedExplosive dudTimedExplosive)
        {
            if (dudTimedExplosive == null || dudTimedExplosive.net == null) return null;
            var player = dudTimedExplosive.creatorEntity as BasePlayer;
            if (player == null || player.IsNpc || !player.userID.IsSteamId()) return null;

            BuffDetails bd;
            float value;
            if (GetBuffDetails(player.userID, out bd) && bd.GetBuff(Buff.Dudless_Explosive, out value) && RollSuccessful(value) && PassRaidableBasesCheck(dudTimedExplosive, Buff.Dudless_Explosive))
            {
                PlayerInfo pi;
                if (pcdData.pEntity.TryGetValue(player.userID, out pi) && pi.notifications) Player.Message(player, lang.GetMessage("DudExplodedAnyway", this, player.UserIDString), config.misc_settings.ChatID);
                return false;
            }

            if (!Duds.ContainsKey(dudTimedExplosive.net.ID.Value)) Duds.Add(dudTimedExplosive.net.ID.Value, dudTimedExplosive);

            return null;
        }

        void OnExplosiveThrown(BasePlayer player, TimedExplosive timedExplosive, ThrownWeapon item) => HandleExplosionRadius(player, timedExplosive);
        void OnExplosiveDropped(BasePlayer player, TimedExplosive timedExplosive, ThrownWeapon item) => HandleExplosionRadius(player, timedExplosive);
        void OnRocketLaunched(BasePlayer player, TimedExplosive entity) => HandleRocket(player, entity);
        void HandleExplosionRadius(BasePlayer player, TimedExplosive timedExplosive)
        {
            if (config.buff_settings.raid_perk_settings.Explosion_Radius_settings.blacklist.Contains(timedExplosive.ShortPrefabName)) return;
            BuffDetails bd;
            float value;
            if (!GetBuffDetails(player.userID, out bd) || !bd.GetBuff(Buff.Explosion_Radius, out value) || !PassRaidableBasesCheck(timedExplosive, Buff.Explosion_Radius)) return;
            timedExplosive.explosionRadius += timedExplosive.explosionRadius * value;
            if (config.buff_settings.raid_perk_settings.Explosion_Radius_settings.add_to_minimum) timedExplosive.minExplosionRadius += timedExplosive.minExplosionRadius * value;
        }

        void HandleRocket(BasePlayer player, TimedExplosive timedExplosive)
        {
            if (!GetBuffDetails(player.userID, out var bd)) return;

            if (bd.GetBuff(Buff.Rocket_Velocity, out var value))
            {
                if (!timedExplosive.TryGetComponent<ServerProjectile>(out var projectile)) return;
                projectile.CurrentVelocity += (projectile.CurrentVelocity * value);
            }

            if (bd.GetBuff(Buff.Explosion_Radius, out value) && !config.buff_settings.raid_perk_settings.Explosion_Radius_settings.blacklist.Contains(timedExplosive.ShortPrefabName) && PassRaidableBasesCheck(timedExplosive, Buff.Explosion_Radius))
            {
                timedExplosive.explosionRadius += timedExplosive.explosionRadius * value;
                if (config.buff_settings.raid_perk_settings.Explosion_Radius_settings.add_to_minimum) timedExplosive.minExplosionRadius += timedExplosive.minExplosionRadius * value;
            }
        }

        bool CheckedButtonReady = false;
        List<BasePlayer> waitingPlayers = new List<BasePlayer>();
        Timer checkTimer;

        void CheckButtonReady()
        {
            PlayerInfo playerData;
            if (!config.general_settings.useSkinForExtraPockets)
            {
                if (Convert.ToBoolean(ImageLibrary?.Call("HasImage", ExtraPocketsImg.Key)))
                {
                    CheckedButtonReady = true;
                    foreach (var player in waitingPlayers)
                    {
                        if (pcdData.pEntity.TryGetValue(player.userID, out playerData) && playerData.extra_pockets_button)
                            SendExtraPocketsButton(player);
                    }
                    waitingPlayers.Clear();
                    waitingPlayers = null;
                    checkTimer = null;
                }
                else
                {
                    checkTimer = timer.In(5f, CheckButtonReady);
                }
            }
            else
            {
                CheckedButtonReady = true;
                foreach (var player in waitingPlayers)
                {
                    if (pcdData.pEntity.TryGetValue(player.userID, out playerData) && playerData.extra_pockets_button)
                        SendExtraPocketsButton(player);
                }
                waitingPlayers.Clear();
                waitingPlayers = null;
                if (checkTimer != null && !checkTimer.Destroyed) checkTimer.Destroy();
                checkTimer = null;
            }
        }

        private void SendExtraPocketsButton(BasePlayer player)
        {
            if (string.IsNullOrEmpty(ExtraPocketsImg.Key) && string.IsNullOrEmpty(ExtraPocketsImgSkin.Key)) return;
            if (!CheckedButtonReady)
            {
                if (!waitingPlayers.Contains(player)) waitingPlayers.Add(player);
                if (checkTimer == null || checkTimer.Destroyed) CheckButtonReady();
                return;
            }

            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.969 0.922 0.882 0.035", Sprite = "assets/content/ui/ui.background.tiletex.psd" },
                RectTransform = { AnchorMin = config.tools_black_white_list_settings.extra_pockets_button_anchor.anchorMin, AnchorMax = config.tools_black_white_list_settings.extra_pockets_button_anchor.anchorMax, OffsetMin = config.tools_black_white_list_settings.extra_pockets_button_anchor.offsetMin, OffsetMax = config.tools_black_white_list_settings.extra_pockets_button_anchor.offsetMax }
            }, "Overlay", "ExtraPocketsButton");

            if (!config.general_settings.useSkinForExtraPockets && ImageLibrary != null && ImageLibrary.IsLoaded)
            {
                container.Add(new CuiElement
                {
                    Name = "Image_5410",
                    Parent = "ExtraPocketsButton",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = (string)ImageLibrary?.Call("GetImage", ExtraPocketsImg.Key) },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
                });
            }
            else
            {
                container.Add(new CuiElement
                {
                    Name = "Image_5410",
                    Parent = "ExtraPocketsButton",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 1", ItemId = 1751045826, SkinId = ExtraPocketsImgSkin.Value },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
                });
            }

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = $"openextrapockets" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, "ExtraPocketsButton", "Button_2451");

            CuiHelper.DestroyUi(player, "ExtraPocketsButton");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("openextrapockets")]
        void OpenExtraPocketsButton(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            OpenBag(player);
        }

        #endregion

        #region Scoreboard

        void CheckScoreBoardConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            CheckScoreBoard(player);
        }

        void CheckScoreBoard(BasePlayer player)
        {
            if (ScoreInitializing)
            {
                PrintToChat(player, "Scoreboard is still being loaded. Please try again later.");
                return;
            }
            if (ScoreBoard.lastChecked + config.misc_settings.scoreBoardSettings.ScoreUpdateTime < Time.time) UpdateScoreBoard(false);
            ScoreBoardBackPanel(player);
            try
            {
                ScoreBoardPanel(player);
            }
            catch(Exception ex)
            {
                Puts($"Error sending scoreboard. {ex.Message}");
                CuiHelper.DestroyUi(player, "ScoreboardBackPanel");
            }
        }

        void UpdateScoreBoard(bool initialize)
        {
            if (initialize)
            {
                ServerMgr.Instance.StartCoroutine(GetScoreDataFromFiles(initialize));
                return;
            }
            else if (pcdData.pEntity.Count == 0) return;

            if (ScoreInitializing) return;

            if (ScoreBoard.data == null) return;
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!pcdData.pEntity.TryGetValue(player.userID, out var pi) || permission.UserHasPermission(player.UserIDString, perm_no_scoreboard)) continue;
                if (ScoreBoard.data.TryGetValue(player.userID, out var scoreData)) scoreData.xp = pi.xp;
                else ScoreBoard.data.Add(player.userID, new ScoreboardInfo.ScoreInfo(player.displayName, pi.xp, pi.prestige_level, pi.prestige_level > 0 ? config.prestige_settings.levels.TryGetValue(pi.prestige_level, out var presData) ? presData.RankUpPic : 0 : 0));
            }
            ScoreBoard.UpdateScores();
        }

        bool ScoreInitializing;
        IEnumerator GetScoreDataFromFiles(bool callBack)
        {
            ScoreInitializing = true;
            var count = 0;
            Dictionary<ulong, ScoreboardInfo.ScoreInfo> data = new Dictionary<ulong, ScoreboardInfo.ScoreInfo>();

            foreach (var playerData in pcdData.pEntity)
            {
                if (permission.UserHasPermission(playerData.Key.ToString(), perm_no_scoreboard)) continue;
                data[playerData.Key] = new ScoreboardInfo.ScoreInfo(playerData.Value.name ?? playerData.Key.ToString(), playerData.Value.xp, playerData.Value.prestige_level, playerData.Value.prestige_level > 0 ? config.prestige_settings.levels.TryGetValue(playerData.Value.prestige_level, out var presData) ? presData.RankUpPic : 0 : 0);
            }

            foreach (var file in Directory.GetFiles(NewDirectory))
            {
                try
                {
                    var useridString = FormatUserIDFromPath(file);
                    var userid = Convert.ToUInt64(useridString);
                    if (userid == 0 || data.ContainsKey(userid)) continue;
                    if (permission.UserHasPermission(useridString, perm_no_scoreboard)) continue;
                    var obj = LoadOfflinePlayerInfo(file, false);
                    data.Add(userid, new ScoreboardInfo.ScoreInfo(obj.name ?? useridString, obj.xp, obj.prestige_level, obj.prestige_level > 0 ? config.prestige_settings.levels.TryGetValue(obj.prestige_level, out var presData) ? presData.RankUpPic : 0 : 0));
                }
                catch
                {
                    Puts($"Error loading file: [{FormatUserIDFromPath(file)}] {file}");
                }
                count++;
                if (count > config.misc_settings.scoreBoardSettings.ScoreUpdateIteration)
                {
                    count = 0;
                    yield return CoroutineEx.waitForEndOfFrame;
                }
            }

            ScoreBoard.data = data;
            ScoreBoard.UpdateScores();
            ScoreBoard.lastChecked = Time.time;

            ScoreInitializing = false;
            if (callBack) UpdateScoreBoard(false);
        }

        private void ScoreBoardBackPanel(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0 0 0 0.99" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, "Overlay", "ScoreboardBackPanel");

            CuiHelper.DestroyUi(player, "ScoreboardBackPanel");
            CuiHelper.AddUi(player, container);
        }

        private void ScoreBoardPanel(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "ScoreBoardPanel",
                Parent = "Overlay",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIScoresTitle", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 32, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-116.003 145.3", OffsetMax = "115.997 187.3" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "STScoreTitleRank",
                Parent = "ScoreBoardPanel",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIRank", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.2832619 0.5943396 0 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-124.537 -67.045", OffsetMax = "-89.917 -47.555" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "STScoreTitleName",
                Parent = "ScoreBoardPanel",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIName", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.9150943 0.8035371 0 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-89.916 -67.046", OffsetMax = "89.914 -47.555" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "STScoreTitleXP",
                Parent = "ScoreBoardPanel",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UITotalXP", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "0 0.8679245 0.8500054 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "89.913 -67.046", OffsetMax = "223.173 -47.555" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "STScoreScrollPanel",
                Parent = "ScoreBoardPanel",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-124.537 -267.05", OffsetMax = "223.173 -67.05" }
                }
            });

            if (ScoreBoard.orderedList.Count > 10)
            {
                container.Add(new CuiElement
                {
                    Name = "STScoreSB",
                    Parent = "STScoreScrollPanel",
                    Components = {
                        new CuiScrollViewComponent {
                            MovementType = UnityEngine.UI.ScrollRect.MovementType.Clamped,
                            Vertical = true,
                            Inertia = true,
                            Horizontal = false,
                            Elasticity = 0.25f,
                            DecelerationRate = 0.3f,
                            ScrollSensitivity = 24f,
                            ContentTransform = new CuiRectTransform { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 " + (((20 * ScoreBoard.orderedList.Count) + 5) * -1), OffsetMax = "0 0" },
                            VerticalScrollbar = new CuiScrollbar() { Size = 1f, AutoHide = true }, // Remove this to remove the scroll bar and just have it scrollable with mwheel
                        }
                    }
                });
            }

            var count = 0;
            foreach (var score in ScoreBoard.orderedList)
            {
                container.Add(new CuiElement
                {
                    Name = "STScoreElement",
                    Parent = ScoreBoard.orderedList.Count > 10 ? "STScoreSB" : "STScoreScrollPanel",
                    Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0 0 0 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-173.848 {-20 - (count * 20)}", OffsetMax = $"173.852 {0 - (count * 20)}" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "ScoreRank",
                    Parent = "STScoreElement",
                    Components = {
                    new CuiTextComponent { Text = $"{count + 1}:", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = "0.282353 0.5960785 0 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-173.857 -20", OffsetMax = "-139.237 0" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "ScoreName",
                    Parent = "STScoreElement",
                    Components = {
                    new CuiTextComponent { Text = score.Value.name, Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperCenter, Color = "0.9137255 0.8039216 0 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-139.236 -20", OffsetMax = "40.595 0" }
                }
                });

                if (score.Value.pres_skin > 0)
                {
                    container.Add(new CuiElement
                    {
                        Name = "PrestigeRank",
                        Parent = "STScoreElement",
                        Components = {
                        new CuiImageComponent { Color = "1 1 1 1", ItemId = -697981032, SkinId = score.Value.pres_skin },
                        new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "40.738 -17", OffsetMax = "54.738 -3" }
                    }
                    });
                }

                container.Add(new CuiElement
                {
                    Name = "ScoreXP",
                    Parent = "STScoreElement",
                    Components = {
                    new CuiTextComponent { Text = config.misc_settings.scoreBoardSettings.xpRounding > 0 ? Math.Round(score.Value.xp, 2).ToString() : Convert.ToInt32(score.Value.xp).ToString(), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = "0 0.8666667 0.8509804 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"{40.594 + (score.Value.pres_skin > 0 ? 14 : 0)} -20", OffsetMax = $"{173.852 + (score.Value.pres_skin > 0 ? 14 : 0)} 0" }
                }
                });

                count++;
            }

            container.Add(new CuiElement
            {
                Name = "ScoreboardCloseLabel",
                Parent = "ScoreBoardPanel",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIClose", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-26 -303.9", OffsetMax = "26 -279.9" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = "closescoreboard" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-26 -12.001", OffsetMax = "26 12.001" }
            }, "ScoreboardCloseLabel", "ScoreboardCloseButton");

            CuiHelper.DestroyUi(player, "ScoreBoardPanel");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("closescoreboard")]
        void CloseScoreBoard(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, "ScoreboardBackPanel");
            CuiHelper.DestroyUi(player, "ScoreBoardPanel");
        }

        #endregion

        #region Ultimates

        #region Ultimate settings

        string GetUltimateSettingsDescription(BasePlayer player, Buff buff)
        {
            switch (buff)
            {
                case Buff.Woodcutting_Ultimate: return string.Format(lang.GetMessage("UltimateSettingsUIDescription", this), lang.GetMessage(buff.ToString().Split('_')[0], this, player.UserIDString));
                case Buff.Mining_Ultimate: return string.Format(lang.GetMessage("UltimateSettingsUIDescription", this), lang.GetMessage(buff.ToString().Split('_')[0], this, player.UserIDString));
                case Buff.Combat_Ultimate: return string.Format(lang.GetMessage("UltimateSettingsUIDescription", this), lang.GetMessage(buff.ToString().Split('_')[0], this, player.UserIDString));
                case Buff.Vehicle_Ultimate: return string.Format(lang.GetMessage("UltimateSettingsUIDescription", this), lang.GetMessage(buff.ToString().Split('_')[0], this, player.UserIDString));
                case Buff.Harvester_Ultimate: return string.Format(lang.GetMessage("UltimateSettingsUIDescription", this), lang.GetMessage(buff.ToString().Split('_')[0], this, player.UserIDString));
                case Buff.Medical_Ultimate: return string.Format(lang.GetMessage("UltimateSettingsUIDescription", this), lang.GetMessage(buff.ToString().Split('_')[0], this, player.UserIDString));
                case Buff.Skinning_Ultimate: return string.Format(lang.GetMessage("UltimateSettingsUIDescription", this), lang.GetMessage(buff.ToString().Split('_')[0], this, player.UserIDString));
                case Buff.Build_Craft_Ultimate: return string.Format(lang.GetMessage("UltimateSettingsUIDescription", this), lang.GetMessage("Build_Craft_formatted", this));
                case Buff.Scavengers_Ultimate: return string.Format(lang.GetMessage("UltimateSettingsUIDescription", this), lang.GetMessage(buff.ToString().Split('_')[0], this, player.UserIDString));
                case Buff.Raiding_Ultimate: return string.Format(lang.GetMessage("UltimateSettingsUIDescription", this), lang.GetMessage(buff.ToString().Split('_')[0], this, player.UserIDString));
                case Buff.Cooking_Ultimate: return string.Format(lang.GetMessage("UltimateSettingsUIDescription", this), lang.GetMessage(buff.ToString().Split('_')[0], this, player.UserIDString));
                default: return "Custom Ultimate";
            }
        }

        private void SkillTree_UltimateMenu(BasePlayer player)
        {
            PlayerInfo pi;
            if (!pcdData.pEntity.TryGetValue(player.userID, out pi)) return;

            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0 0 0 0.9803922" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0.024 -0.331", OffsetMax = "0.325 0.339" }
            }, "Overlay", "SkillTree_UltimateMenu");

            container.Add(new CuiElement
            {
                Name = "SkillTreeUltimateMenu_Title",
                Parent = "SkillTree_UltimateMenu",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UltimateSettingsButton", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 26, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-495.24 190.4", OffsetMax = "-180.18 250.4" }
                }
            });

            var count = 0;
            var row = 0;
            if (pi.ultimate_settings.Count == 0)
            {
                container.Add(new CuiElement
                {
                    Name = "no_ultimates_unlocked",
                    Parent = "SkillTree_UltimateMenu",
                    Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UINoUltimatesUnlocked", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 0.9397521 0 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-495.24 158.268", OffsetMax = "-180.18 190.4" }
                }
                });
            }
            else foreach (var option in pi.ultimate_settings)
                {
                    container.Add(new CuiPanel
                    {
                        CursorEnabled = false,
                        Image = { Color = "0.1132075 0.1073335 0.1073335 1" },
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-495.24 + (325.06 * row)} {132.4 - (68 * count)}", OffsetMax = $"{-180.18 + (325.06 * row)} {190.4 - (68 * count)}" }
                    }, "SkillTree_UltimateMenu", "SkillTree_UltimateMenu_tgl_pnl_bk_1");

                    container.Add(new CuiPanel
                    {
                        CursorEnabled = false,
                        Image = { Color = "0.2264151 0.2264151 0.2264151 0.9607843" },
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-155.53 -27", OffsetMax = "155.53 27" }
                    }, "SkillTree_UltimateMenu_tgl_pnl_bk_1", "SkillTree_UltimateMenu_tgl_pnl_ft_1");

                    container.Add(new CuiElement
                    {
                        Name = "SkillTree_UltimateMenu_tgl_des_1",
                        Parent = "SkillTree_UltimateMenu_tgl_pnl_bk_1",
                        Components = {
                        new CuiTextComponent { Text = GetUltimateSettingsDescription(player, option.Key), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                        new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-147 -26", OffsetMax = "52.24 26" }
                    }
                    });

                    container.Add(new CuiPanel
                    {
                        CursorEnabled = false,
                        Image = { Color = "0.1132075 0.1073335 0.1073335 1" },
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "66.53 -24", OffsetMax = "152.53 24" }
                    }, "SkillTree_UltimateMenu_tgl_pnl_bk_1", "SkillTree_UltimateMenu_tgl_bttn_pnl_1");

                    container.Add(new CuiButton
                    {
                        Button = { Color = "0.1607843 0.1607843 0.1607843 1", Command = $"sttoggleultimate {option.Key}" },
                        Text = { Text = option.Value.enabled ? lang.GetMessage("ON", this, player.UserIDString) : lang.GetMessage("OFF", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = option.Value.enabled ? "0.1333333 0.5960785 0.1872104 1" : "0.5943396 0.131764 0.1842591 1" },
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "68.53 -22", OffsetMax = "150.53 22" }
                    }, "SkillTree_UltimateMenu_tgl_pnl_bk_1", "SkillTree_UltimateMenu_tgl_bttn_1");

                    count++;
                    if (count >= 5)
                    {
                        row++;
                        count = 0;
                    }
                }

            container.Add(new CuiElement
            {
                Name = "SkillTree_UltimateMenu_close",
                Parent = "SkillTree_UltimateMenu",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIClose", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-366.71 -201.1", OffsetMax = "-308.71 -169.1" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = $"stcloseultimatesettings" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-29 -16", OffsetMax = "29 16" }
            }, "SkillTree_UltimateMenu_close", "SkillTree_UltimateMenu_close_button");



            CuiHelper.DestroyUi(player, "SkillTree_UltimateMenu");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("stcloseultimatesettings")]
        void CloseUltimateSettings(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, "SkillTree_UltimateMenu");
        }

        [ConsoleCommand("sttoggleultimate")]
        void ToggleUltimate(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            PlayerInfo pi;
            if (!pcdData.pEntity.TryGetValue(player.userID, out pi)) return;
            Buff buff;
            if (!Enum.TryParse(arg.Args[0], out buff)) return;

            UltimatePlayerSettings ultimateData;
            if (!pi.ultimate_settings.TryGetValue(buff, out ultimateData)) pi.ultimate_settings.Add(buff, ultimateData = new UltimatePlayerSettings());
            if (ultimateData.enabled) ultimateData.enabled = false;
            else ultimateData.enabled = true;

            HandleUltimateToggle(player, buff, pi);

            SkillTree_UltimateMenu(player);
        }

        bool IsUltimateEnabled(BasePlayer player, Buff buff)
        {
            PlayerInfo playerData;
            UltimatePlayerSettings buffSettings;
            return pcdData.pEntity.TryGetValue(player.userID, out playerData) && playerData.ultimate_settings.TryGetValue(buff, out buffSettings) && buffSettings.enabled;
        }

        void HandleUltimateToggle(BasePlayer player, Buff buff, PlayerInfo pi)
        {
            // Add handles here.

            UltimatePlayerSettings ups;
            if (!pi.ultimate_settings.TryGetValue(buff, out ups)) pi.ultimate_settings.Add(buff, ups = new UltimatePlayerSettings());
            if (!ups.enabled) Player.Message(player, string.Format(lang.GetMessage("UltimateDisabledMessage", this, player.UserIDString), lang.GetMessage("UI" + buff.ToString(), this, player.UserIDString)), config.misc_settings.ChatID);

            if (buff == Buff.Mining_Ultimate)
            {
                if (ups.enabled)
                {
                    Player.Message(player, string.Format(lang.GetMessage("UltimateToggleOnMining", this, player.UserIDString), config.ultimate_settings.ultimate_mining.distance_from_player, config.ultimate_settings.ultimate_mining.find_node_cmd, config.ultimate_settings.ultimate_mining.cooldown), config.misc_settings.ChatID);
                }
            }
            if (buff == Buff.Vehicle_Ultimate && GetBuffDetails(player.userID, out var buffData) && buffData.GetBuff(buff, out var value))
            {
                if (ups.enabled)
                {
                    Player.Message(player, string.Format(lang.GetMessage("UltimateToggleOnVehicle", this, player.UserIDString), value * 100), config.misc_settings.ChatID);
                }
            }
            if (buff == Buff.Medical_Ultimate)
            {
                if (ups.enabled)
                {
                    Player.Message(player, string.Format(lang.GetMessage("UltimateToggleOnMedical", this, player.UserIDString), config.ultimate_settings.ultimate_medical.resurrection_chance), config.misc_settings.ChatID);
                }
                else CuiHelper.DestroyUi(player, "SkillTree_MedicalUltimate_ResurrectionButton");
            }
            if (buff == Buff.Harvester_Ultimate)
            {
                if (ups.enabled)
                {
                    Player.Message(player, string.Format(lang.GetMessage("UltimateToggleOnHarvester", this, player.UserIDString), config.ultimate_settings.ultimate_harvesting.gene_chat_command, config.ultimate_settings.ultimate_harvesting.cooldown), config.misc_settings.ChatID);
                }
            }

            if (buff == Buff.Build_Craft_Ultimate)
            {
                if (ups.enabled)
                {
                    Player.Message(player, string.Format(lang.GetMessage("UltimateToggleOnBuildCraft", this, player.UserIDString), config.ultimate_settings.ultimate_buildCraft.success_chance), config.misc_settings.ChatID);
                }
            }

            if (buff == Buff.Woodcutting_Ultimate)
            {
                if (ups.enabled)
                {
                    Player.Message(player, string.Format(lang.GetMessage("UltimateToggleOnWoodcutting", this, player.UserIDString), config.ultimate_settings.ultimate_woodcutting.distance_from_player), config.misc_settings.ChatID);
                }
            }

            if (buff == Buff.Scavengers_Ultimate)
            {
                if (ups.enabled)
                {
                    Player.Message(player, lang.GetMessage("UltimateToggleOnScavengers", this, player.UserIDString), config.misc_settings.ChatID);
                }
            }

            if (buff == Buff.Combat_Ultimate)
            {
                if (ups.enabled)
                {
                    string formattedString = "";
                    var active = 0;
                    if (config.ultimate_settings.ultimate_combat.scientists_enabled) active++;
                    if (config.ultimate_settings.ultimate_combat.players_enabled) active++;
                    if (config.ultimate_settings.ultimate_combat.scientists_enabled) active++;

                    if (config.ultimate_settings.ultimate_combat.scientists_enabled)
                    {
                        formattedString += lang.GetMessage("CombatUltimateScientists", this, player.UserIDString);
                        if (active == 2) formattedString += lang.GetMessage("CombatUltimateAnd", this, player.UserIDString);
                        if (active == 3) formattedString += ", ";
                    }
                    if (config.ultimate_settings.ultimate_combat.animals_enabled)
                    {
                        formattedString += lang.GetMessage("CombatUltimateAnimals", this, player.UserIDString);
                        if (active == 3) formattedString += lang.GetMessage("CombatUltimateAnd", this, player.UserIDString);
                    }
                    if (config.ultimate_settings.ultimate_combat.players_enabled) formattedString += lang.GetMessage("CombatUltimatePlayers", this, player.UserIDString);
                    Player.Message(player, string.Format(lang.GetMessage("CombatUltimateToggleOnMessage", this, player.UserIDString), config.ultimate_settings.ultimate_combat.health_scale * 100, formattedString), config.misc_settings.ChatID);
                    //Player.Message(player, $"You will now receive <color=#DFF008>{config.ultimate_settings.ultimate_combat.health_scale * 100}%</color> of the damage as health when damaging {formattedString}.", config.misc_settings.ChatID);
                }
            }
            if (buff == Buff.Skinning_Ultimate)
            {
                if (ups.enabled)
                {
                    Player.Message(player, string.Format(lang.GetMessage("SkinningUltimateToggleText", this, player.UserIDString), string.Join("</color>, <color=#DFF008>", config.ultimate_settings.ultimate_skinning.enabled_buffs.Select(x => lang.GetMessage(x.Key.ToString().ToLower(), this, player.UserIDString)))), config.misc_settings.ChatID);
                }
                else
                {
                    RemoveAnimalBuff(player);
                }
            }

            if (buff == Buff.Raiding_Ultimate)
            {
                if (ups.enabled)
                    Player.Message(player, string.Format(lang.GetMessage("UltimateToggleOnRaiding", this, player.UserIDString), config.ultimate_settings.ultimate_raiding.command, config.ultimate_settings.ultimate_raiding.cooldown), config.misc_settings.ChatID);
                else DestroyRaidBehaviour(player);
            }

            if (buff == Buff.Cooking_Ultimate)
            {
                if (ups.enabled)
                    Player.Message(player, string.Format(lang.GetMessage("UltimateToggleOnCooking", this, player.UserIDString), config.ultimate_settings.ultimate_cooking.command, config.ultimate_settings.ultimate_cooking.buff_cooldown), config.misc_settings.ChatID);
                else RemoveCookingUltimateBuffs(player);
            }
        }

        #endregion

        #region Mining ultimate

        Dictionary<ulong, float> MiningUltimateCooldowns = new Dictionary<ulong, float>();

        void TriggerMiningUltimateFromItem(BasePlayer player) => TriggerMiningUltimateAction(player, false);
        void TriggerMiningUltimateFromCMD(BasePlayer player) => TriggerMiningUltimateAction(player, true);

        void TriggerMiningUltimateAction(BasePlayer player, bool from_command = true)
        {
            if (!player.IsAdmin && !player.IsDeveloper && player.IsFlying)
            {
                Player.Message(player, lang.GetMessage("DisableNoclipCommand", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }
            BuffDetails bd;
            if (GetBuffDetails(player.userID, out bd) && bd.ContainsBuff(Buff.Mining_Ultimate) && IsUltimateEnabled(player, Buff.Mining_Ultimate))
            {
                if (MiningUltimateCooldowns.ContainsKey(player.userID))
                {
                    if (MiningUltimateCooldowns[player.userID] > Time.time)
                    {
                        if (from_command) Player.Message(player, string.Format(lang.GetMessage("MiningUltimateCooldownMessage", this, player.UserIDString), Math.Round(MiningUltimateCooldowns[player.userID] - Time.time, 0)), config.misc_settings.ChatID);
                        return;
                    }
                    else MiningUltimateCooldowns[player.userID] = Time.time + config.ultimate_settings.ultimate_mining.cooldown;
                }
                else MiningUltimateCooldowns.Add(player.userID, Time.time + config.ultimate_settings.ultimate_mining.cooldown);
                List<BaseEntity> mining_nodes = Pool.Get<List<BaseEntity>>();
                var entities = FindEntitiesOfType<BaseEntity>(player.transform.position, config.ultimate_settings.ultimate_mining.distance_from_player);
                mining_nodes.AddRange(entities.Where(x => x.PrefabName.StartsWith("assets/bundled/prefabs/autospawn/resource/ores")));
                Pool.FreeUnmanaged(ref entities);
                if (mining_nodes.Count > 0)
                {
                    var wasAdmin = player.IsAdmin;
                    if (!wasAdmin)
                    {
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                        player.SendNetworkUpdateImmediate();
                    }

                    string nodeName;
                    foreach (var node in mining_nodes)
                    {
                        nodeName = string.Format("<size={0}>{1}</size>", config.ultimate_settings.ultimate_mining.text_size, (node.ShortPrefabName == "metal-ore" ? lang.GetMessage("metal", this, player.UserIDString) : node.ShortPrefabName == "stone-ore" ? lang.GetMessage("stone", this, player.UserIDString) : lang.GetMessage("sulfur", this, player.UserIDString)) + (config.ultimate_settings.ultimate_mining.show_distance ? $" - Distance: {Mathf.Round(Vector3.Distance(player.transform.position, node.transform.position))}" : null));
                        player.SendConsoleCommand("ddraw.text", config.ultimate_settings.ultimate_mining.hud_time, GetNodeColor(node), node.transform.position, nodeName);
                    }

                    if (!wasAdmin)
                    {
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                        player.SendNetworkUpdateImmediate();
                    }
                }
                Pool.FreeUnmanaged(ref mining_nodes);
            }
        }

        Color GetNodeColor(BaseEntity entity)
        {
            if (entity == null) return Color.yellow;
            switch (entity.ShortPrefabName)
            {
                case "stone-ore": return GetColor(config.ultimate_settings.ultimate_mining.stone_colour);
                case "metal-ore": return GetColor(config.ultimate_settings.ultimate_mining.metal_colour);
                case "sulur-ore": return GetColor(config.ultimate_settings.ultimate_mining.sulfur_colour);
                default: return Color.yellow;
            }
        }

        Color GetColor(int type)
        {
            switch (type)
            {
                case 0: return Color.red;
                case 1: return Color.green;
                case 2: return Color.blue;
                case 3: return Color.white;
                case 4: return Color.black;
                case 5: return Color.yellow;
                case 6: return Color.cyan;
                case 7: return Color.magenta;
                default: return Color.yellow;
            }
        }

        #endregion

        #region Resurrection button

        private void SendResurrectionButton(BasePlayer player, Vector3 pos)
        {
            if (Resurrection_Cooldowns.ContainsKey(player.userID) && Resurrection_Cooldowns[player.userID] > Time.time) return;

            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1320755 0.1314525 0.1314525 1" },
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-104.9 86.718", OffsetMax = "-4.9 110.718" }
            }, "Overlay", "SkillTree_MedicalUltimate_ResurrectionButton");

            container.Add(new CuiButton
            {
                Button = { Color = "0.2352941 0.2705882 0.1607843 1", Command = $"stattemptresurrection {pos.x} {pos.y} {pos.z}" },
                Text = { Text = lang.GetMessage("UIResurrect", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.5803922 0.7294118 0.2588235 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-48 -10", OffsetMax = "48 10" }
            }, "SkillTree_MedicalUltimate_ResurrectionButton", "Button_2968");

            CuiHelper.DestroyUi(player, "SkillTree_MedicalUltimate_ResurrectionButton");
            CuiHelper.AddUi(player, container);
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            if (player == null) return;
            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd)) return;
            float buffValue;
            if (bd.ContainsBuff(Buff.Medical_Ultimate)) CuiHelper.DestroyUi(player, "SkillTree_MedicalUltimate_ResurrectionButton");
            if (bd.GetBuff(Buff.Spawn_Health, out buffValue))
            {
                Subscription subData;
                bool isSubbed = subscriptions.TryGetValue(nameof(OnPlayerHealthChange), out subData) && subData.isSubscribed;
                if (isSubbed) Unsubscribe(nameof(OnPlayerHealthChange));
                player.SetHealth(buffValue * 100);
                if (isSubbed) Subscribe(nameof(OnPlayerHealthChange));
            }
        }

        Dictionary<ulong, float> Resurrection_Cooldowns = new Dictionary<ulong, float>();
        List<ulong> SpamProtection = new List<ulong>();

        [ConsoleCommand("stattemptresurrection")]
        void AttemptResurrection(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, "SkillTree_MedicalUltimate_ResurrectionButton");
            if (SpamProtection.Contains(player.userID)) return;
            SpamProtection.Add(player.userID);
            ulong id = player.userID;
            ServerMgr.Instance.Invoke(() => SpamProtection.Remove(id), 0.1f);

            if (player.IsAlive() || !player.IsConnected) return;

            if (UnityEngine.Random.Range(0f, 100f) <= config.ultimate_settings.ultimate_medical.resurrection_chance)
            {
                var pos = new Vector3(Convert.ToSingle(arg.Args[0]), Convert.ToSingle(arg.Args[1]), Convert.ToSingle(arg.Args[2]));
                player.RespawnAt(pos, Quaternion.identity);
                if (Resurrection_Cooldowns.ContainsKey(player.userID)) Resurrection_Cooldowns[player.userID] = Time.time + config.ultimate_settings.ultimate_medical.resurrection_delay;
                else Resurrection_Cooldowns.Add(player.userID, Time.time + config.ultimate_settings.ultimate_medical.resurrection_delay);
            }
            else
            {
                SendResurrectionFailed(player);
                ServerMgr.Instance.Invoke(() =>
                {
                    if (player != null)
                        CuiHelper.DestroyUi(player, "SkillTree_MedicalUltimate_Failed");
                }, 3);
            }
        }

        private void SendResurrectionFailed(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "SkillTree_MedicalUltimate_Failed",
                Parent = "Overlay",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIFailed", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "1 0 0 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-104.57 66.393", OffsetMax = "-4.57 90.387" }
                }
            });

            CuiHelper.DestroyUi(player, "SkillTree_MedicalUltimate_Failed");
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Harvester Ultimate

        bool FoundInvalidGeneLetter(string genes)
        {
            foreach (var c in genes.ToCharArray())
            {
                if (c != 'g' && c != 'e' && c != 'x' && c != 'w' && c != 'y' && c != 'h') return true;
            }
            return false;
        }

        void SetPlantGenes(BasePlayer player, string command, string[] args)
        {
            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd) || !bd.ContainsBuff(Buff.Harvester_Ultimate))
            {
                Player.Message(player, lang.GetMessage("RequireHarvestingUltimateMsg", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }
            Plant_Gene_Select_background(player);
            Plant_Gene_Select(player);
        }

        private void Plant_Gene_Select(BasePlayer player)
        {
            PlayerInfo pi;
            if (!pcdData.pEntity.TryGetValue(player.userID, out pi)) return;

            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0 0 0 0.9490196" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-0.675 0.01", OffsetMax = "0.325 0" }
            }, "Overlay", "Plant_Gene_Select");

            container.Add(new CuiElement
            {
                Name = "title",
                Parent = "Plant_Gene_Select",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIGeneHeading", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 20, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-128 160.3", OffsetMax = "128 192.3" }
                }
            });

            var gene_array = pi.plant_genes.ToCharArray();
            char[] gene_chars = { 'g', 'x', 'w', 'y', 'h' };
            for (int i = 0; i < 6; i++)
            {
                for (int j = 0; j < 5; j++)
                {
                    string buttonCol = "0.2924528 0.2924528 0.2924528 1";
                    if (gene_array[i] == gene_chars[j]) buttonCol = "0.003070482 0.2169811 0.02914789 1";
                    container.Add(new CuiPanel
                    {
                        CursorEnabled = false,
                        Image = { Color = "0.1698113 0.1698113 0.1698113 0.8" },
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-90 + (37 * j)} {120.2 - (37 * i)}", OffsetMax = $"{-58 + (37 * j)} {152.2 - (37 * i)}" }
                    }, "Plant_Gene_Select", "gene_button_panel");

                    container.Add(new CuiButton
                    {
                        Button = { Color = buttonCol, Command = $"setgenevalue {i} {gene_chars[j]}" },
                        Text = { Text = gene_chars[j].ToString().ToUpper(), Font = "robotocondensed-bold.ttf", FontSize = 20, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-14 -14", OffsetMax = "14 14" }
                    }, "gene_button_panel", "gene_button");
                }
            }

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = "closegenstructuremenu" },
                Text = { Text = "X", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "128 160.3", OffsetMax = "160 192.3" }
            }, "Plant_Gene_Select", "close");

            CuiHelper.DestroyUi(player, "Plant_Gene_Select");
            CuiHelper.AddUi(player, container);
        }

        private void Plant_Gene_Select_background(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0 0 0 0.9490196" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, "Overlay", "Plant_Gene_Select_background");

            CuiHelper.DestroyUi(player, "Plant_Gene_Select_background");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("closegenstructuremenu")]
        void CloseGeneMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, "Plant_Gene_Select");
            CuiHelper.DestroyUi(player, "Plant_Gene_Select_background");
        }

        [ConsoleCommand("setgenevalue")]
        void ChangeChar(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, "Plant_Gene_Select");

            var pos = Convert.ToInt32(arg.Args[0]);
            var c = Convert.ToChar(arg.Args[1]);

            PlayerInfo pi;
            if (pcdData.pEntity.TryGetValue(player.userID, out pi))
            {
                string newGene = "";
                for (int i = 0; i < 6; i++)
                {
                    if (i == pos) newGene += c;
                    else newGene += pi.plant_genes[i];
                }
                pi.plant_genes = newGene.ToString();
            }
            Plant_Gene_Select(player);
        }

        #endregion

        #region Scavengers Ultimate



        private void Card(BasePlayer player, int cardLevel, ulong cardReaderID)
        {
            if (Interface.CallHook("OnGainXPFromSwipeCard", player, cardLevel, cardReaderID) != null) return;
            if (config.xp_settings.swipe_card_xp_cooldown > 0)
            {
                if (!LastSwipe.ContainsKey(player)) LastSwipe.Add(player, Time.time + config.xp_settings.swipe_card_xp_cooldown);
                else if (LastSwipe[player] <= Time.time) LastSwipe[player] = Time.time + config.xp_settings.swipe_card_xp_cooldown;
                else
                {
                    if (NotificationsOn(player)) Player.Message(player, string.Format(lang.GetMessage("CardSwipeCooldownMessage", this, player.UserIDString), Math.Round(LastSwipe[player] - Time.time, 2)), config.misc_settings.ChatID);
                    return;
                }
            }
            switch (cardLevel)
            {
                case 1:
                    AwardXP(player, config.xp_settings.xp_sources.swipe_card_level_1, null, false, false, nameof(config.xp_settings.xp_sources.swipe_card_level_1));
                    break;
                case 2:
                    AwardXP(player, config.xp_settings.xp_sources.swipe_card_level_2, null, false, false, nameof(config.xp_settings.xp_sources.swipe_card_level_2));
                    break;
                case 3:
                    AwardXP(player, config.xp_settings.xp_sources.swipe_card_level_3, null, false, false, nameof(config.xp_settings.xp_sources.swipe_card_level_3));
                    break;
            }
        }

        Dictionary<BasePlayer, float> LastSwipe = new Dictionary<BasePlayer, float>();

        private object OnCardSwipe(CardReader cardReader, Keycard card, BasePlayer player)
        {
            Item item = card.GetItem();
            if (item == null || item.isBroken || cardReader == null || player == null) return null;

            BuffDetails bd;
            if (card.accessLevel != cardReader.accessLevel && GetBuffDetails(player.userID, out bd) && bd.ContainsBuff(Buff.Build_Craft_Ultimate) && IsUltimateEnabled(player, Buff.Build_Craft_Ultimate))
            {
                var roll = UnityEngine.Random.Range(1, maxRoll + 1);
                if (config.ultimate_settings.ultimate_buildCraft.success_chance < maxRoll && maxRoll - config.ultimate_settings.ultimate_buildCraft.success_chance < roll)
                {
                    if (config.ultimate_settings.ultimate_buildCraft.notify_fail)
                        Player.Message(player, lang.GetMessage("BuildCraftFailNotify", this, player.UserIDString), config.misc_settings.ChatID);
                    item.LoseCondition(1f);
                    Card(player, card.accessLevel, cardReader.net.ID.Value);
                    return null;
                }

                if (Interface.CallHook("OnSwipeAccessLevelBypass", player, cardReader, card) != null) return null;

                item.LoseCondition(1f);
                Card(player, card.accessLevel, cardReader.net.ID.Value);

                cardReader.Invoke(new Action(cardReader.GrantCard), 0.5f);
                return true;
            }

            if (card.accessLevel == cardReader.accessLevel)
            {
                var condition = item.condition;
                var accessLevel = card.accessLevel;
                var cardReaderID = cardReader.net.ID.Value;
                NextTick(() =>
                {
                    if (item == null || item.condition != condition)
                        Card(player, accessLevel, cardReaderID);
                });
            }

            return null;
        }


        #endregion

        #region Build_Craft Ultimate

        void ScrapItems(Item item, LootContainer container)
        {
            if ((!config.ultimate_settings.ultimate_scavenger.scrap_skinned_items && item.skin > 0) || (!config.ultimate_settings.ultimate_scavenger.scrap_named_items && !string.IsNullOrEmpty(item.name)) || config.ultimate_settings.ultimate_scavenger.item_blacklist.Contains(item.info.shortname) || (!config.ultimate_settings.ultimate_scavenger.scrap_text_items && !string.IsNullOrEmpty(item.text))) return;
            var blueprint = item.info.Blueprint;
            if (blueprint == null) return;
            item.RemoveFromContainer();
            foreach (var ingredient in blueprint.ingredients)
            {
                int amount;
                if (ingredient.itemDef.shortname == "scrap") amount = blueprint.scrapFromRecycle;
                else amount = UnityEngine.Random.Range(0, 101) <= 50 ? Mathf.CeilToInt(ingredient.amount / 2) : Mathf.FloorToInt(ingredient.amount / 2);
                if (amount == 0) continue;
                var component = ItemManager.CreateByName(ingredient.itemDef.shortname, amount * item.amount);
                container.inventory.capacity++;
                if (!component.MoveToContainer(container.inventory)) component.DropAndTossUpwards(container.transform.position);
            }
        }


        #endregion

        #region Skinning Ultimate

        public enum AnimalBuff
        {
            Chicken, //No fall damage
            Wolf, // Healing increased for each member around you
            Boar, // Access to special loot table for certain items.
            Stag, // Every x seconds the player will get a hud message if a hostile is nearby.
            Bear, // If you attack an NPC, the NPC may not attack you back for a short period of time.
            PolarBear // Overshield
        }

        public class SkinningUltimateBuff
        {
            public AnimalBuff buff;
            public Timer _timer;
            public SkinningUltimateBuff(AnimalBuff buff)
            {
                this.buff = buff;
            }

            public void DestroyTimer()
            {
                if (_timer != null && !_timer.Destroyed) _timer.Destroy();
            }
        }

        public Dictionary<BasePlayer, SkinningUltimateBuff> BuffedPlayers = new Dictionary<BasePlayer, SkinningUltimateBuff>();
        Dictionary<BasePlayer, float> OverShields = new Dictionary<BasePlayer, float>();

        void AddAnimalBuff(BasePlayer player, AnimalBuff animal)
        {
            if (!IsUltimateEnabled(player, Buff.Skinning_Ultimate)) return;
            BuffDetails bd;
            if (GetBuffDetails(player.userID, out bd))
            {
                if (bd.ContainsBuff(Buff.Skinning_Ultimate) && IsUltimateEnabled(player, Buff.Skinning_Ultimate))
                {
                    if (!config.ultimate_settings.ultimate_skinning.enabled_buffs.ContainsKey(animal) || config.ultimate_settings.ultimate_skinning.enabled_buffs[animal] == 0) return;
                    Player.Message(player, GetAnimalBuffDescription(animal, player.UserIDString), config.misc_settings.ChatID);


                    if (BuffedPlayers.ContainsKey(player)) RemoveAnimalBuff(player);
                    SkinningUltimateBuff sub;
                    BuffedPlayers.Add(player, sub = new SkinningUltimateBuff(animal));

                    sub.DestroyTimer();

                    if (animal == AnimalBuff.Bear)
                    {
                        Subscribe("OnNpcTarget");
                        if (!CanNpcAttack_subbed.Contains(player)) CanNpcAttack_subbed.Add(player);
                    }
                    else if (animal == AnimalBuff.PolarBear)
                    {
                        if (!OverShields.ContainsKey(player)) OverShields.Add(player, config.ultimate_settings.ultimate_skinning.bear_overshield_max);
                        else OverShields[player] = config.ultimate_settings.ultimate_skinning.bear_overshield_max;
                        Overshield_main(player, config.ultimate_settings.ultimate_skinning.bear_overshield_max);
                    }
                    else if (animal == AnimalBuff.Stag)
                    {
                        Timer _t;
                        if (StagDangerTimers.TryGetValue(player, out _t))
                        {
                            if (_t != null && !_t.Destroyed) _t.Destroy();
                            StagDangerTimers.Remove(player);
                        }
                        StagDangerTimers.Add(player, timer.Every(config.ultimate_settings.ultimate_skinning.stag_timer, () =>
                        {
                            ProcessStagTimer(player);
                        }));
                    }
                    sub._timer = timer.Once(config.ultimate_settings.ultimate_skinning.enabled_buffs[animal], () =>
                    {
                        RemoveAnimalBuff(player, true);
                    });
                }
            }
        }

        string GetAnimalBuffDescription(AnimalBuff animal, string userid)
        {
            switch (animal)
            {
                case AnimalBuff.Chicken: return lang.GetMessage("AnimalBuffDescription_Chicken", this, userid);
                case AnimalBuff.Bear: return lang.GetMessage("AnimalBuffDescription_Bear", this, userid);
                case AnimalBuff.Wolf: return lang.GetMessage("AnimalBuffDescription_Wolf", this, userid);
                case AnimalBuff.Boar: return lang.GetMessage("AnimalBuffDescription_Boar", this, userid);
                case AnimalBuff.Stag: return lang.GetMessage("AnimalBuffDescription_Stag", this, userid);
                case AnimalBuff.PolarBear: return lang.GetMessage("AnimalBuffDescription_PolarBear", this, userid);
                default: return null;
            }
        }

        void RemoveAnimalBuff(BasePlayer player, bool timed_out = false)
        {
            SkinningUltimateBuff _buffs;
            if (BuffedPlayers.TryGetValue(player, out _buffs))
            {
                var buff = _buffs.buff;
                if (buff == AnimalBuff.PolarBear)
                {
                    OverShields.Remove(player);
                    CuiHelper.DestroyUi(player, "Overshield_main");
                }
                else if (buff == AnimalBuff.Bear)
                {
                    CanNpcAttack_subbed.Remove(player);
                    if (CanNpcAttack_subbed.Count == 0)
                    {
                        Unsubscribe("OnNpcTarget");
                    }
                }
                else if (buff == AnimalBuff.Stag)
                {
                    Timer _t;
                    if (StagDangerTimers.TryGetValue(player, out _t))
                    {
                        if (_t != null && !_t.Destroyed) _t.Destroy();
                        StagDangerTimers.Remove(player);
                    }
                    CuiHelper.DestroyUi(player, "StagDangerUI");
                }

                _buffs.DestroyTimer();
                BuffedPlayers.Remove(player);

                if (timed_out && player != null && player.IsAlive() && player.IsConnected) Player.Message(player, string.Format(lang.GetMessage("AnimalBuffFinishedMsgNew", this, player.UserIDString), buff), config.misc_settings.ChatID);
            }
        }

        Dictionary<BasePlayer, Timer> StagDangerTimers = new Dictionary<BasePlayer, Timer>();

        void ProcessStagTimer(BasePlayer player)
        {
            if (player.InSafeZone()) return;
            List<BasePlayer> neutral_players = Pool.Get<List<BasePlayer>>();
            var entities = FindEntitiesOfType<BasePlayer>(player.transform.position, config.ultimate_settings.ultimate_skinning.stag_danger_dist);
            neutral_players.AddRange(entities.Where(x => x != player && !x.InSafeZone() && (x.Team == null || player.Team == null || x.Team.teamID != player.Team.teamID)));
            Pool.FreeUnmanaged(ref entities);
            if (neutral_players.Count > 0)
            {
                StagDangerUI(player);
                if (config.ultimate_settings.ultimate_skinning.stag_draw_enemy)
                {
                    var wasAdmin = player.IsAdmin;
                    if (!wasAdmin)
                    {
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                        player.SendNetworkUpdateImmediate();
                    }

                    foreach (var threat in neutral_players)
                    {
                        if (threat.limitNetworking) continue;
                        player.SendConsoleCommand("ddraw.text", 10f, Color.red, threat.transform.position, lang.GetMessage("DetectionText", this, player.UserIDString));
                    }

                    if (!wasAdmin)
                    {
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                        player.SendNetworkUpdateImmediate();
                    }
                }
            }
            else CuiHelper.DestroyUi(player, "StagDangerUI");
            Pool.FreeUnmanaged(ref neutral_players);
        }

        bool HasAnimalBuff(BasePlayer player, AnimalBuff animal)
        {
            SkinningUltimateBuff sub;
            return BuffedPlayers.TryGetValue(player, out sub) && sub.buff == animal;
        }

        List<BasePlayer> CanNpcAttack_subbed = new List<BasePlayer>();

        object OnNpcTarget(ScientistNPC npc, BasePlayer player)
        {
            if (HasAnimalBuff(player, AnimalBuff.Bear))
            {
                return true;
            }

            return null;
        }

        private void Overshield_main(BasePlayer player, float health)
        {
            if (health <= 0) return;

            var x_value = (100 / config.ultimate_settings.ultimate_skinning.bear_overshield_max) * health;

            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.3490566 0.3441171 0.3441171 0.5019608" },
                RectTransform = { AnchorMin = config.ultimate_settings.ultimate_skinning.overshield_anchor.anchorMin, AnchorMax = config.ultimate_settings.ultimate_skinning.overshield_anchor.anchorMax, OffsetMin = config.ultimate_settings.ultimate_skinning.overshield_anchor.offsetMin, OffsetMax = config.ultimate_settings.ultimate_skinning.overshield_anchor.offsetMax }
            }, "Hud", "Overshield_main");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.05660379 0.05660379 0.05660379 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-50 -8", OffsetMax = "50 8" }
            }, "Overshield_main", "Overshield_empty");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.2901961 0.4711963 0.5411765 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-50 -8", OffsetMax = $"{-50 + x_value} 8" }
            }, "Overshield_main", "Overshield_pump");

            container.Add(new CuiElement
            {
                Name = "Label_4442",
                Parent = "Overshield_main",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIOvershield", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-50 -8", OffsetMax = "50 8" }
                }
            });

            CuiHelper.DestroyUi(player, "Overshield_main");
            CuiHelper.AddUi(player, container);
        }

        private void StagDangerUI(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "StagDangerUI",
                Parent = "Hud",
                Components = {
                    new CuiTextComponent { Text = $"NEUTRAL PLAYER DETECTED NEARBY", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 0 0 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = config.ultimate_settings.ultimate_skinning.stag_danger_icon_anchor.anchorMin, AnchorMax = config.ultimate_settings.ultimate_skinning.stag_danger_icon_anchor.anchorMax, OffsetMin = config.ultimate_settings.ultimate_skinning.stag_danger_icon_anchor.offsetMin, OffsetMax = config.ultimate_settings.ultimate_skinning.stag_danger_icon_anchor.offsetMax }
                    //new CuiRectTransformComponent { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-201.4 87.6", OffsetMax = "-97.4 107.6" }
                }
            });

            CuiHelper.DestroyUi(player, "StagDangerUI");
            CuiHelper.AddUi(player, container);
        }

        void RollBoarLoot(BasePlayer player, CollectibleEntity entity)
        {
            if (!IsUltimateEnabled(player, Buff.Skinning_Ultimate)) return;
            if (UnityEngine.Random.Range(0f, 100f) <= config.ultimate_settings.ultimate_skinning.boar_chance)
            {
                Player.Message(player, string.Format(lang.GetMessage("BoarLootMsg", this, player.UserIDString), (entity.PrefabName.StartsWith("assets/content/nature/plants/mushroom/") ? lang.GetMessage("Mushroom", this, player.UserIDString) : lang.GetMessage("BerryBush", this, player.UserIDString))), config.misc_settings.ChatID);
                List<ItemDefinition> items = Pool.Get<List<ItemDefinition>>();
                items.AddRange(component_item_list.Where(x => !config.ultimate_settings.ultimate_skinning.boar_blackList.Contains(x.shortname)));
                var itemDef = items.GetRandom();

                player.GiveItem(ItemManager.CreateByName(itemDef.shortname, UnityEngine.Random.Range(config.ultimate_settings.ultimate_skinning.boar_min_quantity, config.ultimate_settings.ultimate_skinning.boar_min_quantity)));
            }
        }


        #endregion

        #region Underwater breathing behaviour

        void DestroyWaterBreathing(BasePlayer player)
        {
            BreathTime.Remove(player);
            var gameObject = player.GetComponent<WaterBreathing>();
            if (gameObject != null) UnityEngine.GameObject.Destroy(gameObject);
            CuiHelper.DestroyUi(player, "UnderwaterBreathCounter");
        }

        void UpdateWaterBreathing(BasePlayer player, float value)
        {
            DestroyWaterBreathing(player);
            BreathTime.Add(player, value);
            var gameObject = player.gameObject.AddComponent<WaterBreathing>();
            if (DisabledPlayers.Contains(player.userID)) gameObject.SetBlocked(true);
        }

        void SetWaterBreathingBlock(BasePlayer player, bool shouldBlock)
        {
            if (!buffDetails.TryGetValue(player.userID, out var bd) || !bd.ContainsBuff(Buff.WaterBreathing)) return;

            var gameObject = player.GetComponent<WaterBreathing>();
            if (gameObject == null) return;
            gameObject.SetBlocked(shouldBlock);
        }

        private static Dictionary<BasePlayer, float> BreathTime = new Dictionary<BasePlayer, float>();

        public class WaterBreathing : MonoBehaviour
        {
            private BasePlayer player;

            private float checkDelay;

            private float max_breathing_time;
            private bool IsSwimming;
            private float time_breathing;
            private bool exceeded_breathing_time;
            private bool Blocked;

            // Awake() is part of the Monobehaviour class.
            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                checkDelay = Time.time + 3f;
                max_breathing_time = BreathTime[player];
            }

            public void SetBlocked(bool shouldBlock)
            {
                Blocked = shouldBlock;
            }

            // FixedUpdate() is also part of the monobehaviour class.
            public void FixedUpdate()
            {
                if (player == null) return;

                if (checkDelay > Time.time) return;

                ItemModGiveOxygen.AirSupplyType oxygenSource;
                var beathLeft = player.GetOxygenTime(out oxygenSource);

                checkDelay = Time.time + 2f;
                if (player.IsDead() || Blocked) return;


                if (player.WaterFactor() > 0.85f && (oxygenSource == ItemModGiveOxygen.AirSupplyType.Lungs || beathLeft < 4))
                {
                    if (exceeded_breathing_time) return;
                    if (!IsSwimming)
                    {
                        IsSwimming = true;
                    }
                    else
                    {
                        time_breathing += 2;
                    }

                    player.metabolism.oxygen.SetValue(1f);

                    if (time_breathing > max_breathing_time)
                    {
                        exceeded_breathing_time = true;
                    }
                    UnderwaterBreathCounter(player, Convert.ToInt32(max_breathing_time - time_breathing));


                }
                else
                {
                    IsSwimming = false;
                    time_breathing = 0f;
                    exceeded_breathing_time = false;
                    CuiHelper.DestroyUi(player, "UnderwaterBreathCounter");
                }
            }

            // OnDestroy() built into the monobehaviour class.
            private void OnDestroy()
            {
                enabled = false;
                CancelInvoke();
            }
        }

        static string UWB_Anchor_Min;
        static string UWB_Anchor_Max;
        static string UWB_Offset_Min;
        static string UWB_Offset_Max;

        private static void UnderwaterBreathCounter(BasePlayer player, float value)
        {
            if (value < 0) value = 0;
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1981132 0.1981132 0.1981132 0.8" },
                RectTransform = { AnchorMin = UWB_Anchor_Min, AnchorMax = UWB_Anchor_Max, OffsetMin = UWB_Offset_Min, OffsetMax = UWB_Offset_Max }
            }, "Hud", "UnderwaterBreathCounter");

            container.Add(new CuiElement
            {
                Name = "Image_2618",
                Parent = "UnderwaterBreathCounter",
                Components = {
                    new CuiImageComponent { Color = "1 1 1 1", Sprite = "assets/icons/lungs.png" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-16 -16", OffsetMax = "16 16" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Label_6078",
                Parent = "UnderwaterBreathCounter",
                Components = {
                    new CuiTextComponent { Text = value.ToString(), Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.LowerCenter, Color = "1 0.8178636 0 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-16 -16", OffsetMax = "16 16" }
                }
            });

            CuiHelper.DestroyUi(player, "UnderwaterBreathCounter");
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Raiding Ultimate

        #region Command

        [ConsoleCommand("addelectricaloverride")]
        void AddElectricalOverrideCMD(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, perm_admin)) return;
            if (config.tools_black_white_list_settings.electricalComponentSettings.electrical_loot_override.Count > 0)
            {
                arg.ReplyWith("There is already data in the config for this setting.");
                return;
            }
            config.tools_black_white_list_settings.electricalComponentSettings.electrical_loot_override.Add(new LootItems("electrical.branch", 1, 5));
            SaveConfig();
            arg.ReplyWith("Added electrical override example to the config.");
        }

        [ConsoleCommand("addcomponentoverride")]
        void AddComponentOverrideCMD(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, perm_admin)) return;
            if (config.tools_black_white_list_settings.electricalComponentSettings.component_loot_override.Count > 0)
            {
                arg.ReplyWith("There is already data in the config for this setting.");
                return;
            }
            config.tools_black_white_list_settings.electricalComponentSettings.component_loot_override.Add(new LootItems("metalpipe", 1, 5));
            SaveConfig();
            arg.ReplyWith("Added component override example to the config.");
        }

        [ConsoleCommand("wipestpouches")]
        void WipePouches(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, perm_admin)) return;

            foreach (var p in BasePlayer.activePlayerList)
                p.EndLooting();

            foreach (var kvp in pcdData.pEntity)
                kvp.Value.pouch_items.Clear();

            arg.ReplyWith("Wiped all pouch data.");
        }

        [ConsoleCommand("stremoveplayerdata")]
        void RemovePlayerData(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, perm_admin)) return;

            if (arg.Args == null || arg.Args.Length != 1)
            {
                arg.ReplyWith("Usage: stremoveplayerdata <userid>. PLAYER MUST BE OFFLINE.");
                return;
            }

            var target = BasePlayer.Find(arg.Args[0]);
            if (target != null && target.IsConnected)
            {
                arg.ReplyWith($"You cannot reset {target.displayName}'s data as they are connected to the server.");
                return;
            }

            if (!File.Exists(NewDirectory + $"{arg.Args[0]}.json"))
            {
                arg.ReplyWith($"No data file found for {arg.Args[0]}");
                return;
            }

            File.Delete(NewDirectory + $"{arg.Args[0]}.json");
            arg.ReplyWith($"Deleted data for {arg.Args[0]}");
        }

        [ConsoleCommand("setxp")]
        void SetXPConsoleCMD(ConsoleSystem.Arg arg)
        {
            var user = arg.Player();
            if (user != null && !permission.UserHasPermission(user.UserIDString, perm_admin)) return;

            if (arg.Args.IsNullOrEmpty() || arg.Args.Length < 2)
            {
                arg.ReplyWith("Usage: /setxp <target> <amount>");
                return;
            }

            var player = BasePlayer.Find(arg.Args[0]);
            if (player == null)
            {
                List<BasePlayer> foundPlayers = Pool.Get<List<BasePlayer>>();
                foreach (var p in BasePlayer.activePlayerList)
                {
                    if (p.displayName.Contains(arg.Args[0]))
                    {
                        foundPlayers.Add(p);
                    }
                }

                if (foundPlayers.Count == 0) arg.ReplyWith($"No players found that matched: {arg.Args[0]}");
                else if (foundPlayers.Count > 1) arg.ReplyWith($"Found multiple matches: {string.Join(", ", foundPlayers.Select(x => x.displayName))}");
                else player = foundPlayers[0];

                Pool.FreeUnmanaged(ref foundPlayers);
                if (player == null) return;
            }

            PlayerInfo data;
            if (!pcdData.pEntity.TryGetValue(player.userID, out data))
            {
                arg.ReplyWith($"There is no data stored for {player.displayName}. They must connect to the server before attempting to set xp.");
                return;
            }

            var xp = Convert.ToDouble(arg.Args[1]);
            if (xp <= 0)
            {
                arg.ReplyWith($"{arg.Args[1]} is not a valid value. Must be above 1.");
                return;
            }

            if (xp < data.xp)
            {
                arg.ReplyWith("You cannot set a lower xp value for the player. Reset their data first then run the command again.");
                return;
            }

            data.xp = xp;
            var level = config.level.GetLevel(data.xp);
            data.current_level = level;
            data.achieved_level = level;
            data.available_points = GetPointsPerLevel(player.UserIDString) * level + config.wipe_update_settings.starting_skill_points;

            if (player.IsConnected) UpdateXP(player, data);
            arg.ReplyWith($"Updated the xp for {player.displayName}.\nXP: {data.xp}\nLevel: {data.current_level}\nAvailable points: {data.available_points}");
        }

        // getplayerinfo <Name or ID>
        [ConsoleCommand("getplayerinfo")]
        void GetPlayerInfo(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, perm_admin)) return;

            if (arg.Args.IsNullOrEmpty())
            {
                arg.ReplyWith("Usage: getplayerinfo <Name or ID>");
                return;
            }

            var joinedArgs = string.Join(" ", arg.Args);

            PlayerInfo playerData = null;
            ulong key = 0;
            if (joinedArgs.IsNumeric())
            {
                var id = Convert.ToUInt64(joinedArgs);
                if (!pcdData.pEntity.TryGetValue(id, out playerData))
                {
                    arg.ReplyWith($"Failed to find data that matched: {joinedArgs}");
                    return;
                }
            }
            else
            {
                List<string> foundPlayers = Pool.Get<List<string>>();
                foreach (var kvp in pcdData.pEntity)
                {
                    if (kvp.Value.name.Contains(joinedArgs))
                    {
                        playerData = kvp.Value;
                        key = kvp.Key;
                        foundPlayers.Add(kvp.Value.name);
                    }
                }
                if (foundPlayers.Count > 1)
                {
                    arg.ReplyWith($"Found multiple players that matched: {string.Join(", ", foundPlayers)}");
                    Pool.FreeUnmanaged(ref foundPlayers);
                    return;
                }
                else if (foundPlayers.Count == 0 || playerData == null)
                {
                    arg.ReplyWith($"Failed to find data that matched: {joinedArgs}");
                    Pool.FreeUnmanaged(ref foundPlayers);
                    return;
                }
                Pool.FreeUnmanaged(ref foundPlayers);
            }

            int pointsSpent = 0;
            foreach (var point in playerData.buff_values.Values)
                pointsSpent += point;

            arg.ReplyWith($"Data for {playerData.name} [{key}]\n- XP: {playerData.xp}\n- Current Level: {playerData.current_level}\n- Highest level achieved this wipe: {playerData.achieved_level}\n- Unspent points: {playerData.available_points}\n- Spent points: {pointsSpent}\n- Pouch items count: {playerData.pouch_items?.Count ?? 0}");
        }

        [ConsoleCommand("stresetxpdebt")]
        void ResetXPDebt(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, perm_admin)) return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                arg.ReplyWith(lang.GetMessage("ResetXPDebtUsage", this));
                return;
            }
            var name = String.Join(" ", arg.Args);
            var target = name.IsNumeric() ? FindPlayerByID(name, player ?? null) : FindPlayerByName(name, player ?? null);
            if (target == null)
            {
                if (!File.Exists(NewDirectory + $"{name}.json"))
                {
                    arg.ReplyWith($"Could not find data file for {name}");
                    return;
                }
                var obj = JsonConvert.DeserializeObject<PlayerInfo>(File.ReadAllText(NewDirectory + $"{name}.json"));
                if (obj == null) return;
                obj.xp_debt = 0;
                WriteJson(name, JsonConvert.SerializeObject(obj));
                return;
            }

            PlayerInfo pi;
            if (pcdData.pEntity.TryGetValue(target.userID, out pi))
            {
                pi.xp_debt = 0;
                UpdateXP(target, pi);
            }
            else
            {
                if (!GetOfflinePlayerinfo(target.UserIDString, out pi))
                {
                    arg.ReplyWith($"Could not find data file for {target.userID}");
                    return;
                }
                pi.xp_debt = 0;
                WriteJson(target.UserIDString, JsonConvert.SerializeObject(pi));
                return;
            }

            arg.ReplyWith($"Reset the xp debt for {target.displayName}");
        }

        [ChatCommand("resetmlrs")]
        void ResetMLRS(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, perm_admin)) return;

            PlayerInfo pi;
            if (!pcdData.pEntity.TryGetValue(player.userID, out pi)) return;

            pi.raiding_ultimate_used_time = DateTime.MinValue;

            Player.Message(player, "Your MLRS timer has been reset.", config.misc_settings.ChatID);
        }

        [ConsoleCommand("globalresetmlrs")]
        void GlobalResetMLRS(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, perm_admin)) return;

            foreach (var pi in pcdData.pEntity)
                pi.Value.raiding_ultimate_used_time = DateTime.MinValue;

            arg.ReplyWith($"Reset the MLRS cooldown globally.");
        }

        void CallRocketStrike(BasePlayer player)
        {
            if (config.ultimate_settings.ultimate_raiding.wipe_prevention_time > 0 && pcdData.wipeTime != DateTime.MinValue)
            {
                var timeSpan = (pcdData.wipeTime.AddHours(config.ultimate_settings.ultimate_raiding.wipe_prevention_time) - DateTime.Now).TotalMinutes;
                if (timeSpan > 0)
                {
                    //Player.Message(player, $"The server does not allow the MLRS strike to be used so close to wipe. This ability will be available in {(timeSpan > 120 ? $"{Math.Round(timeSpan / 60, 0)} hours." : timeSpan > 1 ? $"{Math.Round(timeSpan, 0)} minutes." : $"{Math.Round(timeSpan, 0)} seconds.")}");
                    Player.Message(player, string.Format(lang.GetMessage("RocketStrikeCooldownMsg", this, player.UserIDString), timeSpan > 120 ? $"{Math.Round(timeSpan / 60, 0)} {lang.GetMessage("Hours", this, player.UserIDString)}." : timeSpan > 1 ? $"{Math.Round(timeSpan, 0)} {lang.GetMessage("Minutes", this, player.UserIDString)}." : $"{Math.Round(timeSpan, 0)} {lang.GetMessage("Seconds", this, player.UserIDString)}."));
                    return;
                }
            }

            if (HasRaidBehaviour(player))
            {
                Player.Message(player, lang.GetMessage("RaidingUltimateAlreadyActive", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }

            if (!HasAmmo(player))
            {
                Player.Message(player, string.Format(lang.GetMessage("RaidingMissingAmmo", this, player.UserIDString), MissileQuantity));
                return;
            }

            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd) || !bd.ContainsBuff(Buff.Raiding_Ultimate))
            {
                Player.Message(player, lang.GetMessage("RaidingUltimateNotUnlocked", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }


            if (player.inventory.containerBelt.IsFull())
            {
                Player.Message(player, lang.GetMessage("RaidingUltimateNoFreeSlot", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }

            PlayerInfo pi;

            if (pcdData.pEntity.TryGetValue(player.userID, out pi))
            {
                if (pi.raiding_ultimate_used_time.AddMinutes(config.ultimate_settings.ultimate_raiding.cooldown) > DateTime.Now)
                {
                    var endTime = pi.raiding_ultimate_used_time.AddMinutes(config.ultimate_settings.ultimate_raiding.cooldown);
                    TimeSpan span = endTime.Subtract(DateTime.Now);
                    Player.Message(player, string.Format(lang.GetMessage("RaidingUltimateCooldown", this, player.UserIDString), span.TotalMinutes > 1 ? Math.Round(span.TotalMinutes, 0) + " " + lang.GetMessage("minutes", this, player.UserIDString) : Math.Round(span.TotalSeconds, 0) + " " + lang.GetMessage("seconds", this, player.UserIDString)), config.misc_settings.ChatID);
                    return;
                }
                else pi.raiding_ultimate_used_time = DateTime.Now;
            }
            else return;

            var item = ItemManager.CreateByName("tool.binoculars", 1);
            item.name = "MLRS Strike";

            if (!item.MoveToContainer(player.inventory.containerBelt, -1, false))
            {
                Player.Message(player, lang.GetMessage("BinocularGiveFail", this, player.UserIDString));
                item.Remove();
                return;
            }

            NextTick(() =>
            {
                item.MarkDirty();
                item.LockUnlock(true);
            });

            Player.Message(player, lang.GetMessage("RaidingUltimateChatInstructions", this, player.UserIDString), config.misc_settings.ChatID);

            AddRaidBehaviour(player);
        }

        [ConsoleCommand("stversion")]
        void PrintVersion(ConsoleSystem.Arg arg)
        {
            arg.ReplyWith($"SkillTree version: {this.Version}");
        }

        #endregion

        #region CUI

        static private void SendInstructions(BasePlayer player, string message)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "RaidUltimateSetTargetMessage",
                Parent = "Overlay",
                Components = {
                    new CuiTextComponent { Text = message, Font = "robotocondensed-regular.ttf", FontSize = 20, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-299.664 -176.8", OffsetMax = "300.336 -76.8" }
                }
            });

            CuiHelper.DestroyUi(player, "RaidUltimateSetTargetMessage");
            CuiHelper.AddUi(player, container);
        }

        static private void LaunchProgress(BasePlayer player, int bars, int durationTicks)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.2169811 0.2169811 0.2169811 1" },
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-101.664 114.3", OffsetMax = "102.336 148.3" }
            }, "Overlay", "LaunchProgress");
            var progress = (200 / durationTicks) * bars;
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1686275 0.3518807 0.7254902 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-100.338 -15", OffsetMax = $"{-100.338 + progress} 15" }
            }, "LaunchProgress", "bar");

            container.Add(new CuiElement
            {
                Name = "text",
                Parent = "LaunchProgress",
                Components = {
                    new CuiTextComponent { Text = Instance.lang.GetMessage("UIProgress", Instance, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-100.337 -15", OffsetMax = "100.003 15" }
                }
            });

            CuiHelper.DestroyUi(player, "LaunchProgress");
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Methods

        bool HasRaidBehaviour(BasePlayer player)
        {
            var gameObject = player.GetComponent<RaidBehaviour>();
            return gameObject != null;
        }

        void AddRaidBehaviour(BasePlayer player)
        {
            DestroyRaidBehaviour(player);
            var component = player.gameObject.AddComponent<RaidBehaviour>();
            component.Instance = this;
            component.showTimeRemaining = config.ultimate_settings.ultimate_raiding.show_time_remaining;
            component.timeRemainingMessage = lang.GetMessage("MLRSTimeLeft", this, player.UserIDString);
        }

        void DestroyRaidBehaviour(BasePlayer player)
        {
            if (player.IsNpc) return;
            var gameObject = player.GetComponent<RaidBehaviour>();
            if (gameObject != null)
            {
                UnityEngine.Object.DestroyImmediate(gameObject);
            }
        }

        void ResetStrikeCooldown(ulong userid, BasePlayer player = null)
        {
            pcdData.pEntity[userid].raiding_ultimate_used_time = DateTime.MinValue;
            if (player != null) Player.Message(player, lang.GetMessage("RaidingUltimateResetTimeout", this, player.UserIDString), config.misc_settings.ChatID);
        }

        #endregion

        #region Behaviour

        void SetupRaidUltimateStatics()
        {
            MaxDuration = config.ultimate_settings.ultimate_raiding.max_duration;
            DurationTicks = config.ultimate_settings.ultimate_raiding.ticks_required;
            CheckInterval = config.ultimate_settings.ultimate_raiding.tick_interval;
            MissileQuantity = config.ultimate_settings.ultimate_raiding.missile_amount;
            MissileFireDelay = config.ultimate_settings.ultimate_raiding.delay_between_rockets;
            MissileFireConfirmationEffect = config.ultimate_settings.ultimate_raiding.missile_fire_confirmation_effect;

            RaidBehaviourExpiredMessage = lang.GetMessage("RaidBehaviourExpiredMessage", this);
            RaidBehaviourSuccessMessage = lang.GetMessage("RaidBehaviourSuccessMessage", this);
        }

        public float MaxDuration;
        public int DurationTicks;
        public float CheckInterval;
        public string RaidBehaviourExpiredMessage;
        public string RaidBehaviourSuccessMessage;
        public int MissileQuantity;
        public float MissileFireDelay;
        public string MissileFireConfirmationEffect;
        public MLRS mlrs;

        // DateTime = DateTime.Now + prevention seconds
        public Dictionary<Vector3, DateTime> StrikedLocations = new Dictionary<Vector3, DateTime>();

        public Dictionary<ulong, bool> StrikeFired = new Dictionary<ulong, bool>();

        //CreateGameTip
        public class RaidBehaviour : MonoBehaviour
        {
            public SkillTree Instance;
            private BasePlayer player;
            private ulong userid;
            private int pressedDuration;
            private float nextCheck;

            public bool showTimeRemaining;
            public string timeRemainingMessage;
            public float timeSinceBroken;

            private Vector3 targetPoint;
            private int fired;

            private bool striking = false;
            private Item binoculars;

            private bool wsAdmin;
            private bool sendhudhint = false;
            private float startTime;
            private bool sentInstructions = false;
            private bool wasDestroyed;

            private Timer positionTimer;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                wsAdmin = player.IsAdmin;
                startTime = Time.time;
                nextCheck = Time.time + 0.5f;
                userid = player.userID;
                foreach (var item in player.inventory.containerBelt.itemList)
                {
                    if (item.info.shortname == "tool.binoculars" && item.name != null)
                    {
                        binoculars = item;
                        break;
                    }
                }
            }

            public void FixedUpdate()
            {
                if (!sentInstructions)
                {
                    SendInstructions(player, Instance.lang.GetMessage("UIBinocularsMessage", Instance, player.UserIDString));
                    sentInstructions = true;
                }
                if (player == null || !player.IsConnected)
                {
                    Destroy(this);
                    return;
                }

                if (Time.time > startTime + Instance.MaxDuration && !striking)
                {
                    CreateGameTip(Instance.RaidBehaviourExpiredMessage, player, 10);
                    CuiHelper.DestroyUi(player, "PendingTimer");
                    //player.ChatMessage(RaidBehaviourExpiredMessage);
                    DisableStrike();
                    return;
                }

                var activeItem = player.GetActiveItem();

                if (showTimeRemaining && !striking) Instance.PendingTimer(player, string.Format(timeRemainingMessage, Convert.ToInt32(startTime + Instance.MaxDuration - Time.time)));

                if (!player.serverInput.IsDown(BUTTON.FIRE_SECONDARY) || !player.serverInput.IsDown(BUTTON.USE) || activeItem == null || activeItem != binoculars)
                {
                    nextCheck = Time.time + Instance.CheckInterval;
                    pressedDuration = 0;
                    if (!player.serverInput.IsDown(BUTTON.FIRE_SECONDARY)) CuiHelper.DestroyUi(player, "LaunchProgress");
                    else LaunchProgress(player, 0, Instance.DurationTicks);
                    return;
                }

                if (Time.time > nextCheck)
                {
                    nextCheck = Time.time + Instance.CheckInterval;
                    pressedDuration++;
                    LaunchProgress(player, pressedDuration, Instance.DurationTicks);

                    RaycastHit raycastHit;
                    bool flag = Physics.Raycast(player.eyes.HeadRay(), out raycastHit, 5000, LAYER_TARGET);
                    targetPoint = flag ? raycastHit.point : Vector3.zero;

                    if (Interface.CallHook("OnRaidingUltimateTargetAcquire", player, targetPoint) != null)
                        targetPoint = Vector3.zero;

                    if (!Instance.PassRaidableBasesCheck(targetPoint, Buff.Raiding_Ultimate))
                        targetPoint = Vector3.zero;

                    if (targetPoint == Vector3.zero)
                    {
                        ResetLaunchProgress();
                        return;
                    }

                    if (!wsAdmin)
                    {
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                        player.SendNetworkUpdateImmediate();
                    }
                    player.SendConsoleCommand("ddraw.text", Instance.CheckInterval, Color.red, targetPoint, "X");
                    if (!wsAdmin)
                    {
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                        player.SendNetworkUpdateImmediate();
                    }

                    if (!string.IsNullOrEmpty(Instance.config.ultimate_settings.ultimate_raiding.valid_position_effect)) EffectNetwork.Send(new Effect(Instance.config.ultimate_settings.ultimate_raiding.valid_position_effect, player.transform.position, player.transform.position), player.net.connection);
                    if (pressedDuration >= Instance.DurationTicks)
                    {
                        DoStrike();
                    }
                }
            }

            public void ResetLaunchProgress()
            {
                pressedDuration = 0;
                if (!player.serverInput.IsDown(BUTTON.FIRE_SECONDARY)) CuiHelper.DestroyUi(player, "LaunchProgress");
                else
                {
                    if (!sendhudhint)
                    {
                        CreateGameTip("Invalid target location.", player, 5);
                        sendhudhint = true;
                    }
                    LaunchProgress(player, 0, Instance.DurationTicks);
                }
            }

            public bool ValidateStrikeLocation(Vector3 loc)
            {
                if (!Instance.config.ultimate_settings.ultimate_raiding.prevent_mlrs_spamming) return true;
                foreach (var pos in Instance.StrikedLocations)
                {
                    if (InRange(pos.Key, loc, Instance.config.ultimate_settings.ultimate_raiding.prevention_radius))
                    {
                        if (pos.Value > DateTime.Now)
                        {
                            //Instance.Player.Message(player, $"Strike cancelled - location too closed to a previous strike zone. Available in: {Math.Floor((pos.Value - DateTime.Now).TotalMinutes)} minutes.", Instance.config.misc_settings.ChatID);
                            Instance.Player.Message(player, string.Format(Instance.lang.GetMessage("StrikeCancelledDueToPreviousStrike", Instance, player.UserIDString), Math.Floor((pos.Value - DateTime.Now).TotalMinutes)), Instance.config.misc_settings.ChatID);
                            return false;
                        }
                        Instance.StrikedLocations.Remove(pos.Key);
                        return true;
                    }
                }
                return true;
            }

            private bool SetupMLRS()
            {
                if (Instance.mlrs.IsDead() || Instance.mlrs.IsFiringRockets)
                {
                    return false;
                }

                StorageContainer dashboardContainer = Instance.mlrs.GetDashboardContainer();
                if (!Instance.mlrs.HasAimingModule)
                {
                    dashboardContainer.inventory.AddItem(ItemManager.FindItemDefinition("aiming.module.mlrs"), 1, 0uL);
                }

                StorageContainer rocketContainer = Instance.mlrs.GetRocketContainer();
                ItemDefinition itemDefinition = ItemManager.FindItemDefinition("ammo.rocket.mlrs");

                int ammoPerSlot = Instance.config.ultimate_settings.ultimate_raiding.missile_amount / 2;
                for (int i = 0; i < rocketContainer.inventory.capacity; i++)
                {
                    rocketContainer.inventory.AddItem(itemDefinition, ammoPerSlot, 0ul);
                }

                Instance.mlrs.SetRepaired();
                Instance.mlrs.SendNetworkUpdate();
                return true;
            }

            public void DoStrike()
            {
                if (targetPoint == Vector3.zero || !ValidateStrikeLocation(targetPoint))
                {
                    ResetLaunchProgress();
                    return;
                }
                if (!Instance.HasAmmo(player, true))
                {
                    CreateGameTip($"Not enough MLRS rockets in inventory. Required amount: {Instance.MissileQuantity}", player, 7);
                    ResetLaunchProgress();
                    return;
                }
                if (Instance.mlrs != null)
                {
                    if (Instance.mlrs.IsFiringRockets)
                    {
                        CreateGameTip("MLRS fire mission is already in progress. Please try again shortly.", player, 10);
                        ResetLaunchProgress();
                        return;
                    }
                    if (Instance.mlrs._mounted != null)
                    {
                        if (Instance.mlrs.HasAimingModule)
                        {
                            CreateGameTip($"MLRS is in use by another player. Please wait for them to dismount.", player, 7);
                            ResetLaunchProgress();
                            return;
                        }
                        CreateGameTip("You were removed from the MLRS so it could be used for a remote fire mission.", Instance.mlrs._mounted, 7);
                        Instance.mlrs._mounted.EnsureDismounted();
                    }

                    Instance.mlrs.SetFlag(BaseEntity.Flags.Locked, true);
                    if (Instance.mlrs.IsBroken())
                    {
                        wasDestroyed = true;
                        timeSinceBroken = Instance.mlrs.timeSinceBroken;
                    }
                    if (!SetupMLRS())
                    {
                        CreateGameTip("Something went wrong while attempting to setup the MLRS. Please try again.", player, 7);
                        ResetLaunchProgress();
                        return;
                    }
                }
                if (!string.IsNullOrEmpty(Instance.MissileFireConfirmationEffect)) EffectNetwork.Send(new Effect(Instance.MissileFireConfirmationEffect, player.transform.position, player.transform.position), player.net.connection);
                CreateGameTip(Instance.RaidBehaviourSuccessMessage, player, 7);
                CuiHelper.DestroyUi(player, "RaidUltimateSetTargetMessage");
                CuiHelper.DestroyUi(player, "LaunchProgress");
                CuiHelper.DestroyUi(player, "PendingTimer");
                striking = true;
                Instance.StrikeFired[userid] = true;
                RemoveBinoculars();
                player.inventory.containerBelt.SetLocked(false);
                if (Instance.config.ultimate_settings.ultimate_raiding.prevent_mlrs_spamming) Instance.StrikedLocations.Add(targetPoint, DateTime.Now.AddSeconds(Instance.config.ultimate_settings.ultimate_raiding.prevention_duration));

                if (Instance.config.ultimate_settings.ultimate_raiding.use_real_MLRS_entity) SetMLRSPosition();
                else InvokeRepeating(nameof(FireRocket), 0f, Instance.MissileFireDelay);
            }

            private void SetMLRSPosition()
            {
                Instance.mlrs.SetUserTargetHitPos(targetPoint);
                Instance.mlrs.SendNetworkUpdate();

                CreateGameTip("Acquiring firing position...", player, 5);
                positionTimer = Instance.timer.Every(1, () =>
                {
                    if (Instance.mlrs.IsRealigning) return;

                    if (fired == 0)
                    {
                        CreateGameTip("Position acquired. Firing payload.", player, 5);
                        Instance.mlrs.SetFlag(BaseEntity.Flags.Reserved6, b: true);
                        Instance.mlrs.radiusModIndex = 0;
                        Instance.mlrs.nextRocketIndex = Mathf.Min(Instance.mlrs.RocketAmmoCount - 1, Instance.mlrs.rocketTubes.Length - 1);
                        Instance.mlrs.rocketOwnerRef.Set(player);
                        Instance.mlrs.InvokeRepeating(Instance.mlrs.FireNextRocket, 0f, 0.5f);
                        fired = 1;
                    }

                    if (Instance.mlrs.IsFiringRockets) return;
                    DisableStrike();
                });
            }

            public void FireRocket()
            {
                Vector3 firePoint = player.transform.position + new Vector3(0, 100, 0);
                Vector3 nVector = targetPoint - firePoint;
                var rocket = GameManager.server.CreateEntity("assets/content/vehicles/mlrs/rocket_mlrs.prefab", firePoint, Quaternion.Euler(nVector)) as MLRSRocket;
                if (rocket == null)
                {
                    return;
                }
                rocket.creatorEntity = player;
                rocket.OwnerID = player.userID;
                rocket.skinID = MlrsSkin;

                var proj = rocket.GetComponent<ServerProjectile>();
                if (proj == null) return;
                proj.InitializeVelocity(nVector);
                rocket.Spawn();
                fired++;
                if (fired >= Instance.MissileQuantity)
                {
                    DisableStrike();
                }
            }

            public void RemoveBinoculars()
            {
                binoculars?.Remove();
            }

            public void DisableStrike()
            {
                CreateGameTip("Fire mission complete.", player, 5);
                CancelInvoke(nameof(FireRocket));
                Destroy(this);
                CuiHelper.DestroyUi(player, "RaidUltimateSetTargetMessage");
                CuiHelper.DestroyUi(player, "LaunchProgress");
            }

            private void OnDestroy()
            {
                if (Instance.mlrs != null)
                {
                    if (timeSinceBroken > 0) Instance.mlrs.timeSinceBroken = timeSinceBroken;
                    if (!wasDestroyed)
                    {
                        Instance.mlrs.SetRepaired();
                    }
                    if (positionTimer != null && !positionTimer.Destroyed) positionTimer.Destroy();
                }
                if (player != null && player.inventory != null)
                {
                    var items = Instance.AllItems(player);
                    foreach (var item in items)
                    {
                        if (item.info.shortname == "tool.binoculars" && item.IsLocked())
                            item.Remove();
                    }
                    Pool.FreeUnmanaged(ref items);
                }
                if (!Instance.StrikeFired.ContainsKey(userid) || !Instance.StrikeFired[userid]) Instance.ResetStrikeCooldown(userid, player);
                Instance.StrikeFired.Remove(player.userID);
                CuiHelper.DestroyUi(player, "RaidUltimateSetTargetMessage");
                CuiHelper.DestroyUi(player, "LaunchProgress");
                CuiHelper.DestroyUi(player, "PendingTimer");
                RemoveBinoculars();
                enabled = false;
                CancelInvoke();
            }
        }

        private Dictionary<ulong, Timer> timers = new Dictionary<ulong, Timer>();

        private static void CreateGameTip(string text, BasePlayer player, float length = 10f)
        {
            if (player == null)
                return;
            Timer timer;
            if (Instance.timers.TryGetValue(player.userID, out timer))
            {
                timer.Destroy();
            }
            player.SendConsoleCommand("gametip.hidegametip");
            player.SendConsoleCommand("gametip.showgametip", text);
            Instance.timers[player.userID] = Instance.timer.Once(length, () => player?.SendConsoleCommand("gametip.hidegametip"));
        }

        private static SkillTree Instance { get; set; }

        public bool HasAmmo(BasePlayer player, bool take = false)
        {
            if (!config.ultimate_settings.ultimate_raiding.require_ammo) return true;
            List<Item> mlrsItems = Pool.Get<List<Item>>();
            int ammo = 0;
            var items = AllItems(player);
            foreach (var item in items)
            {
                if (item.info.shortname == "ammo.rocket.mlrs")
                {
                    mlrsItems.Add(item);
                    ammo += item.amount;
                }

                if (ammo >= Instance.MissileQuantity) break;
            }
            Pool.FreeUnmanaged(ref items);

            if (!take)
            {
                Pool.FreeUnmanaged(ref mlrsItems);
                return ammo >= Instance.MissileQuantity;
            }
            else if (ammo < Instance.MissileQuantity) return false;

            var taken = 0;
            foreach (var item in mlrsItems)
            {
                if (item.amount == Instance.MissileQuantity - taken)
                {
                    item.Remove();
                    taken = Instance.MissileQuantity;
                }
                else if (item.amount > Instance.MissileQuantity - taken)
                {
                    item.UseItem(Instance.MissileQuantity - taken);
                    taken = Instance.MissileQuantity;
                }
                else
                {
                    taken += item.amount;
                    item.Remove();
                }
                if (taken >= Instance.MissileQuantity) break;
            }
            return true;
        }

        #endregion

        #endregion

        #endregion

        #region Sonar

        public enum SonarType
        {
            Invalid,
            Tugboat,
            DiveSite,
            Player,
            Scientist,
            Shark
        }

        void SonarChatCMD(BasePlayer player) => HandleSonarBuff(player);
        void SonarConsoleCMD(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            HandleSonarBuff(player);
        }

        Dictionary<ulong, float> SonarCooldown = new Dictionary<ulong, float>();
        void HandleSonarBuff(BasePlayer player)
        {
            if (!player.IsAdmin && !player.IsDeveloper && player.IsFlying)
            {
                Player.Message(player, lang.GetMessage("DisableNoclipCommand", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }

            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd) || !bd.ContainsBuff(Buff.Sonar)) return;

            if (config.buff_settings.sonar_settings.cooldown > 0)
            {
                float time;
                if (SonarCooldown.TryGetValue(player.userID, out time))
                {
                    if (time > Time.time)
                    {
                        Player.Message(player, string.Format(lang.GetMessage("SonarBuffCooldown", this, player.UserIDString), Math.Round(time - Time.time, 0)), config.misc_settings.ChatID);
                        return;
                    }
                    else SonarCooldown[player.userID] = Time.time + config.buff_settings.sonar_settings.cooldown;
                }
                else SonarCooldown.Add(player.userID, Time.time + config.buff_settings.sonar_settings.cooldown);
            }

            var entitites = FindEntitiesOfType<BaseEntity>(player.transform.position, config.buff_settings.sonar_settings.distance);
            List<BaseEntity> validEntities = Pool.Get<List<BaseEntity>>();
            foreach (var entity in entitites)
            {
                if (!IsEntityUnderwater(entity)) continue;
                if (entity is BasePlayer)
                {
                    var p = entity as BasePlayer;
                    if (p.IsNpc || !p.userID.IsSteamId())
                    {
                        if (config.buff_settings.sonar_settings.show_scientists) validEntities.Add(entity);
                    }
                    else if (config.buff_settings.sonar_settings.show_players) validEntities.Add(entity);
                }
                else if (entity is Tugboat)
                {
                    if (config.buff_settings.sonar_settings.show_tugboats) validEntities.Add(entity);
                }
                else if (entity is DiveSite)
                {
                    if (config.buff_settings.sonar_settings.show_dive_sites) validEntities.Add(entity);
                }
                else if (entity is SimpleShark)
                {
                    if (config.buff_settings.sonar_settings.show_sharks) validEntities.Add(entity);
                }
            }
            Pool.FreeUnmanaged(ref entitites);

            var wasAdmin = player.IsAdmin;
            try
            {
                if (!wasAdmin)
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                    player.SendNetworkUpdateImmediate();
                }

                foreach (var entity in validEntities)
                {
                    var type = GetEntityType(entity);
                    Color col = GetSonarColor(type);
                    player.SendConsoleCommand("ddraw.text", config.buff_settings.sonar_settings.time_on_screen, col, entity.transform.position, lang.GetMessage(type.ToString(), this, player.UserIDString) + (config.buff_settings.sonar_settings.show_distance ? string.Format(lang.GetMessage("ShowDist", this, player.UserIDString), Math.Round(Vector3.Distance(player.transform.position, entity.transform.position), 0)) : null));
                }

                if (!wasAdmin)
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                    player.SendNetworkUpdateImmediate();
                }
            }
            finally
            {
                if (!wasAdmin)
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                    player.SendNetworkUpdateImmediate();
                }
            }

            
            Pool.FreeUnmanaged(ref validEntities);
        }

        SonarType GetEntityType(BaseEntity entity)
        {
            if (entity is SimpleShark) return SonarType.Shark;
            if (entity is Tugboat) return SonarType.Tugboat;
            if (entity is DiveSite) return SonarType.DiveSite;
            var player = entity as BasePlayer;
            if (player == null) return SonarType.Invalid;
            return player != null && player.userID.IsSteamId() ? SonarType.Player : SonarType.Scientist;
        }

        Color GetSonarColor(SonarType type)
        {
            switch (type)
            {
                case SonarType.Player: return Color.red;
                case SonarType.DiveSite: return Color.yellow;
                case SonarType.Scientist: return Color.magenta;
                case SonarType.Shark: return Color.green;
                case SonarType.Tugboat: return Color.white;
                default: return Color.cyan;
            }
        }

        #endregion

        #region Forager

        void ForagerChatCMD(BasePlayer player) => HandleForagerBuff(player);
        void ForagerConsoleCMD(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            HandleForagerBuff(player);
        }

        Dictionary<ulong, float> ForagerCooldown = new Dictionary<ulong, float>();
        void HandleForagerBuff(BasePlayer player)
        {
            if (!player.IsAdmin && !player.IsDeveloper && player.IsFlying)
            {
                Player.Message(player, lang.GetMessage("DisableNoclipCommand", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }

            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd) || !bd.ContainsBuff(Buff.Forager)) return;

            if (config.buff_settings.forager_settings.cooldown > 0)
            {
                float time;
                if (ForagerCooldown.TryGetValue(player.userID, out time))
                {
                    if (time > Time.time)
                    {
                        Player.Message(player, string.Format(lang.GetMessage("ForageBuffCooldown", this, player.UserIDString), Math.Round(time - Time.time, 0)), config.misc_settings.ChatID);
                        return;
                    }
                    else ForagerCooldown[player.userID] = Time.time + config.buff_settings.forager_settings.cooldown;
                }
                else ForagerCooldown.Add(player.userID, Time.time + config.buff_settings.forager_settings.cooldown);
            }

            var collectibles = FindEntitiesOfType<BaseEntity>(player.transform.position, config.buff_settings.forager_settings.distance);

            collectibles.RemoveAll(x => (!(x is NaturalBeehive) && !(x is CollectibleEntity)) || config.buff_settings.forager_settings.blacklist.Contains(x.ShortPrefabName));

            if (collectibles.Count == 0)
            {
                Pool.FreeUnmanaged(ref collectibles);
                return;
            }

            var wasAdmin = player.IsAdmin;
            if (!wasAdmin)
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                player.SendNetworkUpdateImmediate();
            }

            foreach (var collectible in collectibles)
            {
                float[] cols;
                if (!config.buff_settings.forager_settings.displayColours.TryGetValue(collectible.ShortPrefabName, out cols)) cols = DefaultForagerCol;
                player.SendConsoleCommand("ddraw.text", config.buff_settings.forager_settings.time_on_screen, new Color(cols[0], cols[1], cols[2]), collectible.transform.position, CollectibleDisplayName(player, collectible.ShortPrefabName) + (config.buff_settings.forager_settings.show_distance ? string.Format(lang.GetMessage("ShowDist", this, player.UserIDString), Math.Round(Vector3.Distance(player.transform.position, collectible.transform.position), 0)) : null));
            }

            if (!wasAdmin)
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                player.SendNetworkUpdateImmediate();
            }

            Pool.FreeUnmanaged(ref collectibles);
        }

        float[] DefaultForagerCol = new float[3] { 0.960f, 0.802f, 0.230f };

        string CollectibleDisplayName(BasePlayer player, string shortname)
        {
            return lang.GetMessage(shortname, this, player.UserIDString);
        }

        #endregion

        #region Instant Untie

        void SetInstantUntieBlock(BasePlayer player, bool shouldBlock)
        {
            if (!buffDetails.TryGetValue(player.userID, out var bd) || !bd.ContainsBuff(Buff.InstantUntie)) return;

            var gameObject = player.GetComponent<InstantUntie>();
            if (gameObject == null) return;
            gameObject.SetBlocked(shouldBlock);
        }

        public class InstantUntie : MonoBehaviour
        {
            private BasePlayer player;
            private float checkDelay;
            private bool hitSuccess;
            private bool Blocked;

            // Awake() is part of the Monobehaviour class.
            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                checkDelay = Time.time + 0.1f;
            }

            public void SetBlocked(bool shouldBlock)
            {
                Blocked = shouldBlock;
            }

            // FixedUpdate() is also part of the monobehaviour class.
            public void FixedUpdate()
            {
                if (player == null || player.WaterFactor() < 1f) return;
                if (checkDelay < Time.time)
                {
                    if (player.serverInput.IsDown(BUTTON.USE) && !hitSuccess && !Blocked)
                    {
                        var target = GetTargetEntity(player);
                        if (target != null && target is FreeableLootContainer)
                        {
                            var lootContainer = target as FreeableLootContainer;
                            if (!lootContainer.IsTiedDown()) return;
                            lootContainer.Release(player);
                            

                            hitSuccess = true;
                        }
                    }
                    if (hitSuccess) checkDelay = Time.time + 2.0f;
                    else checkDelay = Time.time + 0.1f;
                    hitSuccess = false;
                }
            }

            // OnDestroy() built into the monobehaviour class.
            private void OnDestroy()
            {
                enabled = false;
                CancelInvoke();
            }
        }

        void DestroyInstantUntie(BasePlayer player)
        {
            BreathTime.Remove(player);
            var gameObject = player.GetComponent<InstantUntie>();
            if (gameObject != null) GameObject.Destroy(gameObject);
        }

        void UpdateInstantUntie(BasePlayer player)
        {
            DestroyInstantUntie(player);
            var gameObject = player.gameObject.AddComponent<InstantUntie>();
            if (DisabledPlayers.Contains(player.userID)) gameObject.SetBlocked(true);
        }

        const int LAYER_TARGET = ~(1 << 2 | 1 << 3 | 1 << 4 | 1 << 10 | 1 << 18 | 1 << 28 | 1 << 29);
        private static BaseEntity GetTargetEntity(BasePlayer player)
        {
            RaycastHit raycastHit;
            bool flag = Physics.Raycast(player.eyes.HeadRay(), out raycastHit, 5, LAYER_TARGET);
            var targetEntity = flag ? raycastHit.GetEntity() : null;
            return targetEntity;
        }

        #endregion

        #region Handle API Nodes

        bool NewNodesAdded = false;
        public Dictionary<string, Dictionary<string, Configuration.TreeInfo.NodeInfo>> QueuedNodes = new Dictionary<string, Dictionary<string, Configuration.TreeInfo.NodeInfo>>();

        // AddNode(string tree, string node, bool enabled, int max_level, int tier, float value_per_buff, string buff, string buffType, string icon_url, object[] perms { string perms_description, Dictionary<int, List<string>> tiers_and_perms })
        [HookMethod("AddNode")]
        public void AddNode(string tree, string node, bool enabled, int max_Level, int tier, float value_Per_Buff, string _buff, string _buffType, string icon_url, object[] _perms = null, ulong skin = 0, bool overwrite = false)
        {
            Buff buff;
            if (!Enum.TryParse(_buff, out buff) || buff == Buff.None) return;
            BuffType buffType;
            if (!Enum.TryParse(_buffType, out buffType)) return;
            if (string.IsNullOrEmpty(tree)) return;
            if (!config.trees.ContainsKey(tree)) return;
            if (string.IsNullOrEmpty(node)) return;
            if (config.trees[tree].nodes.ContainsKey(node) && !overwrite) return;
            if (string.IsNullOrEmpty(icon_url) && skin == 0)
            {
                Puts($"Error adding skill - requires a skinid or url");
                return;
            }

            Permissions perms = null;

            if (_perms != null && _perms.Length == 2 && !string.IsNullOrEmpty((string)_perms[0]) && (Dictionary<int, Dictionary<string, string>>)_perms[1] != null)
            {
                Dictionary<int, PermissionInfo> perms_to_add = new Dictionary<int, PermissionInfo>();
                foreach (var kvp in (Dictionary<int, Dictionary<string, string>>)_perms[1])
                {
                    perms_to_add.Add(kvp.Key, new PermissionInfo(kvp.Value));
                }
                perms = new Permissions((string)_perms[0], perms_to_add);
            }
            //new Configuration.TreeInfo(new Dictionary<string, Configuration.TreeInfo.NodeInfo>()            
            var NodeData = new Configuration.TreeInfo.NodeInfo(enabled, max_Level, tier, value_Per_Buff, new KeyValuePair<Buff, BuffType>(buff, buffType), icon_url, skin, perms);

            if (overwrite && config.trees.ContainsKey(tree) && config.trees[tree].nodes.ContainsKey(node) && IsDataIdentical(NodeData, config.trees[tree].nodes[node]))
            {
                return;
            }

            Puts($"Queuing new node {node}, to be added to tree: {tree} - Buff: {buff} - Type: {buffType}");
            if (!QueuedNodes.ContainsKey(tree)) QueuedNodes.Add(tree, new Dictionary<string, Configuration.TreeInfo.NodeInfo>());
            if (!QueuedNodes[tree].ContainsKey(node))
            {
                QueuedNodes[tree].Add(node, NodeData);
                NewNodesAdded = true;
            }

            if (overwrite && config.trees[tree].nodes.ContainsKey(node))
            {
                Puts($"Overwriting node: {node}.");
                var nodeData = config.trees[tree].nodes[node];
                if (nodeData.permissions != null && !nodeData.permissions.perms.IsNullOrEmpty())
                {
                    List<string> permsToRevoke = Pool.Get<List<string>>();
                    try
                    {
                        foreach (var num in nodeData.permissions.perms)
                        {
                            foreach (var perm in num.Value.perms_list)
                            {
                                permsToRevoke.Add(perm.Key);
                            }
                        }
                    }
                    catch { }

                    Puts($"Found {permsToRevoke.Count} perms to revoke. Revoking from all active players.");
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        try
                        {
                            foreach (var perm in permsToRevoke)
                                if (permission.UserHasPermission(player.UserIDString, perm)) permission.RevokeUserPermission(player.UserIDString, perm);
                        }
                        catch { }
                    }
                    Pool.FreeUnmanaged(ref permsToRevoke);
                }

                config.trees[tree].nodes.Remove(node);
                OnServerSave();
            }
            //config.trees[tree].nodes.Add(node, new Configuration.TreeInfo.NodeInfo(enabled, max_level, tier, value_per_buff, new KeyValuePair<Buff, BuffType>(buff, buffType), icon_url, perms));            
        }

        bool IsDataIdentical(Configuration.TreeInfo.NodeInfo oldNodeData, Configuration.TreeInfo.NodeInfo newNodeData)
        {
            if (oldNodeData.enabled != newNodeData.enabled) return false;
            if (oldNodeData.buff_info.Key != newNodeData.buff_info.Key || oldNodeData.buff_info.Value != newNodeData.buff_info.Value) return false;
            if (oldNodeData.value_per_buff != newNodeData.value_per_buff) return false;
            if (oldNodeData.tier != newNodeData.tier) return false;
            if (oldNodeData.skin != newNodeData.skin) return false;
            if (oldNodeData.icon_url != newNodeData.icon_url) return false;
            if (oldNodeData.max_level != newNodeData.max_level) return false;
            if (oldNodeData.permissions.description != newNodeData.permissions.description) return false;
            if (oldNodeData.permissions.perms.Count != newNodeData.permissions.perms.Count) return false;
            foreach (var num in oldNodeData.permissions.perms)
            {
                if (!newNodeData.permissions.perms.ContainsKey(num.Key)) return false;
                foreach (var perm in num.Value.perms_list)
                {
                    if (!newNodeData.permissions.perms[num.Key].perms_list.ContainsKey(perm.Key)) return false;
                    else if (newNodeData.permissions.perms[num.Key].perms_list[perm.Key] != perm.Value) return false;
                }
            }
            return true;
        }

        [ConsoleCommand("addtestpermsnode")]
        void AddTestPermsNodeConsoleCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && permission.UserHasPermission(player.UserIDString, perm_admin)) return;

            AddTestPermsNode(player ?? null);
        }

        [ChatCommand("addtestpermsnode")]
        void AddTestPermsNode(BasePlayer player)
        {
            if (player != null && !permission.UserHasPermission(player.UserIDString, "skilltree.admin")) return;
            if (!config.trees.ContainsKey("Cooking")) return;
            if (config.trees["Cooking"].nodes.ContainsKey("Test perms node")) return;

            config.trees["Cooking"].nodes.Add("Test perms node", new Configuration.TreeInfo.NodeInfo(false, 2, 2, 1, new KeyValuePair<Buff, BuffType>(Buff.Permission, BuffType.Permission), "https://www.dropbox.com/s/6blc3eiarm07rku/cooking%20tree%20example.v1.png?dl=1", 2936558732, new Permissions("This is a test node. You can add your description here. Level 1 gives instant cooking. Level 2 gives free cooking.", new Dictionary<int, PermissionInfo>()
            {
                [1] = new PermissionInfo(new Dictionary<string, string>() { ["cooking.instant"] = "Instant Cooking" }),
                [2] = new PermissionInfo(new Dictionary<string, string>() { ["cooking.instant"] = "Instant Cooking", ["cooking.free"] = "Free Cooking" })
            })));

            SaveConfig();
            if (player != null) Player.Message(player, "Saved new node called 'Test perms node' in the Cooking tree.", config.misc_settings.ChatID);
            else Puts("Saved new node called 'Test perms node' in the Cooking tree.");
        }

        #endregion

        #region Discord

        public void SendDiscordMsg(string message)
        {
            if (string.IsNullOrEmpty(config.notification_settings.discordSettings.webhook)) return;
            try
            {
                Dictionary<string, string> headers = new Dictionary<string, string>();
                headers.Add("Content-Type", "application/json");
                string payload = "{\"content\": \"" + message + "\"}";
                webrequest.Enqueue(config.notification_settings.discordSettings.webhook, payload, (code, response) =>
                {
                    if (code != 200 && code != 204)
                    {
                        if (response == null)
                        {
                            PrintWarning($"Discord didn't respond. Error Code: {code}. Try removing escape characters from your string such as \\n.");
                        }
                    }
                }, this, Core.Libraries.RequestMethod.POST, headers);
            }
            catch (Exception e)
            {
                Puts($"Failed. Error: {e?.Message}.\nIf this error was related to Bad Request, you may need to remove any escapes from your lang such as \\n.");
            }

        }

        #endregion

        #region Cooking Ultimate

        void AddTeaBuffsCMD(BasePlayer player)
        {
            BuffDetails bd;
            if (!GetBuffDetails(player.userID, out bd) || !bd.ContainsBuff(Buff.Cooking_Ultimate))
            {
                Player.Message(player, lang.GetMessage("CookingUltimateNotUnlocked", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }

            if (!IsUltimateEnabled(player, Buff.Cooking_Ultimate))
            {
                Player.Message(player, string.Format(lang.GetMessage("CookingUltimateNotEnabled", this, player.UserIDString), lang.GetMessage("UltimateSettingsButton", this, player.UserIDString)), config.misc_settings.ChatID);
                return;
            }

            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;

            if (playerData.cooking_ultimate_used_time.AddMinutes(config.ultimate_settings.ultimate_cooking.buff_cooldown) > DateTime.Now)
            {
                var endTime = playerData.cooking_ultimate_used_time.AddMinutes(config.ultimate_settings.ultimate_cooking.buff_cooldown);
                TimeSpan span = endTime.Subtract(DateTime.Now);
                //Player.Message(player, $"You cannot use this ultimate again until <color=#ffae00>{pi.raiding_ultimate_used_time.AddMinutes(config.ultimate_settings.ultimate_raiding.cooldown).ToString("hh:mm:ss tt")}</color>.");
                Player.Message(player, string.Format(lang.GetMessage("CookingUltimateCooldownReminder", this, player.UserIDString), span.TotalMinutes > 1 ? Math.Round(span.TotalMinutes, 0) + " minutes" : Math.Round(span.TotalSeconds, 0) + " seconds"), config.misc_settings.ChatID);
                return;
            }
            playerData.cooking_ultimate_used_time = DateTime.Now;

            AddTeaBuffs(player);
        }

        void AddTeaBuffs(BasePlayer player)
        {
            List<Modifier> ExistingModifiers = Pool.Get<List<Modifier>>();
            List<Modifier.ModifierType> EMods = Pool.Get<List<Modifier.ModifierType>>();
            ExistingModifiers.AddRange(player.modifiers.All);
            foreach (var mod in ExistingModifiers)
            {
                CookingUltimate.ModifierValues entryValue;
                if (!config.ultimate_settings.ultimate_cooking.tea_mods.TryGetValue(mod.Type, out entryValue) || (mod.Value > entryValue.modifier && !config.ultimate_settings.ultimate_cooking.override_better_mod) || (mod.Duration > entryValue.duration && !config.ultimate_settings.ultimate_cooking.override_better_duration)) EMods.Add(mod.Type);
            }
            Pool.FreeUnmanaged(ref ExistingModifiers);

            List<ModifierDefintion> mods = Pool.Get<List<ModifierDefintion>>();
            foreach (var entry in config.ultimate_settings.ultimate_cooking.tea_mods)
            {
                if (EMods.Contains(entry.Key)) continue;
                mods.Add(new ModifierDefintion
                {
                    type = entry.Key,
                    value = entry.Value.modifier,
                    duration = Convert.ToSingle(entry.Value.duration),
                    source = Modifier.ModifierSource.Tea
                });
            }
            Pool.FreeUnmanaged(ref EMods);

            HandlingCookingUltimate = true;
            player.modifiers.Add(mods);
            player.modifiers.SendChangesToClient();
            HandlingCookingUltimate = false;

            var messageString = lang.GetMessage("AppliedTeaMessage", this, player.UserIDString);
            foreach (var mod in config.ultimate_settings.ultimate_cooking.tea_mods)
            {
                messageString += string.Format(lang.GetMessage("AppliedTeaMessageModString", this, player.UserIDString), mod.Key.ToString().Replace('_', ' '), mod.Value.modifier * 100, mod.Value.duration / 60);
            }
            Player.Message(player, messageString, config.misc_settings.ChatID);

            Pool.FreeUnmanaged(ref mods);
        }

        void RemoveCookingUltimateBuffs(BasePlayer player)
        {
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;

            if (playerData.cooking_ultimate_used_time.AddMinutes(config.ultimate_settings.ultimate_cooking.buff_cooldown) <= DateTime.Now)
            {
                Player.Message(player, lang.GetMessage("CookingUltimateToggleOffCooldownFail", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }

            List<ModifierDefintion> modsToKeep = Pool.Get<List<ModifierDefintion>>();

            foreach (var mod in player.modifiers.All)
            {
                CookingUltimate.ModifierValues modData;
                if (!config.ultimate_settings.ultimate_cooking.tea_mods.TryGetValue(mod.Type, out modData) || mod.Value != modData.modifier) AddModToList(mod, modsToKeep);
            }
            player.modifiers.RemoveAll();
            if (modsToKeep.Count > 0) player.modifiers.Add(modsToKeep);
            player.modifiers.SendChangesToClient();

            Pool.FreeUnmanaged(ref modsToKeep);
        }

        List<ModifierDefintion> AddModToList(Modifier mod, List<ModifierDefintion> mods)
        {
            var duration = Convert.ToSingle(mod.TimeRemaining);
            mods.Add(new ModifierDefintion
            {
                type = mod.Type,
                value = mod.Value,
                duration = duration,
                source = mod.Source
            });
            return mods;
        }

        [ChatCommand("resetcookingultimate")]
        void ResetCookingUltimate(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, perm_admin)) return;

            PlayerInfo pi;
            if (!pcdData.pEntity.TryGetValue(player.userID, out pi)) return;

            pi.cooking_ultimate_used_time = DateTime.MinValue;

            Player.Message(player, "Your Cooking Ultimate timer has been reset.", config.misc_settings.ChatID);
        }

        #endregion

        #region Trap_Spotter

        void SearchForTrapsConsoleCMD(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null) SearchForTraps(player);
        }

        void SearchForTraps(BasePlayer player)
        {
            if (!player.IsAdmin && !player.IsDeveloper && player.IsFlying)
            {
                Player.Message(player, "You cannot use this command while in noclip.", config.misc_settings.ChatID);
                return;
            }

            if (config.buff_settings.raid_perk_settings.Trap_Spotter_settings.raidable_bases_only && !PassRaidableBasesCheck(player, Buff.Trap_Spotter)) return;

            BuffDetails bd;
            float value;
            if (!GetBuffDetails(player.userID, out bd) || !bd.GetBuff(Buff.Trap_Spotter, out value))
            {
                Player.Message(player, lang.GetMessage("TrapSpotterNotUnlocked", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }

            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;

            if (playerData.Trap_Spotter_used_time.AddSeconds(config.buff_settings.raid_perk_settings.Trap_Spotter_settings.cooldown) > DateTime.Now)
            {
                var endTime = playerData.Trap_Spotter_used_time.AddSeconds(config.buff_settings.raid_perk_settings.Trap_Spotter_settings.cooldown);
                TimeSpan span = endTime.Subtract(DateTime.Now);
                Player.Message(player, string.Format(lang.GetMessage("TrapSpotterCooldownReminder", this, player.UserIDString), span.TotalMinutes > 1 ? Math.Round(span.TotalMinutes, 0) + " minutes" : Math.Round(span.TotalSeconds, 0) + " seconds"), config.misc_settings.ChatID);
                return;
            }
            playerData.Trap_Spotter_used_time = DateTime.Now;

            var wasAdmin = player.IsAdmin;
            if (!wasAdmin)
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                player.SendNetworkUpdateImmediate();
            }

            var entities = FindEntitiesOfType<BaseCombatEntity>(player.transform.position, config.buff_settings.raid_perk_settings.Trap_Spotter_settings.distance);
            foreach (var entity in entities)
            {
                if (!IsTrap(entity)) continue;
                if (value < 1 && !RollSuccessful(value)) continue;

                float[] cols = config.buff_settings.raid_perk_settings.Trap_Spotter_settings.show_names ? TrapDisplayColour(entity.ShortPrefabName) : DefaultSpotterCol;
                player.SendConsoleCommand("ddraw.text", config.buff_settings.raid_perk_settings.Trap_Spotter_settings.time_on_screen, new Color(cols[0], cols[1], cols[2]), entity.transform.position, config.buff_settings.raid_perk_settings.Trap_Spotter_settings.show_names ? TrapDisplayName(entity.ShortPrefabName, player.UserIDString) : lang.GetMessage("Trap", this, player.UserIDString));
            }

            if (!wasAdmin)
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                player.SendNetworkUpdateImmediate();
            }

            Pool.FreeUnmanaged(ref entities);
        }

        string TrapDisplayName(string shortname, string id)
        {
            switch (shortname)
            {
                case "flameturret.deployed":
                case "autoturret_deployed":
                case "spikes.floor":
                case "teslacoil.deployed":
                case "beartrap":
                case "landmine":
                case "guntrap.deployed":
                    return lang.GetMessage(shortname, this, id);
                default: return lang.GetMessage("Trap", this, id);
            }
        }

        float[] TrapDisplayColour(string shortname)
        {
            float[] cols;
            if (config.buff_settings.raid_perk_settings.Trap_Spotter_settings.trap_colours.TryGetValue(shortname, out cols) && cols.Length >= 3) return cols;
            return DefaultSpotterCol;
        }

        float[] DefaultSpotterCol = new float[3] { 0.702f, 0.082f, 0.298f };

        Dictionary<string, float[]> DefaultSpotterCols
        {
            get
            {
                return new Dictionary<string, float[]>()
                {
                    ["flameturret.deployed"] = new float[3] { 0.851f, 0.514f, 0.055f },
                    ["autoturret_deployed"] = new float[3] { 0.463f, 0.506f, 0.522f },
                    ["spikes.floor"] = new float[3] { 0.741f, 0.592f, 0.604f },
                    ["teslacoil.deployed"] = new float[3] { 0.165f, 0.675f, 0.741f },
                    ["beartrap"] = new float[3] { 0.835f, 0.902f, 0.173f },
                    ["landmine"] = new float[3] { 0.969f, 0.286f, 0.847f },
                    ["guntrap.deployed"] = new float[3] { 0.357f, 0.969f, 0.286f },
                };
            }
        }

        #endregion

        #region Loot_Spotter

        void SearchForLootConsoleCMD(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null) SearchForLoot(player);
        }

        void SearchForLoot(BasePlayer player)
        {
            if (!player.IsAdmin && !player.IsDeveloper && player.IsFlying)
            {
                Player.Message(player, "You cannot use this command while in noclip.", config.misc_settings.ChatID);
                return;
            }

            if (config.buff_settings.raid_perk_settings.Loot_Spotter_settings.raidable_bases_only && !PassRaidableBasesCheck(player, Buff.Loot_Spotter)) return;

            BuffDetails bd;
            float value;
            if (!GetBuffDetails(player.userID, out bd) || !bd.GetBuff(Buff.Loot_Spotter, out value))
            {
                Player.Message(player, lang.GetMessage("LootSpotterNotUnlocked", this, player.UserIDString), config.misc_settings.ChatID);
                return;
            }

            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;

            if (playerData.Loot_Spotter_used_time.AddSeconds(config.buff_settings.raid_perk_settings.Loot_Spotter_settings.cooldown) > DateTime.Now)
            {
                var endTime = playerData.Loot_Spotter_used_time.AddSeconds(config.buff_settings.raid_perk_settings.Loot_Spotter_settings.cooldown);
                TimeSpan span = endTime.Subtract(DateTime.Now);
                Player.Message(player, string.Format(lang.GetMessage("TrapSpotterCooldownReminder", this, player.UserIDString), span.TotalMinutes > 1 ? Math.Round(span.TotalMinutes, 0) + " minutes" : Math.Round(span.TotalSeconds, 0) + " seconds"), config.misc_settings.ChatID);
                return;
            }
            playerData.Loot_Spotter_used_time = DateTime.Now;

            var wasAdmin = player.IsAdmin;
            if (!wasAdmin)
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                player.SendNetworkUpdateImmediate();
            }

            var entities = FindEntitiesOfType<BoxStorage>(player.transform.position, value);
            var col = config.buff_settings.raid_perk_settings.Loot_Spotter_settings.GetColour();
            foreach (var entity in entities)
            {
                player.SendConsoleCommand("ddraw.text", config.buff_settings.raid_perk_settings.Loot_Spotter_settings.time_on_screen, col, entity.transform.position, config.buff_settings.raid_perk_settings.Loot_Spotter_settings.show_names ? lang.GetMessage(entity.ShortPrefabName, this, player.UserIDString) : lang.GetMessage("Container", this, player.UserIDString));
            }

            if (!wasAdmin)
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                player.SendNetworkUpdateImmediate();
            }

            Pool.FreeUnmanaged(ref entities);
        }        

        #endregion

        #region Harmony

        private void Loaded()
        {
            Saving = Pool.Get<List<KeyValuePair<ulong, PlayerInfo>>>();
            LoadData();
        }

        bool ShieldPatchActive = false;
        bool HandlingRebound = false;

        [AutoPatch]
        [HarmonyPatch(typeof(Shield), "ServerSideAttack")]
        internal class Shield_Patch
        {
            [HarmonyPrefix]
            private static bool Prefix(Shield __instance, HitInfo info)
            {
                if (!Instance.ShieldPatchActive) return true;
                if (info?.damageTypes == null) return true;
                var player = __instance.GetOwnerPlayer();
                if (player == null)
                    return true;

                if (info.InitiatorPlayer == null) return true;

                if (!Instance.buffDetails.TryGetValue(player.userID, out var bd) || !bd.GetBuff(Buff.Shield_Reflect, out var value)) return true;
                if (UnityEngine.Random.Range(0f, 1f) > value) return true;
                if (Instance.config.buff_settings.shield_ReflectSettings.maxDistance > -1 && !InRange(player.transform.position, info.InitiatorPlayer.transform.position, Instance.config.buff_settings.shield_ReflectSettings.maxDistance))
                    return true;

                var damageType = info.damageTypes.GetMajorityDamageType();

                switch (damageType)
                {
                    case DamageType.Bullet:
                        if (Instance.config.buff_settings.shield_ReflectSettings.bulletReflectMod > 0) info.damageTypes.ScaleAll(Instance.config.buff_settings.shield_ReflectSettings.bulletReflectMod);
                        else return true;
                        break;

                    case DamageType.Arrow:
                        if (Instance.config.buff_settings.shield_ReflectSettings.arrowReflectMod > 0) info.damageTypes.ScaleAll(Instance.config.buff_settings.shield_ReflectSettings.arrowReflectMod);
                        else return true;
                        break;

                    default: return true;
                }

                Instance.HandlingRebound = true;
                info.InitiatorPlayer.Hurt(info.damageTypes.Total(), damageType, player, true);
                Instance.HandlingRebound = false;

                return true;
            }
        }


        [AutoPatch]
        [HarmonyPatch(typeof(MetalDetectorSource), "CreateFlag")]
        internal class Item_SplitItem_Patch
        {
            [HarmonyPrefix]
            private static bool Prefix(MetalDetectorSource __instance, Vector3 pos)
            {
                var players = FindEntitiesOfType<BasePlayer>(pos, 1);
                if (players.Count == 0)
                {
                    Pool.FreeUnmanaged(ref players);
                    return true;
                }

                var player = players[0];
                Pool.FreeUnmanaged(ref players);

                if (!Instance.GetBuffDetails(player.userID, out var buffData) || !buffData.GetBuff(Buff.Efficient_Digger, out var value) || !Instance.RollSuccessful(value)) return true;

                var diggable = GameManager.server.CreateEntity(__instance.FlagPrefab.resourcePath, pos, Quaternion.Euler(0f, UnityEngine.Random.Range(0, 360), 0f)) as BaseDiggableEntity;
                diggable.Spawn();
                Effect.server.Run(__instance.EffectPrefab.resourcePath, pos + Vector3.up * 0.1f, Vector3.up);
                diggable.digsRemaining = 0;
                diggable.Dig(player);
                return false;
            }
        }

        [AutoPatch]
        [HarmonyPatch(typeof(BaseDiggableEntity), "OnFullyDug")]
        internal class OnFullyDug_Patch
        {
            [HarmonyPrefix]
            private static bool Prefix(BaseDiggableEntity __instance, BasePlayer player)
            {
                if (player == null || !Instance.GetBuffDetails(player.userID, out var buffData)) return true;

                if (buffData.GetBuff(Buff.Metal_Detector_Luck, out var value) && Instance.RollSuccessful(value))
                {
                    var randProfile = Instance.RollLootItem(Instance.config.loot_settings.metal_detector_loot_table);
                    if (randProfile != null)
                    {
                        var item = ItemManager.CreateByName(randProfile.shortname, Math.Max(UnityEngine.Random.Range(randProfile.min, randProfile.max + 1), 1), randProfile.skin);
                        if (!string.IsNullOrEmpty(randProfile.displayName)) item.name = randProfile.displayName;

                        var droppedItem = item.Drop(__instance.transform.position + __instance.DropOffset, __instance.DropVelocity) as DroppedItem;
                        if (droppedItem != null)
                        {
                            droppedItem.NeverCombine = true;
                            droppedItem.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)) * 720f);
                        }

                        if (Instance.config.notification_settings.chatMessageNotificationSettings.Metabolism_Share_Notify)
                        {
                            if (Instance.NotificationsOn(player)) Instance.Player.Message(player, string.Format(Instance.lang.GetMessage("Metal_Detector_Luck_Found_Item", Instance, player.UserIDString), item.amount, item.name ?? item.info.displayName.english), Instance.config.misc_settings.ChatID);
                        }
                    }
                }
                // 47180
                if (buffData.GetBuff(Buff.Magnetic_Digger, out value) && Instance.RollSuccessful(value))
                {
                    var dItem = __instance.SpawnLootListItem(player) as DroppedItem;
                    if (dItem == null) return true;

                    var pickupItem = dItem.item;
                    dItem.RemoveItem();
                    player.GiveItem(pickupItem, BaseEntity.GiveItemReason.PickedUp);
                    return false;
                }
                return true;
            }
        }

        [AutoPatch]
        [HarmonyPatch(typeof(BaseFishingRod), "Server_RequestCast")]
        internal class FishingRod_Cast_Patch
        {
            [HarmonyPostfix]
            private static void Postfix(BaseFishingRod __instance, ref TimeUntil ___catchTime)
            {
                try
                {
                    if (__instance == null) return;
                    var player = __instance.GetOwnerPlayer();
                    BuffDetails bd;
                    if (!Instance.GetBuffDetails(player.userID, out bd)) return;
                    float value;

                    if (bd.GetBuff(Buff.Bite_Speed, out value))
                    {
                        ___catchTime = (TimeUntil)Mathf.Max(___catchTime - (___catchTime * value), 0.1f);
                    }
                    if (bd.GetBuff(Buff.Rod_Tension_Bonus, out value)) Instance.ApplyRodStrength(__instance, value);
                }
                catch { }
            }
        }

        [AutoPatch]
        [HarmonyPatch(typeof(Recycler), "StopRecycling")]
        internal class StopRecycling_Patch
        {
            [HarmonyPostfix]
            private static void Postfix(Recycler __instance)
            {
                if (__instance == null) return;
                Instance.ResetRecyclerEfficiency(__instance.net.ID.Value, null, true);
            }
        }

        [AutoPatch]
        [HarmonyPatch(typeof(BasePlayer), "RadiationProtection")]
        internal class RadiationProtection_Patch
        {
            [HarmonyPostfix]
            private static void Postfix(BasePlayer __instance, ref float __result)
            {
                if (__instance == null || !__instance.userID.IsSteamId() || __instance.baseProtection == null || !Instance.GetBuffDetails(__instance.userID, out var buffData)) return;

                var baseRadProtection = __instance.baseProtection.amounts[17] * 100f;
                float result = 0;
                if (buffData.GetBuff(Buff.RadiationBaseValue, out var value)) result += value * 100;
                if (buffData.GetBuff(Buff.RadiationResistModifier, out value)) result += (baseRadProtection * value);
                __result += result;
            }
        }

        [AutoPatch]
        [HarmonyPatch(typeof(ItemModContainerArmorSlot), "CreateForPlayer")]
        internal class ItemModContainerArmorSlot_Patch
        {
            [HarmonyPrefix]
            private static bool Prefix(ItemModContainerArmorSlot __instance, Item item, BasePlayer player)
            {
                if (player == null || !Instance.GetBuffDetails(player.userID, out var bd) || !bd.GetBuff(Buff.Armor_Slots, out var value) || value <= 0) return true;

                var cap = ItemModContainerArmorSlot.GetRandomSlotCount(Mathf.Clamp01(player.modifiers.GetValue(Modifier.ModifierType.Crafting_Quality)), __instance.MinSlots, __instance.MaxSlots);
                if (cap < value) cap = Mathf.RoundToInt(value);

                __instance.CreateAtCapacity(cap, item);
                return false;
            }
        }

        private float[] RollChances = new float[]
        {
            0.3f,
            0.2f,
            0.1f,
            0.05f
        };

        float GetChanceReq(float slots)
        {
            switch (slots)
            {
                case float n when n >= 0 && n < 2: return 0.5f;
                case float n when n >= 2 && n < 3: return 0.3f;
                case float n when n >= 3 && n < 4: return 0.2f;
                case float n when n >= 4 && n < 5: return 0.1f;
                case float n when n >= 5 && n < 6: return 0.05f;
                default: return 1;
            }
        }

        #endregion

        #region Prestige

        [ConsoleCommand("addprestigelevel")]
        void SetPrestigeLevel(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, perm_admin)) return;

            if (arg.Args == null || arg.Args.Length < 1)
            {
                arg.ReplyWith($"Usage: addprestigelevel <target>");
                return;
            }

            string criteria = string.Join(" ", arg.Args);
            var target = BasePlayer.Find(criteria) ?? FindPlayerByName(criteria, player);
            if (target == null)
            {
                arg.ReplyWith($"No player matched {criteria}");
                return;
            }

            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(target.userID, out playerData)) return;

            CheckPrestigeGroups(target, playerData.prestige_level + 1, target.IsConnected ? true : false);

            arg.ReplyWith($"Set {target.displayName}'s prestige level to {playerData.prestige_level}");
        }

        void CreatePrestigeGroups()
        {
            foreach (var level in config.prestige_settings.levels)
            {
                var groupString = $"prestige_{level.Key}";
                if (!permission.GroupExists(groupString)) permission.CreateGroup(groupString, "", 0);
                //if (!parent.IsNullOrEmpty())
                //{
                //    // sets perms to inherit from parent
                //    permission.SetGroupParent(groupString, parent);
                //    parent = groupString;
                //}
                //else parent = groupString;
                foreach (var perm in level.Value.perms)
                {
                    if (!permission.GroupHasPermission(groupString, perm.Value)) permission.GrantGroupPermission(groupString, perm.Value, null);
                }
            }
        }

        void CheckPrestigeGroups(BasePlayer player, int presLevel, bool handleInstance)
        {
            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;
            playerData.prestige_level = presLevel;
            foreach (var level in config.prestige_settings.levels)
            {
                if (level.Key > presLevel) continue;
                if (level.Key < presLevel && config.prestige_settings.remove_from_lower_groups)
                {
                    if (permission.UserHasGroup(player.UserIDString, $"prestige_{level.Key}")) permission.RemoveUserGroup(player.UserIDString, $"prestige_{level.Key}");
                    continue;
                }
                if (!permission.UserHasGroup(player.UserIDString, $"prestige_{level.Key}")) permission.AddUserGroup(player.UserIDString, $"prestige_{level.Key}");
            }

            if (!handleInstance) return;
            CuiHelper.DestroyUi(player, "SkillTree");
            CuiHelper.DestroyUi(player, "respec_confirmation");
            CuiHelper.DestroyUi(player, "SkillTreeBackPanel");
            CuiHelper.DestroyUi(player, "NavigationMenu");
            CuiHelper.DestroyUi(player, "PrestigeConfirmation");
            DoClear(player, true);
            LoggingOff(player, true);
            HandleNewConnection(player);

            Puts($"You have achieved Prestige rank {presLevel}");
        }

        void RemovePrestigeGroup(string userid, int level)
        {
            foreach (var kvp in config.prestige_settings.levels)
            {
                if (kvp.Key > level) continue;
                string groupName = $"prestige_{kvp.Key}";
                if (permission.GroupExists(groupName)) permission.RemoveUserGroup(userid, groupName);
            }
        }

        void ClearPrestigeGroup()
        {
            List<string> groupUsers = Pool.Get<List<string>>();
            foreach (var group in permission.GetGroups())
            {
                if (!group.StartsWith("prestige_")) continue;

                groupUsers.AddRange(permission.GetUsersInGroup(group));
                foreach (var id in groupUsers)
                {
                    permission.RemoveUserGroup(id.Split(' ')[0], group);
                }

                groupUsers.Clear();
            }
            Pool.FreeUnmanaged(ref groupUsers);
        }

        string GetPrestigeBetterChatTitle(ulong id, PlayerInfo playerData)
        {
            if (playerData.prestige_level == 0) return string.Empty;
            KeyValuePair<int, Configuration.PrestigeSettings.PrestigeInfo> highest = new KeyValuePair<int, Configuration.PrestigeSettings.PrestigeInfo>(0, null);
            foreach (var kvp in config.prestige_settings.levels)
            {
                if (kvp.Key <= playerData.prestige_level && kvp.Key > highest.Key)
                {
                    highest = kvp;
                }
            }

            return !string.IsNullOrEmpty(highest.Value.better_title_format) ? string.Format(highest.Value.better_title_format, highest.Value.better_title_default_col, highest.Key) : string.Empty;
        }

        [ConsoleCommand("stincreaseprestigepage")]
        void IncreasePrestige(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            int nextLevel = Convert.ToInt32(arg.Args[0]);
            bool hasLevel = Convert.ToBoolean(arg.Args[1]);

            PrestigeConfirmation(player, nextLevel, hasLevel);
        }

        int _HighestPrestigeLevel = -1;
        int GetHighestPrestigeLevel
        {
            get
            {
                if (_HighestPrestigeLevel > -1) return _HighestPrestigeLevel;
                var highest = 0;
                foreach (var level in config.prestige_settings.levels.Keys)
                    if (level > highest) highest = level;

                _HighestPrestigeLevel = highest;
                return highest;
            }
        }

        #region UI

        (string, int) GetPrestigeBenefits(BasePlayer player, Configuration.PrestigeSettings.PrestigeInfo prestigeData)
        {
            var count = 0;
            StringBuilder sb = new StringBuilder();
            if (prestigeData.perms != null)
            {
                foreach (var description in prestigeData.perms.Keys)
                {
                    sb.AppendLine($"<color=#ece209>-</color> {lang.GetMessage(description, this, player.UserIDString)}.");
                    count++;
                }
            }

            if (prestigeData.commands != null)
            {
                foreach (var description in prestigeData.commands.Keys)
                {
                    sb.AppendLine($"<color=#ece209>-</color> {lang.GetMessage(description, this, player.UserIDString)}.");
                    count++;
                }
            }

            foreach (var benefit in prestigeData.additionalBenfitsDescription)
            {
                sb.AppendLine($"<color=#ece209>-</color> {lang.GetMessage(benefit, this, player.UserIDString)}.");
                count++;
            }

            return (sb.ToString(), count);
        }

        private void PrestigeConfirmation(BasePlayer player, int nextLevel, bool hasLevel)
        {
            Configuration.PrestigeSettings.PrestigeInfo prestigeData;
            if (!config.prestige_settings.levels.TryGetValue(nextLevel, out prestigeData)) return;
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0 0 0 1" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0.068 0.342", OffsetMax = "-0.032 0.342" }
            }, "Overlay", "PrestigeConfirmation");

            container.Add(new CuiElement
            {
                Name = "title",
                Parent = "PrestigeConfirmation",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIPrestige", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 26, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-180 119.6", OffsetMax = "180 179.6" }
                }
            });

            var benefits = GetPrestigeBenefits(player, prestigeData);

            container.Add(new CuiElement
            {
                Name = "STPrestigeScrollPanelAnchor",
                Parent = "title",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0 0 0 1" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-158.489 -313.25", OffsetMax = "158.491 -60" }
                }
            });

            int threshold = 9;

            if (benefits.Item2 > threshold)
            {
                container.Add(new CuiElement
                {
                    Name = "STPrestigeScrollElement",
                    Parent = "STPrestigeScrollPanelAnchor",
                    Components = {
                    new CuiScrollViewComponent {
                        MovementType = UnityEngine.UI.ScrollRect.MovementType.Elastic,
                        Vertical = true,
                        Inertia = true,
                        Horizontal = false,
                        Elasticity = 0.25f,
                        DecelerationRate = 0.3f,
                        ScrollSensitivity = 24f,
                        ContentTransform = new CuiRectTransform { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "0 " + benefits.Item2 * 21 * -1 , OffsetMax = "0 0" },
                    },
                    new CuiNeedsCursorComponent()
                }
                });

                container.Add(new CuiPanel()
                {
                    Image = { Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
                }, "STPrestigeScrollElement", "STPrestigeScrollElement_AREA");
            }

            container.Add(new CuiElement
            {
                Name = "text",
                Parent = benefits.Item2 > threshold ? "STPrestigeScrollElement_AREA" : "STPrestigeScrollPanelAnchor",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIPrestigeExplain", this, player.UserIDString) + benefits.Item1 + (prestigeData.xp_mod != 1 ? string.Format(lang.GetMessage("UIPrestigeXPMod", this, player.UserIDString), Math.Round(prestigeData.xp_mod * 100, 2)) : ""), Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-158.493 {-253.626 - (benefits.Item2 > threshold ? 21 * (benefits.Item2 - 12) : 0)}", OffsetMax = "158.491 -0.375" }
                }
            });

            if (hasLevel)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = "confirmprestige" },
                    Text = { Text = lang.GetMessage("UICONFIRM", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.07280672 1 0 1" },
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-80.001 -29.625", OffsetMax = "-20.001 0.375" }
                }, "STPrestigeScrollPanelAnchor", "Confirm");
            }

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = "closeprestige" },
                Text = { Text = lang.GetMessage("UICANCEL", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 0.3820755 0.3820755 1" },
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "19.999 -29.625", OffsetMax = "79.999 0.375" }
            }, "STPrestigeScrollPanelAnchor", "Cancel");

            if (nextLevel == 1 && config.prestige_settings.levels.TryGetValue(nextLevel, out var firstLevelData))
            {
                container.Add(new CuiElement
                {
                    Name = "FirstPrestige",
                    Parent = "PrestigeConfirmation",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 1", ItemId = 1776460938, SkinId = firstLevelData.RankUpPic },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-50 182.8", OffsetMax = "50 282.8" }
                }
                });
            }
            else if (nextLevel > 1 && nextLevel <= config.prestige_settings.HighestLevel() && config.prestige_settings.levels.TryGetValue(nextLevel - 1, out var currentLevelData) && config.prestige_settings.levels.TryGetValue(nextLevel, out var nextLevelData))
            {
                container.Add(new CuiElement
                {
                    Name = "CurrentPrestige",
                    Parent = "PrestigeConfirmation",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 1", ItemId = 1776460938, SkinId = currentLevelData.RankUpPic },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-180 179.6", OffsetMax = "-80 279.6" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "PrestigeArrow",
                    Parent = "PrestigeConfirmation",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 1", Sprite = "assets/icons/arrow_right.png" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-32 197.6", OffsetMax = "32 261.6" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "NextPrestige",
                    Parent = "PrestigeConfirmation",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 1", ItemId = 1776460938, SkinId = nextLevelData.RankUpPic },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "80 182.8", OffsetMax = "180 282.8" }
                }
                });
            }

            CuiHelper.DestroyUi(player, "PrestigeConfirmation");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("closeprestige")]
        void ClosePrestigeMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, "PrestigeConfirmation");
        }

        [ConsoleCommand("confirmprestige")]
        void ConfirmPrestigeMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            PlayerInfo playerData;
            if (!pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;

            if (playerData.current_level < config.general_settings.max_player_level) return;

            CuiHelper.DestroyUi(player, "SkillTree");
            CuiHelper.DestroyUi(player, "respec_confirmation");
            CuiHelper.DestroyUi(player, "SkillTreeBackPanel");
            CuiHelper.DestroyUi(player, "NavigationMenu");
            CuiHelper.DestroyUi(player, "PrestigeConfirmation");

            int excessPoints = 0;
            if (config.prestige_settings.should_keep_excess_points) excessPoints = CalculateExcessPoints(player, playerData);

            int newPrestigeLevel = playerData.prestige_level + 1;

            if (playerData.pouch_items != null & playerData.pouch_items.Count > 0)
            {
                var bag = GenerateBag(player, playerData.pouch_items.Count + 1);
                if (bag.inventory?.itemList != null)
                {
                    List<Item> giveItems = Pool.Get<List<Item>>();
                    giveItems.AddRange(bag.inventory.itemList);

                    foreach (var item in giveItems)
                    {
                        GiveItem(player, item);
                        //player.GiveItem(item);
                    }
                    playerData.pouch_items.Clear();
                    Pool.FreeUnmanaged(ref giveItems);
                    Player.Message(player, lang.GetMessage("PouchItemsRemoved", this, player.UserIDString), config.misc_settings.ChatID);
                }
            }

            if (config.misc_settings.presetSettings.enabled && !string.IsNullOrEmpty(playerData.presets?.activePreset))
            {
                SaveProfile(player, playerData, playerData.presets.activePreset);
                playerData.presets.activePreset = null;
            }

            DoClear(player, true);

            if (config.prestige_settings.run_level_rewards_reset_on_Prestige) RunResetCommands(player.UserIDString, playerData.prestige_level > 0 ? GetHighestLevelReward : Math.Max(playerData.current_level, playerData.achieved_level));

            if (TreeData.ContainsKey(player.userID)) TreeData.Remove(player.userID);
            buffDetails.Remove(player.userID);

            Configuration.PrestigeSettings.PrestigeInfo prestigeData;
            if (config.prestige_settings.levels.TryGetValue(newPrestigeLevel, out prestigeData))
            {
                AchievedRank(player, prestigeData.RankUpPic, prestigeData.rankTitle);
                HandlePrestigeCommands(player, prestigeData.commands);
            }

            playerData.xp = 0;
            playerData.prestige_level = newPrestigeLevel;
            playerData.achieved_level = 0;
            playerData.current_level = 0;
            playerData.available_points = 0;
            playerData.buff_values.Clear();
            playerData.pouch_items.Clear();
            playerData.logged_off = DateTime.Now;
            playerData.xp_bonus_pool = 0;
            playerData.respec_multiplier = 0;
            playerData.xp_debt = 0;
            playerData.last_xp_loss = DateTime.MinValue;
            playerData.ultimate_settings.Clear();
            playerData.respec_multiplier = 0;
            playerData.xp_debt = 0;
            playerData.pending_xp_without_bonus = 0;
            playerData.pending_xp_with_bonus = 0;
            playerData.non_level_related_points_given = 0;

            CheckPrestigeGroups(player, newPrestigeLevel, false);
            LoggingOff(player, true);

            HandleNewConnection(player);
            LoadBuffs();

            GiveSkillPoints(player, excessPoints);            

            if (config.notification_settings.discordSettings.send_prestige_up) SendDiscordMsg(string.Format(lang.GetMessage("PrestigeEarnDiscord", this), player.displayName, player.UserIDString, playerData.prestige_level));
            Interface.Oxide.CallHook("STOnPlayerPrestigeLevelled", player, newPrestigeLevel);
            if (config.notification_settings.notificationSystemSettings.SendPrestigLevelRewards && prestigeData != null)
            {
                var benefits = GetPrestigeBenefits(player, prestigeData);
                SendNotificationSystemMsg(player.userID,
                    string.Format(lang.GetMessage("NSPrestigeTitle", this, player.UserIDString), newPrestigeLevel),
                    string.Format(lang.GetMessage("NSPrestigeBody", this, player.UserIDString), newPrestigeLevel, benefits.Item1));
            }
        }

        void HandlePrestigeCommands(BasePlayer player, Dictionary<string, string> commands)
        {
            if (commands == null) return;
            foreach (var command in commands.Values)
            {
                try
                {
                    var str = command.Replace("{id}", player.UserIDString).Replace("{name}", player.displayName);
                    Server.Command(str);
                }
                catch
                {
                    Puts($"Failed to run command: {command} for {player.userID}");
                }
            }    
        }

        int CalculateExcessPoints(BasePlayer player, PlayerInfo playerData)
        {
            var min = (playerData.achieved_level * GetPointsPerLevel(player.UserIDString)) + GetStartingSkillPoints(player.UserIDString);
            int has = playerData.available_points;
            foreach (var skill in playerData.buff_values)
                has += skill.Value;

            return Math.Max(0, has - min);
        }

        private void AchievedRank(BasePlayer player, ulong skin, string title)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0 0 0 1" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, "Overlay", "AchievedRank");

            container.Add(new CuiElement
            {
                Name = "img",
                Parent = "AchievedRank",
                Components = {
                    new CuiImageComponent { Color = "1 1 1 1", ItemId = 1776460938, SkinId = skin },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-75 60", OffsetMax = "75 210" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Text",
                Parent = "AchievedRank",
                Components = {
                    new CuiTextComponent { Text = $"NEW RANK ACHIEVED:\n<size=26><color=#a809b0>{lang.GetMessage(title, this, player.UserIDString)}</color></size>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.UpperCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-180 -51.333", OffsetMax = "180 60" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = "closerankup" },
                Text = { Text = lang.GetMessage("UIClose", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-30 -81.333", OffsetMax = "30 -51.333" }
            }, "AchievedRank", "Button_6584");

            CuiHelper.DestroyUi(player, "AchievedRank");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("closerankup")]
        void CloseRankUp(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, "AchievedRank");
        }

        #endregion

        #endregion

        #region Comfort

        void DestroyComfortSkill(BasePlayer player)
        {
            var skillComponent = player?.gameObject?.GetComponent<ComfortManager>();
            if (skillComponent != null) GameObject.Destroy(skillComponent);
        }

        void AddComfortSkill(BasePlayer player, float value)
        {
            var existingComponent = player.GetComponent<ComfortManager>();
            if (existingComponent != null)
            {
                existingComponent.UpdateComfortAmount(value);
                return;
            }

            var component = player.gameObject.AddComponent<ComfortManager>();

            component.ComfortAmount = value;
            component.Interval = config.buff_settings.comfortSettings.Interval;
            component.Distance = config.buff_settings.comfortSettings.Distance;

            if (DisabledPlayers.Contains(player.userID)) component.SetBlocked(true);
            component.InitializeComfort();
        }

        void SetComfortBlock(BasePlayer player, bool shouldBlock)
        {
            if (!buffDetails.TryGetValue(player.userID, out var bd) || !bd.ContainsBuff(Buff.Comfort)) return;

            var gameObject = player.GetComponent<ComfortManager>();
            if (gameObject == null) return;
            gameObject.SetBlocked(shouldBlock);
        }

        public class ComfortManager : MonoBehaviour
        {
            private BasePlayer player;
            public float Interval;
            private float Delay;
            public float ComfortAmount = 1;
            public float Distance = 10;
            public bool Blocked;
            public bool BlockActioned;
            private bool Started = false;

            private TriggerComfort comfortTrigger;
            private List<BasePlayer> comfortedPlayers = Pool.Get<List<BasePlayer>>();

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                Delay = Time.time + 1f;
            }

            public void InitializeComfort()
            {
                AddComfort();
                Started = true;
            }

            public void FixedUpdate()
            {
                if (!Started) return;
                if (player == null || !player.IsConnected)
                {
                    Destroy(this);
                    return;
                }
                if (Delay < Time.time)
                {
                    Delay = Time.time + Interval;
                    if (Blocked)
                    {
                        if (!BlockActioned)
                        {
                            RemoveComfort();
                            BlockActioned = true;
                        }
                        return;
                    }
                    if (comfortTrigger == null) AddComfort();
                    ComfortPlayers();
                }
            }

            public void UpdateComfortAmount(float amount)
            {
                ComfortAmount = amount;
                comfortTrigger.baseComfort = amount;
            }

            private void AddComfort()
            {
                comfortTrigger = player.gameObject.AddComponent<TriggerComfort>();
                comfortTrigger.baseComfort = ComfortAmount;
                player.EnterTrigger(comfortTrigger);
            }

            public void SetBlocked(bool shouldBlock)
            {
                BlockActioned = false;
                Blocked = shouldBlock;
            }

            private void ComfortPlayers()
            {
                var hits = FindNearbyTeamMates(player, Distance);
                hits.Remove(player);
                //hits.Remove(player);
                comfortedPlayers.RemoveAll(x => x == null);
                foreach (var hit in comfortedPlayers)
                {
                    if (hit.Team == null || player.Team == null || hit.Team.teamID != player.Team.teamID || !hits.Contains(hit))
                    {
                        hit.LeaveTrigger(comfortTrigger);
                        comfortTrigger.OnEntityLeave(hit);
                    }
                }
                comfortedPlayers.Clear();
                foreach (var hit in hits)
                {
                    if ((hit.triggers.IsNullOrEmpty() || !hit.triggers.Contains(comfortTrigger)) && (hit.Team != null && player.Team != null && hit.Team.teamID == player.Team.teamID))
                        hit.EnterTrigger(comfortTrigger);
                }
                comfortedPlayers.AddRange(hits);
                Pool.FreeUnmanaged(ref hits);
            }

            private void RemoveComfort()
            {
                try
                {
                    player.triggers.Remove(comfortTrigger);
                }
                catch { }
                if (comfortTrigger == null && (comfortTrigger = player.gameObject.GetComponent<TriggerComfort>()) == null) return;
                comfortTrigger.OnEntityLeave(player);
                comfortedPlayers.RemoveAll(x => x == null);
                foreach (var p in comfortedPlayers)
                    p.LeaveTrigger(comfortTrigger);

                comfortedPlayers.Clear();
                GameObject.Destroy(player.gameObject.GetComponent<TriggerComfort>());
            }

            private void OnDestroy()
            {
                RemoveComfort();
                Pool.FreeUnmanaged(ref comfortedPlayers);
                enabled = false;
                CancelInvoke();
            }
        }

        #endregion

        #region Mobile Workbench

        void WorkbenchSkillUnload()
        {
            if (Workbench_Level_1 != null && !Workbench_Level_1.IsDestroyed) Workbench_Level_1.Kill();
            if (Workbench_Level_2 != null && !Workbench_Level_2.IsDestroyed) Workbench_Level_2.Kill();
            if (Workbench_Level_3 != null && !Workbench_Level_3.IsDestroyed) Workbench_Level_3.Kill();
        }

        void DestroyMobileWorkbench(BasePlayer player)
        {
            try
            {
                player.nextCheckTime = UnityEngine.Time.realtimeSinceStartup;
                var skillComponent = player?.gameObject?.GetComponent<MobileWorkbenchSkill>();
                if (skillComponent != null) GameObject.Destroy(skillComponent);
            }
            catch { }
        }

        void WorkbenchSkillOnEntityKill(Workbench workbench)
        {
            if (Unloading) return;
            if (workbench == Workbench_Level_1) SpawnWorkbench(1);
            else if (workbench == Workbench_Level_2) SpawnWorkbench(2);
            else if (workbench == Workbench_Level_3) SpawnWorkbench(3);
        }

        void AddWorkbenchSkill(BasePlayer player, int level)
        {
            var existingComponent = player.GetComponent<MobileWorkbenchSkill>();
            if (existingComponent != null)
            {
                if (level != existingComponent.SkillLevel) existingComponent.UpdateSkillLevel(level);
                return;
            }

            var component = player.gameObject.AddComponent<MobileWorkbenchSkill>();

            component.Range = config.buff_settings.mobileWorkbenchSettings.Distance;
            component.Interval = config.buff_settings.mobileWorkbenchSettings.Interval;
            component.SkillLevel = level;

            if (DisabledPlayers.Contains(player.userID)) component.SetBlocked(true);
        }

        Workbench GetWorkbench(int level)
        {
            switch (level)
            {
                case 1: return Workbench_Level_1;
                case 2: return Workbench_Level_2;
                case 3: return Workbench_Level_3;
                default: return Workbench_Level_1;
            }
        }

        Workbench Workbench_Level_1 { get; set; }
        Workbench Workbench_Level_2 { get; set; }
        Workbench Workbench_Level_3 { get; set; }

        ProtectionProperties SetProtections(BaseCombatEntity entity)
        {
            var protection = ScriptableObject.CreateInstance(nameof(ProtectionProperties)) as ProtectionProperties;
            for (int i = 0; i < 25; i++)
                protection.amounts[i] = 1;

            return protection;
        }

        void SpawnWorkbenchs()
        {
            for (int i = 1; i < 4; i++)
            {
                SpawnWorkbench(i);
            }
        }

        void SpawnWorkbench(int level)
        {
            string prefab = $"assets/prefabs/deployable/tier {level} workbench/workbench{level}.deployed.prefab";

            var workbench = GameManager.server.CreateEntity(prefab, config.buff_settings.mobileWorkbenchSettings.MapSpawnPosition) as Workbench;
            if (workbench == null)
            {
                return;
            }
            workbench.enableSaving = false;

            var groundWatch = workbench.GetComponent<GroundWatch>();
            if (groundWatch != null) UnityEngine.Object.Destroy(groundWatch);

            var groundMissing = workbench.GetComponent<DestroyOnGroundMissing>();
            if (groundWatch != null) UnityEngine.Object.Destroy(groundMissing);

            workbench.Spawn();
            workbench.baseProtection = SetProtections(workbench);

            switch (level)
            {
                case 1: Workbench_Level_1 = workbench; break;
                case 2: Workbench_Level_2 = workbench; break;
                case 3: Workbench_Level_3 = workbench; break;
                default: Workbench_Level_1 = workbench; break;
            }
            Puts($"Spawned: {workbench.ShortPrefabName}");
        }

        void SetMobileWorkbenchBlock(BasePlayer player, bool shouldBlock)
        {
            if (!buffDetails.TryGetValue(player.userID, out var bd) || !bd.ContainsBuff(Buff.Human_Workbench)) return;

            var gameObject = player.GetComponent<MobileWorkbenchSkill>();
            if (gameObject == null) return;
            gameObject.SetBlocked(shouldBlock);
        }

        public class MobileWorkbenchSkill : MonoBehaviour
        {
            /* We apply our workbench trigger if they are close, and remove it if they are further away.
             * 
             * 
             */

            private BasePlayer player;
            private float Delay;
            public float Range;
            public float Interval = 5;
            public int SkillLevel;
            public Dictionary<BasePlayer, TriggerWorkbench> TrackedPlayers = new Dictionary<BasePlayer, TriggerWorkbench>();
            private bool Blocked;
            private bool BlockActioned;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                Delay = Time.time + 1f;
            }

            public void FixedUpdate()
            {
                if (player == null || !player.IsConnected)
                {
                    Destroy(this);
                    return;
                }
                if (Delay < Time.time)
                {
                    Delay = Time.time + Interval;
                    if (Blocked)
                    {
                        if (!BlockActioned)
                        {
                            foreach (var _player in TrackedPlayers)
                                RemoveTriggerFromPlayer(_player.Key, _player.Value);

                            BlockActioned = true;
                        }
                        return;
                    }
                    CheckExistingPlayers();
                    CheckForNewPlayers();
                    RunLogic();
                }
            }

            public void SetBlocked(bool shouldBlocK)
            {
                BlockActioned = false;
                Blocked = shouldBlocK;
            }

            public void UpdateSkillLevel(int level)
            {
                SkillLevel = level;
                for (int i = TrackedPlayers.Count - 1; i >= 0; i--)
                {
                    var _player = TrackedPlayers.ElementAt(i);
                    RemoveTriggerFromPlayer(_player.Key, _player.Value);
                }
                TrackedPlayers.Clear();
            }

            private void CheckExistingPlayers()
            {
                var hasTeam = player.Team != null && player.Team.members?.Count > 1;
                for (int i = TrackedPlayers.Count - 1; i >= 0; i--)
                {
                    var _player = TrackedPlayers.ElementAt(i);
                    if (_player.Key == null)
                    {
                        TrackedPlayers.Remove(_player.Key);
                        continue;
                    }

                    if (!hasTeam || _player.Key.Team == null || _player.Key.Team.teamID != player.Team.teamID || !InRange(_player.Key.transform.position, player.transform.position, Range) || !_player.Key.IsConnected || _player.Key.IsDead())
                    {
                        if (_player.Key == player) continue;
                        RemoveTriggerFromPlayer(_player.Key, _player.Value);
                        TrackedPlayers.Remove(_player.Key);
                        continue;
                    }
                }
            }

            private void CheckForNewPlayers()
            {
                var hasTeam = player.Team != null && player.Team.members?.Count > 1;
                if (!hasTeam)
                {
                    if (!TrackedPlayers.TryGetValue(player, out var trigger)) TrackedPlayers.Add(player, AddTriggerToPlayer(player));
                    else if (trigger == null || player.triggers.IsNullOrEmpty()) trigger = AddTriggerToPlayer(player);
                    return;
                }

                var nearby = FindNearbyTeamMates(player, Range);
                foreach (var _player in nearby)
                {
                    if (!_player.IsConnected || _player.IsDead() || _player.Team == null || _player.Team.teamID != player.Team.teamID || TrackedPlayers.ContainsKey(_player)) continue;
                    var trigger = AddTriggerToPlayer(_player);
                    TrackedPlayers.Add(_player, trigger);
                }
                Pool.FreeUnmanaged(ref nearby);
            }

            private void RunLogic()
            {
                string error_string = "Error 1";
                try
                {
                    error_string = "Error 2";
                    foreach (var _player in TrackedPlayers)
                    {
                        error_string = "Error 3";
                        TriggerWorkbench highest = _player.Value;
                        error_string = "Error 4";
                        if (_player.Key.triggers != null)
                        {
                            for (int i = _player.Key.triggers.Count - 1; i >= 0; i--)
                            {
                                error_string = $"Error 5 - Loop {i}";
                                var trigger = _player.Key.triggers[i] as TriggerWorkbench;
                                error_string = $"Error 6 - Loop {i}";
                                if (trigger == null || trigger == _player.Value) continue;
                                error_string = $"Error 7 - Loop {i}";
                                if (trigger.WorkbenchLevel() > highest.WorkbenchLevel()) highest = trigger;
                                error_string = $"Error 8 - Loop {i}";
                                if (highest.WorkbenchLevel() > 2) break;
                                error_string = $"Error 9 - Loop {i}";
                            }
                        }

                        error_string = "Error 10";
                        if (highest == _player.Value)
                        {
                            error_string = "Error 11";
                            // player is still highest workbench.
                            if (_player.Key.currentCraftLevel != SkillLevel) SetWorkbenchLevel(_player.Key, SkillLevel);
                            error_string = "Error 12";
                            continue;
                        }
                        error_string = "Error AQpkBQN=";
                        error_string = "Error 13";
                        if (_player.Key.cachedCraftLevel == highest.WorkbenchLevel()) continue; // Player has a higher crafting level than we are providing.

                        error_string = "Error 14";
                        SetWorkbenchLevel(player, highest.WorkbenchLevel());
                        error_string = "Error 15";
                    }
                    error_string = "Error 16";
                }
                catch
                {
                    Interface.Oxide.LogInfo($"Encountered error in RunLogic(). Error: {error_string}");
                }
            }

            private void SetWorkbenchLevel(BasePlayer player, float level)
            {
                player.nextCheckTime = float.MaxValue;
                player.cachedCraftLevel = level;
                SetWorkbenchFlag(player, level);
            }

            private void SetWorkbenchFlag(BasePlayer _player, float level)
            {
                switch (level)
                {
                    case 1:
                        _player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, true);
                        break;

                    case 2:
                        _player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, true);
                        break;

                    case 3:
                        _player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, true);
                        break;
                }
            }

            private FieldInfo OwnerItemUID = typeof(HeldEntity).GetField("ownerItemUID", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));

            private void example(MedicalTool medicalTool)
            {
                var obj = OwnerItemUID.GetValue(medicalTool);
                var ownerItemUID = new ItemId(Convert.ToUInt64(obj));
                OwnerItemUID.SetValue(medicalTool, ownerItemUID.Value + 1);
            }

            // Reflection to get the workbench value.
            private FieldInfo CachedWorkbench = typeof(BasePlayer).GetField("_cachedWorkbench", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));

            private TriggerWorkbench AddTriggerToPlayer(BasePlayer player)
            {
                player.nextCheckTime = float.MaxValue;
                var trigger = player.gameObject.AddComponent<TriggerWorkbench>();
                var workbench = Instance.GetWorkbench(SkillLevel);
                trigger.parentBench = workbench;
                player.EnterTrigger(trigger);
                if (player.cachedCraftLevel < trigger.WorkbenchLevel())
                {
                    player.cachedCraftLevel = trigger.WorkbenchLevel();
                    SetWorkbenchFlag(player, trigger.WorkbenchLevel());
                    CachedWorkbench.SetValue(player, trigger.parentBench);
                }
                return trigger;
            }

            private void RemoveTriggerFromPlayer(BasePlayer player, TriggerWorkbench trigger)
            {
                if (trigger != null)
                {
                    player.LeaveTrigger(trigger);
                    GameObject.Destroy(trigger);
                }
                else
                {
                    trigger = player.gameObject.GetComponent<TriggerWorkbench>();
                    if (trigger != null)
                    {
                        player.LeaveTrigger(trigger);
                        GameObject.Destroy(trigger);
                    }
                }

                //WORKBENCH = null;
                //trigger = null;
                if (!HasOtherTrigger(player))
                {
                    player.nextCheckTime = UnityEngine.Time.realtimeSinceStartup - 1;
                }
            }

            private bool HasOtherTrigger(BasePlayer _player)
            {
                if (_player.triggers == null || _player.triggers.Count == 0) return false;
                for (int i = 0; i < _player.triggers.Count; i++)
                {
                    var trigger = _player.triggers[i] as TriggerWorkbench;
                    if (trigger == null || trigger.name == "WorkbenchSource") continue;
                    return true;
                }
                return false;
            }

            private void OnDestroy()
            {
                foreach (var _player in TrackedPlayers)
                    RemoveTriggerFromPlayer(_player.Key, _player.Value);

                enabled = false;
                CancelInvoke();
            }
        }

        #endregion

        #region ZoneManager

        void OnEnterZone(string ZoneID, BasePlayer player) // Called when a player enters a zone
        {
            if (!config.misc_settings.zoneManagerSettings.NoSkillZones.Contains(ZoneID)) return;
            DisableBuffs(player.userID);
        }

        void OnExitZone(string ZoneID, BasePlayer player) // Called when a player leaves a zone
        {
            if (!config.misc_settings.zoneManagerSettings.NoSkillZones.Contains(ZoneID)) return;
            EnableBuffs(player.userID);
        }

        #endregion

        #region Awareness

        Dictionary<ulong, Awareness> AwarenessPlayers = new Dictionary<ulong, Awareness>();
        void AddAwareness(BasePlayer player, float distance)
        {
            if (AwarenessPlayers.TryGetValue(player.userID, out var gameObject))
            {
                gameObject.checkDistance = distance;
                return;
            }
            gameObject = player.GetComponent<Awareness>();
            if (gameObject == null) gameObject = player.gameObject.AddComponent<Awareness>();
            gameObject.name = "SkillTreeAwareness";
            gameObject.Init(config.buff_settings.awareness_settings.updateRate, distance, config.buff_settings.awareness_settings.corpse, config.buff_settings.awareness_settings.bag, config.buff_settings.awareness_settings.droppedItem, config.buff_settings.awareness_settings.animals, config.buff_settings.awareness_settings.humanNPC);
            AwarenessPlayers.Add(player.userID, gameObject);
        }

        void DestroyAwareness(BasePlayer player)
        {
            if (!AwarenessPlayers.TryGetValue(player.userID, out var gameObject))
            {
                gameObject = player.GetComponent<Awareness>();
                if (gameObject == null) return;
            }
            GameObject.Destroy(gameObject);
            AwarenessPlayers.Remove(player.userID);
        }

        void SetAwarenessBlock(BasePlayer player, bool block)
        {
            if (!AwarenessPlayers.TryGetValue(player.userID, out var gameObject)) return;
            gameObject.ToggleBlocked(block);
        }

        /* Allows players to see certain items around them
         * - Update rate
         * - Object types (corpse, bags, npcs)
         * 
         */
        public class Awareness : MonoBehaviour
        {
            private BasePlayer player;
            public float updateRate;
            private float nextUpdate;
            public float checkDistance;
            public float hudTime;

            public bool checkCorpse;
            public bool checkBags;
            public bool checkDroppedItems;
            public bool checkAnimals;
            public bool checkHumanNPCs;
            List<Display> display = Pool.Get<List<Display>>();

            public bool isBlocked = false;

            public void Init(float updateRate, float distance, bool corpse, bool bags, bool droppedItems, bool animals, bool humannpc)
            {
                this.updateRate = updateRate;
                this.checkDistance = distance;
                this.hudTime = updateRate;
                this.checkCorpse = corpse;
                this.checkBags = bags;
                this.checkDroppedItems = droppedItems;
                this.checkAnimals = animals;
                this.checkHumanNPCs = humannpc;
            }

            private struct Display
            {
                public string displayName;
                public Vector3 pos;
                public Display(string name, Vector3 p)
                {
                    this.displayName = name;
                    this.pos = p;
                }
            }
            public void ToggleBlocked(bool block)
            {
                if (block && !isBlocked) isBlocked = true;
                else if (!block && isBlocked) isBlocked = false;
            }

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                updateRate = 1;
                nextUpdate = Time.time + updateRate;
                checkDistance = 10;
                hudTime = 10;
            }

            public void FixedUpdate()
            {
                if (player == null || !player.IsConnected)
                {
                    Destroy(this);
                    return;
                }
                if (isBlocked) return;
                if (nextUpdate < Time.time)
                {
                    nextUpdate = Time.time + updateRate;
                    FindNearby();
                }
            }

            public void FindNearby()
            {
                var nearby = FindEntitiesOfType<BaseEntity>(player.transform.position, checkDistance);
                foreach (var entity in nearby)
                {
                    AddType(entity);
                }

                var wasAdmin = player.IsAdmin;
                if (!wasAdmin)
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                    player.SendNetworkUpdateImmediate();
                }

                foreach (var entity in display)
                {
                    var msg = string.Format(Instance.lang.GetMessage("AwarenessText", Instance, player.UserIDString), entity.displayName);
                    player.SendConsoleCommand("ddraw.text", hudTime, Color.white, entity.pos, msg);
                }

                if (!wasAdmin)
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                    player.SendNetworkUpdateImmediate();
                }

                display.Clear();
                Pool.FreeUnmanaged(ref nearby);
            }

            private void AddType(BaseEntity entity)
            {
                if (checkCorpse && entity is BaseCorpse) display.Add(new Display(Instance.lang.GetMessage("AwarenessCorpse", Instance, player.UserIDString), entity.transform.position));
                else if (checkBags && entity is DroppedItemContainer) display.Add(new Display(Instance.lang.GetMessage("AwarenessBag", Instance, player.UserIDString), entity.transform.position));
                else if (checkAnimals && (Instance.IsAnimal(entity))) display.Add(new Display(Instance.lang.GetMessage("AwarenessAnimal", Instance, player.UserIDString), entity.transform.position));
                else if (checkHumanNPCs && entity is NPCPlayer) display.Add(new Display(Instance.lang.GetMessage("AwarenessHumannpc", Instance, player.UserIDString), entity.transform.position));
                else if (checkDroppedItems && entity is DroppedItem droppedItem && droppedItem.item != null && !Instance.config.buff_settings.awareness_settings.blacklist.Contains(droppedItem.item.info.shortname))
                    display.Add(new Display(Instance.lang.GetMessage("AwarenessItem", Instance, player.UserIDString), entity.transform.position));
            }

            private void OnDestroy()
            {
                Pool.FreeUnmanaged(ref display);
                enabled = false;
                CancelInvoke();
            }
        }

        #endregion

        #region Profiles

        // Presets will be tracked in data
        public class Presets
        {
            public string activePreset;
            // string will be the name of the profile.
            public Dictionary<string, Preset> presets = new Dictionary<string, Preset>();
        }
        public class Preset
        {
            /* Check to see if the player has enough total points (both spent and unspent) to apply the profile.
             * Respec the player, freeing up their points.
             * If the player doesn't have enough points, prevent it from being applied.
             * Add the skills to the player, both in data and instance, and assign left overpoints to Available Points.
             * Add a button to save a new preset (preset 1, 2 etc).
             * Need a way to identify presets and what's unlocked (maybe print list of skills to console with required points).
             */
            public Dictionary<string, PresetInfo> skills = new Dictionary<string, PresetInfo>();
            public int pointsRequired; // Saves having to sum each time its checked.
        }

        public class PresetInfo
        {
            public int points;
            public string tree;
            public PresetInfo(int points, string tree)
            {
                this.points = points;
                this.tree = tree;
            }
        }

        void AddProfile(BasePlayer player, string profileName)
        {
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData)) return;

            if (profileName == playerData.presets?.activePreset)
            {
                SendMessage(player, string.Format(lang.GetMessage("PresetAlreadyExists", this, player.UserIDString), profileName), config.misc_settings.messageSettings.cuiCols.CUIWarn);
                return;
            }

            var pointsInTree = playerData.buff_values.Sum(x => x.Value);

            double cost = 0;
            if (config.misc_settings.presetSettings.setupCosts.chargeRespecCost)
            {
                var respec_cost = GetRespecCost(player);
                cost = Math.Round(pointsInTree * respec_cost, 2);
            }

            if (!CanAffortNewProfile(player, pointsInTree, cost)) return;
            if (playerData.presets != null && !string.IsNullOrEmpty(playerData.presets.activePreset)) SaveProfile(player, playerData, playerData.presets.activePreset);

            TakeItemsForNewProfile(player, cost);
            RespecPlayer(player, playerData);
            SaveProfile(player, playerData, profileName);
            playerData.presets.activePreset = profileName;
            SendBaseMenu(player);
        }

        void SaveProfile(BasePlayer player, PlayerInfo playerData, string profileName)
        {
            if (playerData.presets == null) playerData.presets = new Presets();
            if (!playerData.presets.presets.TryGetValue(profileName, out var presetData)) playerData.presets.presets.Add(profileName, presetData = new Preset());

            var treePoints = 0;
            var skills = 0;
            foreach (var tree in config.trees)
            {
                foreach (var node in tree.Value.nodes)
                {
                    if (!playerData.buff_values.TryGetValue(node.Key, out var points)) continue;
                    if (presetData.skills.TryGetValue(node.Key, out var preset)) preset.points = points;
                    else presetData.skills.Add(node.Key, new PresetInfo(points, tree.Key));

                    treePoints += points;
                    skills++;
                }
            }
            presetData.pointsRequired = treePoints;

            //PrintToChat(player, $"Saved preset: {profileName}. Skills: {skills}. Points: {treePoints}");
            SendMessage(player, string.Format(lang.GetMessage("PresetSaved", this, player.UserIDString), profileName, skills, treePoints), config.misc_settings.messageSettings.cuiCols.CUISuccess);
        }

        bool CanAffortNewProfile(BasePlayer player, int pointsInTree, double cost)
        {
            if (config.misc_settings.presetSettings.setupCosts.chargeRespecCost)
            {
                if (!CanAffordRespecCost(player, cost))
                {
                    SendMessage(player, lang.GetMessage("PresetCannotAffordRespec", this, player.UserIDString), config.misc_settings.messageSettings.cuiCols.CUIWarn);
                    return false;
                }
            }

            if (config.misc_settings.presetSettings.setupCosts.econ > 0 && (config.general_settings.respec_currency == "economics" ? cost : 0) + Convert.ToDouble(Economics?.Call("Balance", player.userID.Get())) < config.misc_settings.presetSettings.setupCosts.econ)
            {
                SendMessage(player, lang.GetMessage("PresetNotEnoughEcon", this, player.UserIDString), config.misc_settings.messageSettings.cuiCols.CUIWarn);
                return false;
            }

            if (config.misc_settings.presetSettings.setupCosts.srp > 0 && (config.general_settings.respec_currency == "srp" ? cost : 0) + Convert.ToInt32(ServerRewards.Call("CheckPoints", player.userID.Get())) < config.misc_settings.presetSettings.setupCosts.srp)
            {
                SendMessage(player, lang.GetMessage("PresetNotEnoughSR", this, player.UserIDString), config.misc_settings.messageSettings.cuiCols.CUIWarn);
                return false;
            }

            if (config.misc_settings.presetSettings.setupCosts.shoppyStock > 0 && (config.general_settings.respec_currency == "shoppystock" ? cost : 0) + Convert.ToInt32(ShoppyStock?.Call("GetCurrencyAmount", config.general_settings.shoppyStockInfo.shopName, player) ?? 0) < config.misc_settings.presetSettings.setupCosts.srp)
            {
                SendMessage(player, lang.GetMessage("PresetNotEnoughShoppyStock", this, player.UserIDString), config.misc_settings.messageSettings.cuiCols.CUIWarn);
                return false;
            }

            if (config.misc_settings.presetSettings.setupCosts.items.Count > 0)
            {
                List<Item> items = Pool.Get<List<Item>>();
                player.inventory.GetAllItems(items);
                foreach (var requiredItem in config.misc_settings.presetSettings.setupCosts.items)
                {
                    int found = 0;
                    double requiredAmount = IsCurrencyMatch(requiredItem.shortname, requiredItem.skin) ? requiredItem.amount + cost : requiredItem.amount;
                    foreach (var item in items)
                    {
                        if (!requiredItem.IsMatch(item)) continue;
                        found += item.amount;
                        if (found >= requiredAmount) break;
                    }
                    if (found < requiredAmount)
                    {
                        SendMessage(player, string.Format(lang.GetMessage("PresetMissingItem", this, player.UserIDString), (!string.IsNullOrEmpty(requiredItem.displayName) ? requiredItem.displayName : ItemManager.FindItemDefinition(requiredItem.shortname)?.displayName.english ?? requiredItem.shortname)), config.misc_settings.messageSettings.cuiCols.CUIWarn);
                        return false;
                    }
                }
                Pool.FreeUnmanaged(ref items);
            }
            return true;
        }

        bool IsCurrencyMatch(string shortname, ulong skin)
        {
            if (config.general_settings.respec_currency == "scrap") return shortname == "scrap" && skin == 0;
            if (config.general_settings.respec_currency == "custom") return shortname == config.general_settings.respec_currency_custom.shortname && skin == config.general_settings.respec_currency_custom.skin;
            return false;
        }

        void TakeItemsForNewProfile(BasePlayer player, double cost)
        {
            PaidForRespec(player, cost);

            if (config.misc_settings.presetSettings.setupCosts.econ > 0) Economics?.Call("Withdraw", player.userID.Get(), config.misc_settings.presetSettings.setupCosts.econ);

            if (config.misc_settings.presetSettings.setupCosts.srp > 0)
            {
                var intCost = Convert.ToInt32(config.misc_settings.presetSettings.setupCosts.srp);
                ServerRewards?.Call("TakePoints", player.userID.Get(), intCost);
            }

            if (config.misc_settings.presetSettings.setupCosts.shoppyStock > 0)
            {
                var intCost = Convert.ToInt32(config.misc_settings.presetSettings.setupCosts.shoppyStock);
                ShoppyStock?.Call("TakeCurrency", config.general_settings.shoppyStockInfo.shopName, player, intCost);
            }

            if (config.misc_settings.presetSettings.setupCosts.items.Count > 0)
            {
                List<Item> items = Pool.Get<List<Item>>();
                player.inventory.GetAllItems(items);
                foreach (var requiredItem in config.misc_settings.presetSettings.setupCosts.items)
                {
                    int taken = 0;
                    foreach (var item in items)
                    {
                        if (!requiredItem.IsMatch(item)) continue;
                        if (taken + item.amount <= requiredItem.amount)
                        {
                            taken += item.amount;
                            item.Remove();

                        }
                        else
                        {
                            item.UseItem(requiredItem.amount - taken);
                            taken = requiredItem.amount;
                        }
                        if (taken >= requiredItem.amount) break;
                    }
                }

                Pool.FreeUnmanaged(ref items);
            }
        }

        void HandleProfileSwap(BasePlayer player, string profileName)
        {
            if (string.IsNullOrEmpty(profileName) || !pcdData.pEntity.TryGetValue(player.userID, out var playerData) || playerData.presets == null || !playerData.presets.presets.TryGetValue(profileName, out var profile)) return;
            if (profileName == playerData.presets.activePreset)
            {
                SendMessage(player, lang.GetMessage("PresetAlreadyActive", this, player.UserIDString), config.misc_settings.messageSettings.cuiCols.CUIWarn);
                return;
            }

            if (!config.misc_settings.presetSettings.allowChangeAnywhere && (!config.misc_settings.presetSettings.allowChangeSafeZone || !player.InSafeZone()) && (!config.misc_settings.presetSettings.allowChangeTC || player.GetBuildingPrivilege() == null))
            {
                var msg = config.misc_settings.presetSettings.allowChangeSafeZone && config.misc_settings.presetSettings.allowChangeSafeZone ? lang.GetMessage("FailSafeTC", this, player.UserIDString) : config.misc_settings.presetSettings.allowChangeTC ? lang.GetMessage("FailTC", this, player.UserIDString) : lang.GetMessage("FailSafe", this, player.UserIDString);
                SendMessage(player, msg, config.misc_settings.messageSettings.cuiCols.CUIWarn);
                return;
            }

            var totalSkillPoints = playerData.GetTotalSkillPoints;
            if (totalSkillPoints < profile.pointsRequired)
            {
                SendMessage(player, string.Format(lang.GetMessage("PresetNotEnoughSkillPoints", this, player.UserIDString), profile.pointsRequired), config.misc_settings.messageSettings.cuiCols.CUIWarn);
                return;
            }

            if (!CostForSwapPaid(player, totalSkillPoints - playerData.available_points)) return;
            if (playerData.presets != null && !string.IsNullOrEmpty(playerData.presets.activePreset))
            {
                SaveProfile(player, playerData, playerData.presets.activePreset);
            }

            RespecPlayer(player, playerData);
            LoadProfile(player, playerData, profile, profileName);
        }

        bool CostForSwapPaid(BasePlayer player, int pointsInTree)
        {
            double cost = 0;

            if (config.misc_settings.presetSettings.swapCost.chargeRespecCost)
            {
                var respec_cost = GetRespecCost(player);
                cost = Math.Round(pointsInTree * respec_cost, 2);

                if (!CanAffordRespecCost(player, cost))
                {
                    SendMessage(player, lang.GetMessage("PresetCannotAffordRespec", this, player.UserIDString), config.misc_settings.messageSettings.cuiCols.CUIWarn);
                    return false;
                }
            }

            if (config.misc_settings.presetSettings.swapCost.additionalEconCost > 0)
            {
                if ((config.general_settings.respec_currency == "economics" && cost + config.misc_settings.presetSettings.swapCost.additionalEconCost > Convert.ToDouble(Economics?.Call("Balance", player.userID.Get()))) ||
                    config.misc_settings.presetSettings.swapCost.additionalEconCost > Convert.ToDouble(Economics?.Call("Balance", player.userID.Get())))
                {
                    SendMessage(player, lang.GetMessage("PresetNotEnoughEconSwap", this, player.UserIDString), config.misc_settings.messageSettings.cuiCols.CUIWarn);
                    return false;
                }
            }

            if (config.misc_settings.presetSettings.swapCost.additionalSRCost > 0)
            {
                if ((config.general_settings.respec_currency == "srp" && cost + config.misc_settings.presetSettings.swapCost.additionalSRCost > Convert.ToInt32(ServerRewards.Call("CheckPoints", player.userID.Get()))) ||
                    config.misc_settings.presetSettings.swapCost.additionalSRCost > Convert.ToInt32(ServerRewards.Call("CheckPoints", player.userID.Get())))
                {
                    SendMessage(player, lang.GetMessage("PresetNotEnoughSRSwap", this, player.UserIDString), config.misc_settings.messageSettings.cuiCols.CUIWarn);
                    return false;
                }
            }

            if (config.misc_settings.presetSettings.swapCost.additionalShoppyStockCost > 0)
            {
                if ((config.general_settings.respec_currency == "shoppystock" && cost + config.misc_settings.presetSettings.swapCost.additionalShoppyStockCost > Convert.ToInt32(ShoppyStock?.Call("GetCurrencyAmount", config.general_settings.shoppyStockInfo.shopName, player) ?? 0)) ||
                    config.misc_settings.presetSettings.swapCost.additionalShoppyStockCost > Convert.ToInt32(ShoppyStock?.Call("GetCurrencyAmount", config.general_settings.shoppyStockInfo.shopName, player) ?? 0))
                {
                    SendMessage(player, lang.GetMessage("PresetNotEnoughShoppyStockSwap", this, player.UserIDString), config.misc_settings.messageSettings.cuiCols.CUIWarn);
                    return false;
                }
            }

            if (config.misc_settings.presetSettings.swapCost.additionalItemCost.Count > 0)
            {
                List<Item> items = Pool.Get<List<Item>>();
                player.inventory.GetAllItems(items);
                foreach (var requiredItem in config.misc_settings.presetSettings.swapCost.additionalItemCost)
                {
                    int found = 0;
                    double requiredAmount = IsCurrencyMatch(requiredItem.shortname, requiredItem.skin) ? requiredItem.amount + cost : requiredItem.amount;
                    foreach (var item in items)
                    {
                        if (!requiredItem.IsMatch(item)) continue;
                        found += item.amount;
                        if (found >= requiredAmount) break;
                    }

                    if (found < requiredAmount)
                    {
                        SendMessage(player, string.Format(lang.GetMessage("PresetNotEnoughItemsSwap", this, player.UserIDString), requiredItem.displayName ?? ItemManager.FindItemDefinition(requiredItem.shortname)?.displayName.english ?? requiredItem.shortname, found, requiredItem.amount), config.misc_settings.messageSettings.cuiCols.CUIWarn);

                        Pool.FreeUnmanaged(ref items);
                        return false;
                    }
                }
                Pool.FreeUnmanaged(ref items);
            }

            PaidForRespec(player, cost);
            TakeAdditionalCosts(player);

            return true;
        }

        void TakeAdditionalCosts(BasePlayer player)
        {
            if (config.misc_settings.presetSettings.swapCost.additionalEconCost > 0) Economics?.Call("Withdraw", player.userID.Get(), config.misc_settings.presetSettings.swapCost.additionalEconCost);
            if (config.misc_settings.presetSettings.swapCost.additionalSRCost > 0)
            {
                var intCost = Convert.ToInt32(config.misc_settings.presetSettings.swapCost.additionalSRCost);
                ServerRewards?.Call("TakePoints", player.userID.Get(), intCost);
            }
            if (config.misc_settings.presetSettings.swapCost.additionalShoppyStockCost > 0)
            {
                var intCost = Convert.ToInt32(config.misc_settings.presetSettings.swapCost.additionalShoppyStockCost);
                ShoppyStock?.Call("TakeCurrency", config.general_settings.shoppyStockInfo.shopName, player, intCost);
            }
            if (config.misc_settings.presetSettings.swapCost.additionalItemCost.Count > 0)
            {
                List<Item> items = Pool.Get<List<Item>>();
                player.inventory.GetAllItems(items);
                foreach (var requiredItem in config.misc_settings.presetSettings.swapCost.additionalItemCost)
                {
                    int taken = 0;
                    foreach (var item in items)
                    {
                        if (!requiredItem.IsMatch(item)) continue;
                        if (taken + item.amount <= requiredItem.amount)
                        {
                            taken += item.amount;
                            item.Remove();

                        }
                        else
                        {
                            item.UseItem(requiredItem.amount - taken);
                            taken = requiredItem.amount;
                        }
                        if (taken >= requiredItem.amount) break;
                    }
                }

                Pool.FreeUnmanaged(ref items);
            }
        }

        bool CanAffordRespecCost(BasePlayer player, double cost)
        {
            if (permission.UserHasPermission(player.UserIDString, perm_respec_bypass)) return true;
            switch (config.general_settings.respec_currency)
            {
                case "economics":
                    var playerBalance = Convert.ToDouble(Economics?.Call("Balance", player.userID.Get()));
                    return playerBalance >= cost;

                case "srp":
                    var balance = Convert.ToInt32(ServerRewards.Call("CheckPoints", player.userID.Get()));
                    return balance >= cost;

                case "shoppystock":
                    var shoppybalance = Convert.ToInt32(ShoppyStock?.Call("GetCurrencyAmount", config.general_settings.shoppyStockInfo.shopName, player) ?? 0);
                    return shoppybalance >= cost;

                case "scrap":
                    List<Item> items = Pool.Get<List<Item>>();
                    player.inventory.GetAllItems(items);
                    int found = 0;
                    foreach (var item in items)
                        if (item.info.shortname == "scrap")
                        {
                            found += item.amount;
                            if (found >= cost) break;
                        }
                    Pool.FreeUnmanaged(ref items);
                    return found >= cost;

                case "custom":
                    List<Item> items2 = Pool.Get<List<Item>>();
                    player.inventory.GetAllItems(items2);
                    int found2 = 0;
                    foreach (var item in items2)
                        if (item.info.shortname == config.general_settings.respec_currency_custom.shortname &&
                            item.skin == config.general_settings.respec_currency_custom.skin &&
                            (string.IsNullOrEmpty(config.general_settings.respec_currency_custom.displayName) ||
                            item.name == config.general_settings.respec_currency_custom.displayName))
                        {
                            found2 += item.amount;
                            if (found2 >= cost) break;
                        }
                    Pool.FreeUnmanaged(ref items2);
                    return found2 >= cost;
            }

            return false;
        }

        void LoadProfile(BasePlayer player, PlayerInfo playerData, Preset profile, string profileName)
        {
            if (!TreeData.TryGetValue(player.userID, out var ti)) return;
            if (!GetBuffDetails(player.userID, out var buffData, true)) return;
            foreach (var skill in profile.skills)
            {
                if (!ti.trees.TryGetValue(skill.Value.tree, out var treeData)) continue;
                if (!treeData.nodes.TryGetValue(skill.Key, out var nodeData)) continue;

                if (playerData.buff_values.TryGetValue(skill.Key, out var existingAmount)) playerData.buff_values.Add(skill.Key, existingAmount + skill.Value.points);
                else playerData.buff_values.Add(skill.Key, skill.Value.points);
                playerData.available_points -= skill.Value.points;

                ti.total_points_spent += skill.Value.points;
                treeData.points_spent += skill.Value.points;

                if (!playerData.buff_values.ContainsKey(skill.Key)) nodeData.level_current = 0;
                else nodeData.level_current = playerData.buff_values[skill.Key];

                SetNodePoints(player, nodeData, buffData, playerData, skill.Value.tree, skill.Key);

                nodeData.level_current = skill.Value.points;
            }

            SetupSkills(player, buffData, playerData);
            CheckPoints(player, playerData);

            foreach (var buff in buffData.GetBuffs())
                if (playerData.DisabledBuffs.Contains(buff.Key))
                    buff.Value.SetEnabled(player, buff.Key, false);

            SendMessage(player, string.Format(lang.GetMessage("PresetSwappedTo", this, player.UserIDString), profileName), config.misc_settings.messageSettings.cuiCols.CUISuccess);
            playerData.presets.activePreset = profileName;
        }

        #region Preset menu

        void SendPresetMenu(BasePlayer player)
        {
            PresetBackpanel(player);
            PresetPanel(player);
        }

        private void PresetBackpanel(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "PresetBackpanel",
                Parent = "Overlay",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0 0 0 0.9803922" },
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            CuiHelper.DestroyUi(player, "PresetBackpanel");
            CuiHelper.AddUi(player, container);
        }

        int GetMaxPresets(BasePlayer player)
        {
            var result = config.misc_settings.presetSettings.maxPresets;
            foreach (var perm in config.misc_settings.presetSettings.maxPresetsOverride)
            {
                var hasPrefix = perm.Key.StartsWith("skilltree.", StringComparison.OrdinalIgnoreCase);
                if (permission.UserHasPermission(player.UserIDString, hasPrefix ? perm.Key : "skilltree." + perm.Key) && perm.Value > result)
                    result = perm.Value;
            }

            return result;
        }

        private void PresetPanel(BasePlayer player)
        {
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData)) return;
            var maxPresets = GetMaxPresets(player);
            var elementCount = playerData.presets == null ? 1 : Math.Min(playerData.presets.presets.Count + 1, maxPresets);

            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "PresetPanel",
                Parent = "Overlay",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.1603774 0.1603774 0.1603774 1" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-100.175 {16 - Math.Min(elementCount * 36, 180)}", OffsetMax = "99.825 20" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Title",
                Parent = "PresetPanel",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIPresetTreePresetTitle", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 20, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-100 4", OffsetMax = "100 44" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "PresetScrollPanel",
                Parent = "PresetPanel",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-100 {0 - Math.Min(elementCount * 36, 180)}", OffsetMax = "100 0" }
                }
            });

            if (elementCount > 5)
            {
                container.Add(new CuiElement
                {
                    Name = "PresetScrollPanelScrollElement",
                    Parent = "PresetScrollPanel",
                    Components = {
                    new CuiScrollViewComponent {
                        MovementType = UnityEngine.UI.ScrollRect.MovementType.Elastic,
                        Vertical = true,
                        Inertia = true,
                        Horizontal = false,
                        Elasticity = 0.25f,
                        DecelerationRate = 0.3f,
                        ScrollSensitivity = 24f,
                        ContentTransform = new CuiRectTransform { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 " + ((36 * (elementCount)) * -1), OffsetMax = "0 0" },
                        VerticalScrollbar = new CuiScrollbar() { Size = 4f, AutoHide = true }, // Remove this to remove the scroll bar and just have it scrollable with mwheel
                    },
                    new CuiNeedsCursorComponent()
                }
                });
            }

            var parent = elementCount > 5 ? "PresetScrollPanelScrollElement" : "PresetScrollPanel";

            var count = 0;
            if (playerData.presets != null)
            {
                var playerPoints = playerData.GetTotalSkillPoints;
                foreach (var preset in playerData.presets.presets)
                {
                    var text = preset.Key == playerData.presets.activePreset ? $"<color=#65f706>{preset.Key.ToUpper()}</color>" : preset.Value.pointsRequired <= playerPoints ? preset.Key.ToUpper() : $"<color=#f6460a>{preset.Key.ToUpper()}</color>";
                    container.Add(new CuiButton
                    {
                        Button = { Color = "0.4150943 0.4150943 0.4150943 1", Command = $"stselectpreset {preset.Key}" },
                        Text = { Text = text, Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                        RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-96 {-36 - (count * 36)}", OffsetMax = $"96 {-4 - (count * 36)}" }
                    }, parent, "PresetButton");
                    count++;
                }
            }

            if (playerData.presets == null || playerData.presets.presets.Count < maxPresets)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = "0.4150943 0.4150943 0.4150943 1", Command = "staddnewpreset" },
                    Text = { Text = lang.GetMessage("UIPresetAddButton", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-96 {-36 - (count * 36)}", OffsetMax = $"96 {-4 - (count * 36)}" }
                }, parent, "PresetButton");
            }

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = "stclosepresetmenu" },
                Text = { Text = lang.GetMessage("UIClose", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-32 -41", OffsetMax = "32 -9" }
            }, "PresetPanel", "PresetClose");

            CuiHelper.DestroyUi(player, "PresetPanel");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("stclosepresetmenu")]
        void ClosePresetMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, "PresetBackpanel");
            CuiHelper.DestroyUi(player, "PresetPanel");
        }

        [ConsoleCommand("stselectpreset")]
        void SelectPreset(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (arg.Args == null) return;

            PresetAddSelectBackpanel(player);
            STAddSelectPresetPanel(player, false, string.Join(" ", arg.Args));
        }

        [ConsoleCommand("staddnewpreset")]
        void AddPreset(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            PresetAddSelectBackpanel(player);
            STAddSelectPresetPanel(player, true, "");
        }

        private void PresetAddSelectBackpanel(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "PresetAddSelectBackpanel",
                Parent = "Overlay",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0 0 0 1" },
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            CuiHelper.DestroyUi(player, "PresetAddSelectBackpanel");
            CuiHelper.AddUi(player, container);
        }

        private void STAddSelectPresetPanel(BasePlayer player, bool adding, string selectedName)
        {
            int totalElements = adding ? 1 : 0;
            totalElements += adding ? config.misc_settings.presetSettings.setupCosts.econ > 0 ? 1 : 0 : config.misc_settings.presetSettings.swapCost.additionalEconCost > 0 ? 1 : 0;
            totalElements += adding ? config.misc_settings.presetSettings.setupCosts.srp > 0 ? 1 : 0 : config.misc_settings.presetSettings.swapCost.additionalSRCost > 0 ? 1 : 0;
            totalElements += adding ? config.misc_settings.presetSettings.setupCosts.shoppyStock > 0 ? 1 : 0 : config.misc_settings.presetSettings.swapCost.additionalShoppyStockCost > 0 ? 1 : 0;
            totalElements += adding ? config.misc_settings.presetSettings.setupCosts.items.Count > 0 ? config.misc_settings.presetSettings.setupCosts.items.Count : 0 : config.misc_settings.presetSettings.swapCost.additionalItemCost.Count > 0 ? config.misc_settings.presetSettings.swapCost.additionalItemCost.Count : 0;


            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "STAddSelectPresetPanel",
                Parent = "Overlay",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.1607843 0.1607843 0.1607843 1" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-99.825 {16 - Math.Min(totalElements * 36, adding ? 216 : 180)}", OffsetMax = "100.175 20.00" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Title",
                Parent = "STAddSelectPresetPanel",
                Components = {
                    new CuiTextComponent { Text = adding ? lang.GetMessage("UIPresetAddNewPresetTitle", this, player.UserIDString) : lang.GetMessage("UIPresetSwapToPresetTitle", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 20, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-100.045 32.5", OffsetMax = "99.955 72.5" }
                }
            });

            if ((!adding && config.misc_settings.presetSettings.swapCost.chargeRespecCost) || (adding && config.misc_settings.presetSettings.setupCosts.chargeRespecCost))
            {
                if ((!adding && totalElements > 0) || (adding && totalElements > 1))
                {
                    container.Add(new CuiElement
                    {
                        Name = "Title",
                        Parent = "STAddSelectPresetPanel",
                        Components = {
                        new CuiTextComponent { Text = string.Format(lang.GetMessage("UIPresetSwapRespecNoticee", this, player.UserIDString), GetTotalRespecCost(player), GetRespecCostName(player)), Font = "robotocondensed-bold.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                        new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-400 0", OffsetMax = "400 20" }
                    }
                    });
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Name = "Title",
                        Parent = "STAddSelectPresetPanel",
                        Components = {
                        new CuiTextComponent { Text = string.Format(lang.GetMessage("UIPresetSwapRespecNoAdditionalCost", this, player.UserIDString), GetTotalRespecCost(player), GetRespecCostName(player)), Font = "robotocondensed-bold.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                        new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-400 0", OffsetMax = "400 20" }
                    }
                    });
                }
            }

            container.Add(new CuiElement
            {
                Name = "PresetAddSelectScroll",
                Parent = "STAddSelectPresetPanel",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-100.045 -180", OffsetMax = "99.915 0" }
                }
            });

            if (totalElements > 5)
            {
                container.Add(new CuiElement
                {
                    Name = "STAddSelectPresetPanelElement",
                    Parent = "PresetAddSelectScroll",
                    Components = {
                    new CuiScrollViewComponent {
                        MovementType = UnityEngine.UI.ScrollRect.MovementType.Elastic,
                        Vertical = true,
                        Inertia = true,
                        Horizontal = false,
                        Elasticity = 0.25f,
                        DecelerationRate = 0.3f,
                        ScrollSensitivity = 24f,
                        ContentTransform = new CuiRectTransform { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 " + ((36 * (totalElements - (adding ? 1 : 0))) * -1), OffsetMax = "0 0" },
                        VerticalScrollbar = new CuiScrollbar() { Size = 4f, AutoHide = true }, // Remove this to remove the scroll bar and just have it scrollable with mwheel
                    },
                    new CuiNeedsCursorComponent()
                }
                });
            }

            var parent = totalElements > 5 ? "STAddSelectPresetPanelElement" : "PresetAddSelectScroll";

            var count = 0;
            if ((adding && config.misc_settings.presetSettings.setupCosts.econ > 0) || (!adding && config.misc_settings.presetSettings.swapCost.additionalEconCost > 0))
            {
                container.Add(new CuiElement
                {
                    Name = "PresetAddCostElement_econ",
                    Parent = parent,
                    Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.4156863 0.4156863 0.4156863 1" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-95.98 -36", OffsetMax = "96.02 -4" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CostTitle",
                    Parent = "PresetAddCostElement_econ",
                    Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIPresetEconCost", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-90 -16", OffsetMax = "0 16" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CostValue",
                    Parent = "PresetAddCostElement_econ",
                    Components = {
                    new CuiTextComponent { Text = string.Format(lang.GetMessage("UIPresetEconValue", this, player.UserIDString), (adding ? config.misc_settings.presetSettings.setupCosts.econ : config.misc_settings.presetSettings.swapCost.additionalEconCost)), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "0 -16", OffsetMax = "90 16" }
                }
                });

                count++;
            }

            if ((adding && config.misc_settings.presetSettings.setupCosts.srp > 0) || (!adding && config.misc_settings.presetSettings.swapCost.additionalSRCost > 0))
            {
                container.Add(new CuiElement
                {
                    Name = "PresetAddCostElement_sr",
                    Parent = parent,
                    Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.4156863 0.4156863 0.4156863 1" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-95.98 {-36 - (count * 36)}", OffsetMax = $"96.02 {-4 - (count * 36)}" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CostTitle",
                    Parent = "PresetAddCostElement_sr",
                    Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIPresetSRCost", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-90 -16", OffsetMax = "0 16" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CostValue",
                    Parent = "PresetAddCostElement_sr",
                    Components = {
                    new CuiTextComponent { Text = string.Format(lang.GetMessage("UIPresetSRValue", this, player.UserIDString), (adding ? config.misc_settings.presetSettings.setupCosts.srp : config.misc_settings.presetSettings.swapCost.additionalSRCost)), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "0 -16", OffsetMax = "90 16" }
                }
                });

                count++;
            }

            if ((adding && config.misc_settings.presetSettings.setupCosts.shoppyStock > 0) || (!adding && config.misc_settings.presetSettings.swapCost.additionalShoppyStockCost > 0))
            {
                container.Add(new CuiElement
                {
                    Name = "PresetAddCostElement_shoppyStock",
                    Parent = parent,
                    Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.4156863 0.4156863 0.4156863 1" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-95.98 {-36 - (count * 36)}", OffsetMax = $"96.02 {-4 - (count * 36)}" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CostTitle",
                    Parent = "PresetAddCostElement_shoppyStock",
                    Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIPresetShoppyStockCost", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-90 -16", OffsetMax = "0 16" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CostValue",
                    Parent = "PresetAddCostElement_shoppyStock",
                    Components = {
                    new CuiTextComponent { Text = string.Format(lang.GetMessage("UIPresetShoppyStockValue", this, player.UserIDString), (adding ? config.misc_settings.presetSettings.setupCosts.shoppyStock : config.misc_settings.presetSettings.swapCost.additionalShoppyStockCost)), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "0 -16", OffsetMax = "90 16" }
                }
                });

                count++;
            }

            if ((adding && config.misc_settings.presetSettings.setupCosts.items.Count > 0) || (!adding && config.misc_settings.presetSettings.swapCost.additionalItemCost.Count > 0))
            {
                foreach (var item in adding ? config.misc_settings.presetSettings.setupCosts.items : config.misc_settings.presetSettings.swapCost.additionalItemCost)
                {
                    container.Add(new CuiElement
                    {
                        Name = $"PresetItemAddCostElement_{count}",
                        Parent = parent,
                        Components =
                    {
                        new CuiNeedsCursorComponent(),
                        new CuiImageComponent{ Color = "0.4156863 0.4156863 0.4156863 1" },
                        new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-95.98 {-36 - (count * 36)}", OffsetMax = $"96.02 {-4 - (count * 36)}" }
                    }
                    });

                    container.Add(new CuiElement
                    {
                        Name = "img",
                        Parent = $"PresetItemAddCostElement_{count}",
                        Components = {
                        new CuiImageComponent { Color = "1 1 1 1", ItemId = ItemDefs.TryGetValue(item.shortname, out var def) ? def.itemid : 1751045826, SkinId = item.skin },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-94 -14", OffsetMax = "-66 14" }
                    }
                    });

                    container.Add(new CuiElement
                    {
                        Name = $"ItemName_{count}",
                        Parent = $"PresetItemAddCostElement_{count}",
                        Components =
                    {
                        new CuiNeedsCursorComponent(),
                        new CuiImageComponent{ Color = "0.3018868 0.3018868 0.3018868 1" },
                        new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66 -14", OffsetMax = "54 14" }
                    }
                    });

                    container.Add(new CuiElement
                    {
                        Name = "Text",
                        Parent = $"ItemName_{count}",
                        Components = {
                        new CuiTextComponent { Text = !string.IsNullOrEmpty(item.displayName) ? item.displayName.TitleCase() : def != null ? def.displayName.english.TitleCase() : item.shortname, Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                        new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-60 -14", OffsetMax = "60 14" }
                    }
                    });

                    container.Add(new CuiElement
                    {
                        Name = $"Amount_{count}",
                        Parent = $"PresetItemAddCostElement_{count}",
                        Components =
                    {
                        new CuiNeedsCursorComponent(),
                        new CuiImageComponent{ Color = "0.3773585 0.3393149 0 1" },
                        new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "54 -14", OffsetMax = "94 14" }
                    }
                    });

                    container.Add(new CuiElement
                    {
                        Name = "Text",
                        Parent = $"Amount_{count}",
                        Components = {
                        new CuiTextComponent { Text = item.amount.ToString(), Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-20 -14", OffsetMax = "20 14" }
                    }
                    });
                    count++;
                }

            }

            if (adding)
            {
                container.Add(new CuiElement
                {
                    Name = "PresetTextInput",
                    Parent = "STAddSelectPresetPanel",
                    Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.4156863 0.4156863 0.4156863 1" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-96.045 4", OffsetMax = "95.955 36" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CostTitle",
                    Parent = "PresetTextInput",
                    Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIPresetInputName", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-94 -16", OffsetMax = "-52 16" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "NamePanel",
                    Parent = "PresetTextInput",
                    Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.2830189 0.2816839 0.2816839 1" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-52 -14", OffsetMax = "94 14" }
                }
                });


                container.Add(new CuiElement
                {
                    Name = "STAddPresetNameField",
                    Parent = "NamePanel",
                    Components =
                    {
                        new CuiInputFieldComponent
                        {
                            Text = selectedName ?? string.Empty,
                            CharsLimit = 40,
                            Color = !string.IsNullOrEmpty(selectedName) ? "0.09 0.741 0.2 1" : "1 1 1 1",
                            IsPassword = false,
                            Command = $"{"STAddPresetPanel"} {adding}",
                            Font = "robotocondensed-regular.ttf",
                            FontSize = 16,                        
                            //NeedsKeyboard = true,
                            Align = TextAnchor.MiddleCenter,
                            HudMenuInput = true
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-73 -14",
                            OffsetMax = "73 14"
                        }
                    }
                });
            }

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = "STGobacktoPresetList" },
                Text = { Text = lang.GetMessage("UIBack", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-100 -32", OffsetMax = "-36 0" }
            }, "STAddSelectPresetPanel", "AddSelectCloseButton");

            var waitingForName = string.IsNullOrEmpty(selectedName);
            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = waitingForName ? "" : $"stconfirmpreset {adding} {selectedName}" },
                Text = { Text = lang.GetMessage("UICONFIRM", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = waitingForName ? "0.553 0.561 0.51 1" : "1 1 1 1" },
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "35.915 -32", OffsetMax = "99.915 0" }
            }, "STAddSelectPresetPanel", "AddSelectConfirmButton");

            if (!adding)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = $"stshowpresetinfo {selectedName}" },
                    Text = { Text = lang.GetMessage("UIInfo", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-32 -32", OffsetMax = "32 0" }
                }, "STAddSelectPresetPanel", "AddSelectInfoButton");
            }

            CuiHelper.DestroyUi(player, "STAddSelectPresetPanel");
            CuiHelper.AddUi(player, container);
        }

        string GetRespecCostName(BasePlayer player)
        {
            //scrap, economics, srp, custom
            switch (config.general_settings.respec_currency)
            {
                case "scrap": return lang.GetMessage("UIScrap", this, player.UserIDString);
                case "srp": return lang.GetMessage("UIPoints", this, player.UserIDString);
                case "shoppystock": return lang.GetMessage("UIShoppyStock", this, player.UserIDString);
                case "economics": return lang.GetMessage("UIDollarsWord", this, player.UserIDString);
                case "custom": return config.general_settings.respec_currency_custom.displayName;
                default: return "error";
            }
        }

        [ConsoleCommand("stshowpresetinfo")]
        void ShowPresetInfo(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (arg.Args == null) return;

            PresetInfoBackground(player);
            STPresetSkillPanel(player, string.Join(" ", arg.Args));
        }

        [ConsoleCommand("STGobacktoPresetList")]
        void BackToPresetList(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, "PresetAddSelectBackpanel");
            CuiHelper.DestroyUi(player, "STAddSelectPresetPanel");
        }

        [ConsoleCommand("STAddPresetPanel")]
        void DelayInputText(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (arg.Args == null) return;
            if (!bool.TryParse(arg.Args[0], out var adding)) return;
            STAddSelectPresetPanel(player, adding, string.Join(" ", arg.Args.Skip(1)));
        }

        [ConsoleCommand("stconfirmpreset")]
        void ConfirmPresetSelection(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (arg.Args == null) return;
            if (!bool.TryParse(arg.Args[0], out var added)) return;
            var profile = string.Join(" ", arg.Args.Skip(1));
            if (string.IsNullOrEmpty(profile)) return;

            CuiHelper.DestroyUi(player, "PresetAddSelectBackpanel");
            CuiHelper.DestroyUi(player, "STAddSelectPresetPanel");
            CuiHelper.DestroyUi(player, "PresetPanel");

            if (!added)
            {
                HandleProfileSwap(player, profile);
                CuiHelper.DestroyUi(player, "PresetBackpanel");
                SendBaseMenu(player);
            }
            else
            {
                AddProfile(player, string.Join(" ", profile));
                PresetBackpanel(player);
                PresetPanel(player);
            }
        }

        Dictionary<ulong, Action> MessageReceivers = new Dictionary<ulong, Action>();

        void SendMessage(BasePlayer player, string message, string col)
        {
            if (MessageReceivers.TryGetValue(player.userID, out var existingAction)) ServerMgr.Instance.CancelInvoke(existingAction);
            Action ClearMessageAction = () => RemoveMessage(player.userID, player);
            MessageReceivers[player.userID] = ClearMessageAction;
            ServerMgr.Instance.Invoke(ClearMessageAction, config.misc_settings.messageSettings.CUIRemoveDelay);
            SendMessagePanel(player, message, col);
        }

        void RemoveMessage(ulong userid, BasePlayer player)
        {
            if (player != null && player.IsConnected) CuiHelper.DestroyUi(player, "MessagePanel");
            MessageReceivers.Remove(userid);
        }

        private void SendMessagePanel(BasePlayer player, string message, string color)
        {
            float height = 42;
            if (config.misc_settings.messageSettings.expandheight) height = message.Split('\n').Length * 42;

            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "MessagePanel",
                Parent = "Overlay",
                FadeOut = 2,
                Components =
                {
                    new CuiImageComponent{ Color = color },
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = $"0 {height}" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "text",
                Parent = "MessagePanel",
                FadeOut = 2,
                Components = {
                    new CuiTextComponent { Text = message, Font = "robotocondensed-regular.ttf", FontSize = 20, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            CuiHelper.DestroyUi(player, "MessagePanel");
            CuiHelper.AddUi(player, container);
        }

        private void PresetInfoBackground(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "PresetInfoBackground",
                Parent = "Overlay",
                DestroyUi = "PresetInfoBackground",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0 0 0 1" },
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            CuiHelper.DestroyUi(player, "PresetInfoBackground");
            CuiHelper.AddUi(player, container);
        }

        private void STPresetSkillPanel(BasePlayer player, string profileName, bool delete = false)
        {
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData)) return;
            if (!playerData.presets.presets.TryGetValue(profileName, out var presetData)) return;
            int totalElements = presetData.skills.Count;

            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "STPresetSkillPanel",
                Parent = "Overlay",
                DestroyUi = "STPresetSkillPanel",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.1607843 0.1607843 0.1607843 1" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-99.825 {16 - Math.Min(totalElements * 36, 180)}", OffsetMax = "100.175 20.00" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Title",
                Parent = "STPresetSkillPanel",
                Components = {
                    new CuiTextComponent { Text = $"PRESET: {profileName.ToUpper()}", Font = "robotocondensed-bold.ttf", FontSize = 20, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-100.045 2.5", OffsetMax = "99.955 42.5" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "PresetSkillScroll",
                Parent = "STPresetSkillPanel",
                DestroyUi = "PresetSkillScroll",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-100.045 -180.04", OffsetMax = "99.915 0" }
                }
            });

            if (totalElements > 5)
            {
                container.Add(new CuiElement
                {
                    Name = "PresetSkillScrollElement",
                    Parent = "PresetSkillScroll",
                    Components = {
                    new CuiScrollViewComponent {
                        MovementType = UnityEngine.UI.ScrollRect.MovementType.Elastic,
                        Vertical = true,
                        Inertia = true,
                        Horizontal = false,
                        Elasticity = 0.25f,
                        DecelerationRate = 0.3f,
                        ScrollSensitivity = 24f,
                        ContentTransform = new CuiRectTransform { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 " + ((36 * (totalElements)) * -1), OffsetMax = "0 0" },
                        VerticalScrollbar = new CuiScrollbar() { Size = 4f, AutoHide = true }, // Remove this to remove the scroll bar and just have it scrollable with mwheel
                    },
                    new CuiNeedsCursorComponent()
                }
                });
            }

            var count = 0;
            var parent = totalElements > 5 ? "PresetSkillScrollElement" : "PresetSkillScroll";

            foreach (var tree in config.trees)
            {
                foreach (var node in tree.Value.nodes)
                {
                    if (!presetData.skills.TryGetValue(node.Key, out var points)) continue;
                    container.Add(new CuiElement
                    {
                        Name = $"PresetSkillElement_{count}",
                        Parent = parent,
                        Components =
                        {
                            new CuiNeedsCursorComponent(),
                            new CuiImageComponent{ Color = "0.4156863 0.4156863 0.4156863 1" },
                            new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-95.98 {-36 - (count * 36)}", OffsetMax = $"96.02 {-4 - (count * 36)}" }
                        }
                    });

                    container.Add(new CuiElement
                    {
                        Name = "img",
                        Parent = $"PresetSkillElement_{count}",
                        Components = {
                            new CuiImageComponent { Color = "1 1 1 1", ItemId = 1751045826, SkinId = node.Value.skin },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-94 -14", OffsetMax = "-66 14" }
                        }
                    });

                    container.Add(new CuiElement
                    {
                        Name = "ItemName",
                        Parent = $"PresetSkillElement_{count}",
                        Components =
                        {
                            new CuiNeedsCursorComponent(),
                            new CuiImageComponent{ Color = "0.3018868 0.3018868 0.3018868 1" },
                            new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66 -14", OffsetMax = "54 14" }
                        }
                    });

                    container.Add(new CuiElement
                    {
                        Name = "Text",
                        Parent = "ItemName",
                        Components = {
                        new CuiTextComponent { Text = node.Key.TitleCase(), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                        new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-60 -14", OffsetMax = "60 14" }
                    }
                    });

                    container.Add(new CuiElement
                    {
                        Name = "Amount",
                        Parent = $"PresetSkillElement_{count}",
                        Components =
                        {
                            new CuiNeedsCursorComponent(),
                            new CuiImageComponent{ Color = "0.3773585 0.3393149 0 1" },
                            new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "54 -14", OffsetMax = "94 14" }
                        }
                    });

                    container.Add(new CuiElement
                    {
                        Name = "Text",
                        Parent = "Amount",
                        Components = {
                            new CuiTextComponent { Text = points.points.ToString(), Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-20 -14", OffsetMax = "20 14" }
                        }
                    });

                    count++;
                }
            }

            if (!delete)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = "stclosepresetuiskill" },
                    Text = { Text = lang.GetMessage("UIBack", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-32.065 -32", OffsetMax = "31.935 0" }
                }, "STPresetSkillPanel", "PresetInfoClose");

                container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = $"stdeletepreset {profileName}" },
                    Text = { Text = lang.GetMessage("UIDelete", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-100 -32", OffsetMax = "-36 0" }
                }, "STPresetSkillPanel", "PresetInfoDelete");
            }

            if (delete)
            {
                container.Add(new CuiElement
                {
                    Name = "DeleteTitle",
                    Parent = "STPresetSkillPanel",
                    Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIAreSure", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-100.004 -32", OffsetMax = "99.916 -0.02" }
                }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = $"stconfirmpresetdelete {profileName}" },
                    Text = { Text = "YES", Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 0.1159904 0 1" },
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-80 -32", OffsetMax = "-16 0" }
                }, "DeleteTitle", "PresetDeleteYes");

                container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = $"stpresetbacktoprestinfo {profileName}" },
                    Text = { Text = "NO", Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "16 -32", OffsetMax = "80 0" }
                }, "DeleteTitle", "PresetDeleteNo");
            }

            CuiHelper.DestroyUi(player, "STPresetSkillPanel");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("stclosepresetuiskill")]
        void CloseSkillPresetMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, "PresetInfoBackground");
            CuiHelper.DestroyUi(player, "STPresetSkillPanel");
        }

        [ConsoleCommand("stpresetbacktoprestinfo")]
        void BackToPresetInfo(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            STPresetSkillPanel(player, string.Join(" ", arg.Args));
        }

        [ConsoleCommand("stdeletepreset")]
        void SendDeletePresetMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            STPresetSkillPanel(player, string.Join(" ", arg.Args), true);
        }

        [ConsoleCommand("stconfirmpresetdelete")]
        void DeletePreset(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData) || playerData.presets == null) return;
            var profileName = string.Join(" ", arg.Args);

            playerData.presets.presets.Remove(profileName);
            CuiHelper.DestroyUi(player, "PresetInfoBackground");
            CuiHelper.DestroyUi(player, "STPresetSkillPanel");
            CuiHelper.DestroyUi(player, "PresetBackpanel");
            CuiHelper.DestroyUi(player, "PresetPanel");
            CuiHelper.DestroyUi(player, "PresetAddSelectBackpanel");
            CuiHelper.DestroyUi(player, "STAddSelectPresetPanel");
            SendMessage(player, $"Removed preset: {profileName}", config.misc_settings.messageSettings.cuiCols.CUISuccess);

            if (playerData.presets.activePreset == profileName) playerData.presets.activePreset = null;
        }

        #endregion

        #endregion

        #region Video handler

        [ConsoleCommand("stplayskilldemo")]
        void PlayVideoCMD(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            var url = arg.Args[0];

            PlayVideo(player, url);
        }

        [ConsoleCommand("stplayskilldemorequiresconfirmation")]
        void PlayVideoRequiresConfirmationCMD(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            var url = arg.Args[0];

            PlayVideoBG(player);
            VideoConfirmation(player, false, url);
        }

        void PlayVideo(BasePlayer player, string url)
        {
            SendMessage(player, lang.GetMessage("LoadingVideoMsg", this, player.UserIDString), config.misc_settings.messageSettings.cuiCols.CUISuccess);
            player.SendConsoleCommand("client.playvideo " + url);
        }

        #region UI Confirmation

        private void PlayVideoBG(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "PlayVideoBG",
                Parent = "Overlay",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0 0 0 1" },
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            CuiHelper.DestroyUi(player, "PlayVideoBG");
            CuiHelper.AddUi(player, container);
        }

        private void VideoConfirmation(BasePlayer player, bool boxChecked, string url)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "VideoConfirmation",
                Parent = "Overlay",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIPlayVideoConfirmationMsg", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-147.784 66.1", OffsetMax = "147.428 166.1" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "0.2264151 0.2168031 0.2168031 1", Command = $"stvideoconfirmation {true} {boxChecked} {url}" },
                Text = { Text = lang.GetMessage("UIYes", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "0 -32", OffsetMax = "64 0" }
            }, "VideoConfirmation", "Yes");

            container.Add(new CuiButton
            {
                Button = { Color = "0.2264151 0.2168031 0.2168031 1", Command = $"stvideoconfirmation {false} {url}" },
                Text = { Text = lang.GetMessage("UINo", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-63.79 -32", OffsetMax = "0.21 0" }
            }, "VideoConfirmation", "No");

            container.Add(new CuiElement
            {
                Name = "CheckBox",
                Parent = "VideoConfirmation",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.1509434 0.1509434 0.1509434 1" },
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "0.39 -56.7", OffsetMax = "16.39 -40.7" }
                }
            });

            var col = boxChecked ? "1 0.804 0 1" : "0.2830189 0.2736739 0.2736739 1";
            container.Add(new CuiElement
            {
                Name = "InnerCheckbox",
                Parent = "CheckBox",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = col },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-6 -6", OffsetMax = "6 6" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = $"stvideocheckboxtoggle {boxChecked} {url}" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" }
            }, "InnerCheckbox", "DontAskAgainButton");

            container.Add(new CuiElement
            {
                Name = "Label_8478",
                Parent = "CheckBox",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIDontAsk", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "20.3 -8", OffsetMax = "120.3 8" }
                }
            });

            CuiHelper.DestroyUi(player, "VideoConfirmation");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("stvideocheckboxtoggle")]
        void CheckboxToggle(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!bool.TryParse(arg.Args[0], out var result)) return;
            VideoConfirmation(player, !result, string.Join(" ", arg.Args.Skip(1)));
        }

        [ConsoleCommand("stvideoconfirmation")]
        void ConfirmSelected(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!bool.TryParse(arg.Args[0], out var result)) return;
            if (result)
            {
                if (bool.TryParse(arg.Args[1], out var stopConfirmation))
                {
                    if (pcdData.pEntity.TryGetValue(player.userID, out var playerData)) playerData.ignoreWarning = stopConfirmation;
                }
                PlayVideo(player, string.Join(" ", arg.Args.Skip(2)));
            }
            CuiHelper.DestroyUi(player, "PlayVideoBG");
            CuiHelper.DestroyUi(player, "VideoConfirmation");
        }

        #endregion

        #endregion


        #region New Menu

        void SendBaseMenu(BasePlayer player, string tree = null, bool sendRespec = true)
        {
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData)) return;            
            var container = new CuiElementContainer();
            if (string.IsNullOrEmpty(tree)) tree = Trees[0];
            if (!TreeData.TryGetValue(player.userID, out var treeData) || !treeData.trees.TryGetValue(tree, out var nodes)) return;
            SendCoreMenu(player, container);
            STSkillScrollPanel(player, tree, container);
            SkillBuffInformation(player, container);
            STNextUnlock(player, container, tree, null);
            SkillCurrentPrestige(player, container, playerData);            
            if (nodes.min_points > 0 || nodes.min_level > 0 || nodes.min_prestige > 0) SkillPointsSpent(player, container, tree, treeData, nodes, playerData);
            if (sendRespec) SkillRespec(player, container, tree, null, playerData);
            CuiHelper.AddUi(player, container);
        }

        private void SendCoreMenu(BasePlayer player, CuiElementContainer container)
        {
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData)) return;
            var tree = Trees[0];
            if (!TreeData.TryGetValue(player.userID, out var treeData)) return;
            if (!treeData.trees.TryGetValue(tree, out var nodes)) return;

            bool send = false;
            if (container == null)
            {
                container = new CuiElementContainer();
                send = true;
            }
            container.Add(new CuiElement
            {
                Name = "SkillTree",
                Parent = "Overlay",
                DestroyUi = "SkillTree",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0 0 0 0.9607843" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-0.006 -0.002", OffsetMax = "0.004 0.008" }
                }
            });

            #region Current level

            container.Add(new CuiElement
            {
                Name = "SkillCurrentLevel",
                Parent = "SkillTree",
                DestroyUi = "SkillCurrentLevel",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-450.04 -143.979", OffsetMax = "-291.36 -120.962" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Text",
                Parent = "SkillCurrentLevel",
                Components = {
                    new CuiTextComponent { Text = $"Current Level: <color=#03b2d9>{playerData.current_level}</color>", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
            });

            #endregion

            #region Current XP

            container.Add(new CuiElement
            {
                Name = "SkillCurrentXP",
                Parent = "SkillTree",
                DestroyUi = "SkillCurrentXP",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-450.04 -166.999", OffsetMax = "-188.51 -143.982" }
                }
            });

            string debt = playerData.xp_debt > 0 ? string.Format(lang.GetMessage("UIDebtText", this, player.UserIDString), $"{Math.Round(playerData.xp_debt, config.xp_settings.xp_rounding)}") : null;
            container.Add(new CuiElement
            {
                Name = "Text",
                Parent = "SkillCurrentXP",
                Components = {
                    new CuiTextComponent { Text = $"{lang.GetMessage("UIXP", this, player.UserIDString)} <color=#03b2d9>{Math.Round(playerData.xp, 2):###,###,##0}</color>/<color=#03b2d9>{Math.Round(config.level.GetLevelStartXP(playerData.current_level + 1), config.xp_settings.xp_rounding):###,###,##0}</color>" + debt, Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
            });

            #endregion            

            #region Settings buttons

            container.Add(new CuiElement
            {
                Name = "SkillTree_player_settings_panel",
                Parent = "SkillTree",
                DestroyUi = "SkillTree_player_settings_panel",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.2358491 0.2358491 0.2358491 0.3176471" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-450.04 -254.67", OffsetMax = "-321.646 -222.67" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "SkillTree_player_settings_text",
                Parent = "SkillTree_player_settings_panel",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIPlayerSettingsButton", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.195 -16", OffsetMax = "64.195 16" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = $"stsendplayersettingsmenu" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.195 -16", OffsetMax = "64.195 16" }
            }, "SkillTree_player_settings_text", "SkillTree_player_settings_button");

            container.Add(new CuiElement
            {
                Name = "SkillTree_ultimate_settings_panel",
                Parent = "SkillTree",
                DestroyUi = "SkillTree_ultimate_settings_panel",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.2358491 0.2358491 0.2358491 0.3176471" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-311.647 -254.67", OffsetMax = "-183.253 -222.67" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "SkillTree_ultimate_settings_text",
                Parent = "SkillTree_ultimate_settings_panel",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIUltimateSettingsButton", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.195 -16", OffsetMax = "64.195 16" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = $"stsendultimatesettingsmenu" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.195 -16", OffsetMax = "64.195 16" }
            }, "SkillTree_ultimate_settings_text", "SkillTree_ultimate_settings_button");

            container.Add(new CuiElement
            {
                Name = "SkillTree_buff_settings_panel",
                Parent = "SkillTree",
                DestroyUi = "SkillTree_buff_settings_panel",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.2358491 0.2358491 0.2358491 0.3176471" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-450.037 -296.67", OffsetMax = "-321.643 -264.67" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "SkillTree_buff_settings_text",
                Parent = "SkillTree_buff_settings_panel",
                Components = {
                    new CuiTextComponent { Text = $"<color=#ffb600>{lang.GetMessage("ButtonBuffSettings", this, player.UserIDString)}</color>", Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.195 -16", OffsetMax = "64.195 16" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = $"stsendbuffsettingsmenu" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.195 -16", OffsetMax = "64.195 16" }
            }, "SkillTree_buff_settings_text", "SkillTree_buff_settings_button");

            #endregion

            #region Presets button

            if (config.misc_settings.presetSettings.enabled)
            {
                container.Add(new CuiElement
                {
                    Name = "SkillTree_presets_panel",
                    Parent = "SkillTree",
                    DestroyUi = "SkillTree_presets_panel",
                    Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.2358491 0.2358491 0.2358491 0.3176471" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-311.647 -295.89", OffsetMax = "-183.253 -263.89" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SkillTree_presets_text",
                    Parent = "SkillTree_presets_panel",
                    Components = {
                    new CuiTextComponent { Text = $"<color=#ffb600>{lang.GetMessage("ButtonPresetSettings", this, player.UserIDString)}</color>", Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.195 -16", OffsetMax = "64.195 16" }
                }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = $"stsendpresetsettingsmenu" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.195 -16", OffsetMax = "64.195 16" }
                }, "SkillTree_presets_text", "SkillTree_presets_button");
            }

            #endregion

            TreeNavButtons(player, 0, container);
            SkillPointsSpent(player, container, tree, treeData, nodes, playerData);
            SkillAvailablePoints(player, container, playerData);
            SkillRespec(player, container, tree, treeData, playerData);

            if (send) CuiHelper.AddUi(player, container);
        }

        #region Tree navigation buttons
        private void TreeNavButtons(BasePlayer player, int treeIndex, CuiElementContainer container)
        {
            bool send = false;
            if (container == null) 
            {
                container = new CuiElementContainer();
                send = true;
            }

            container.Add(new CuiElement
            {
                Name = "TreeNavButtons",
                Parent = "SkillTree",
                DestroyUi = "TreeNavButtons",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-137 -254.67", OffsetMax = "137 -222.67" }
                }
            });

            if (treeIndex > 0)
            {
                container.Add(new CuiElement
                {
                    Name = "SkillTree_Back",
                    Parent = "TreeNavButtons",
                    Components = {
                    new CuiTextComponent { Text = "< <", Font = "robotocondensed-bold.ttf", FontSize = 24, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0 -16", OffsetMax = "58 16" }
                }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = $"stchangetree {treeIndex - 1}" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-29 -16", OffsetMax = "29 16" }
                }, "SkillTree_Back", "SkillTree_back_button");
            }            

            if (treeIndex < Trees.Count - 1)
            {
                container.Add(new CuiElement
                {
                    Name = "SkillTree_forward",
                    Parent = "TreeNavButtons",
                    Components = {
                    new CuiTextComponent { Text = "> >", Font = "robotocondensed-bold.ttf", FontSize = 24, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-58 -16", OffsetMax = "0 16" }
                }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = $"stchangetree {treeIndex + 1}" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-29 -16", OffsetMax = "29 16" }
                }, "SkillTree_forward", "SkillTree_forward_button");
            }           

            container.Add(new CuiElement
            {
                Name = "SkillTree_close",
                Parent = "TreeNavButtons",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIClose", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-29 -16", OffsetMax = "29 16" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = "stmenuclosemain" },
                Text = { Text = " ", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0 0 0 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-29 -16", OffsetMax = "29 16" }
            }, "SkillTree_close", "SkillTree_close_button");


            if (send) CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("stmenuclosemain")]
        void CloseMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            CuiHelper.DestroyUi(player, "SkillTree");
            CuiHelper.DestroyUi(player, "SkillTreeBackPanel");
            CuiHelper.DestroyUi(player, "NavigationMenu");
            CuiHelper.DestroyUi(player, "PrestigeConfirmation");
        }

        [ConsoleCommand("stchangetree")]
        void ChangeTree(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            if (!int.TryParse(arg.Args[0], out var index)) return;

            var tree = Trees[index];
            if (!TreeData.TryGetValue(player.userID, out var treeData) || !treeData.trees.TryGetValue(tree, out var nodes)) return;
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData)) return;

            var container = new CuiElementContainer();
            TreeNavButtons(player, index, container);
            STSkillScrollPanel(player, tree, container);
            SkillPointsSpent(player, container, tree, treeData, nodes, playerData);
            STNextUnlock(player, container, tree, nodes);
            if (nodes.min_points > 0 || nodes.min_level > 0 || nodes.min_prestige > 0) SkillPointsSpent(player, container, tree, treeData, nodes, playerData);
            if (config.general_settings.respecType == RespecType.Tree) SkillRespec(player, container, tree, treeData, playerData);

            CuiHelper.DestroyUi(player, "SkillDescription");
            CuiHelper.DestroyUi(player, "SkillLevelUpPanel");

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Nodes

        string AddScrollElement(CuiElementContainer container, string parent, float height, float width, float horizontalScrollBarWidth, bool vertical, float verticalScrollBarWidth)
        {
            CuiScrollViewComponent scrollComponent = new CuiScrollViewComponent
            {
                MovementType = UnityEngine.UI.ScrollRect.MovementType.Clamped,
                Vertical = vertical,
                Inertia = true,                
                Elasticity = 0,
                DecelerationRate = 0.3f,
                ScrollSensitivity = 24f,
                ContentTransform = new CuiRectTransform { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"{(Math.Max(width - config.misc_settings.uiSettings.nodeSettings.width - config.misc_settings.uiSettings.nodeSettings.NodeSpace, 0)) * -1} {((Math.Max(height - config.misc_settings.uiSettings.nodeSettings.width - config.misc_settings.uiSettings.nodeSettings.NodeSpace, 0))) * -1}", OffsetMax = "0 0" }, // We need to reduce width by 283.58 (panel width) + 30 (spacing). Set it to 0 as a min.
                                                                                                                                                                                                                                                                                                                                                                                    //VerticalScrollbar = scrollBarWidth > 0 ? new CuiScrollbar() { Size = scrollBarWidth, AutoHide = true } : null, // Remove this to remove the scroll bar and just have it scrollable with mwheel
            };
            if (width > config.misc_settings.uiSettings.nodeSettings.width)
            {
                scrollComponent.Horizontal = true; // 283.58 represents the size of the scroll panel that this element is attached to.
                if (horizontalScrollBarWidth > 0) scrollComponent.HorizontalScrollbar = new CuiScrollbar() { Size = horizontalScrollBarWidth, AutoHide = true, Invert = true };
            }
            if (vertical && verticalScrollBarWidth > 0)
            {
                scrollComponent.VerticalScrollbar = new CuiScrollbar() { Size = verticalScrollBarWidth, AutoHide = true };
            }
            container.Add(new CuiElement
            {
                Name = $"{parent}_Scroll_Element",
                Parent = parent,
                Components = {
                    scrollComponent
                }
            });
            var result = $"{parent}_Scroll_Element_Area";

            container.Add(new CuiPanel()
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, $"{parent}_Scroll_Element", result);

            return result;
        }

        private void STSkillScrollPanel(BasePlayer player, string tree, CuiElementContainer container)
        {
            if (!TreeData.TryGetValue(player.userID, out var treeData)) return;
            if (!treeData.trees.TryGetValue(tree, out var nodes)) return;

            bool send = false;
            if (container == null)
            {
                container = new CuiElementContainer();
                send = true;
            }            

            container.Add(new CuiElement
            {
                Name = "STSkillScrollPanel",
                Parent = "SkillTree",
                DestroyUi = "STSkillScrollPanel",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-136 -204", OffsetMax = $"{-136 + config.misc_settings.uiSettings.nodeSettings.width} 117" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "TreeTitle",
                Parent = "STSkillScrollPanel",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage(tree, this, player.UserIDString).ToUpper(), Font = "robotocondensed-bold.ttf", FontSize = 26, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-184.789 73.48", OffsetMax = "175.211 133.48" }
                }
            });

            var lengths = GetRows(nodes);
            AddScrollElement(container, "STSkillScrollPanel", lengths.Item1 * (config.misc_settings.uiSettings.nodeSettings.NodeSize + config.misc_settings.uiSettings.nodeSettings.NodeSpace), lengths.Item2 * (config.misc_settings.uiSettings.nodeSettings.NodeSize + config.misc_settings.uiSettings.nodeSettings.NodeSpace), config.misc_settings.uiSettings.nodeSettings.horizontalScrollBarWidth, lengths.Item1 > 4, config.misc_settings.uiSettings.nodeSettings.verticalScrollBarWidth); 

            SendNodes(player, "STSkillScrollPanel_Scroll_Element_Area", tree, container, nodes, null);

            if (send) CuiHelper.AddUi(player, container);
        }

        (int, int) GetRows(NodesInfo nodes)
        {
            Dictionary<int, int> nodesCount = new Dictionary<int, int>();
            foreach (var node in nodes.nodes)
            {
                if (!nodesCount.ContainsKey(node.Value.tier)) nodesCount.Add(node.Value.tier, 1);
                else nodesCount[node.Value.tier]++;                
            }
            int widest = nodesCount.OrderByDescending(x => x.Value).FirstOrDefault().Value;
            int height = nodesCount.Count;
            nodesCount.Clear();

            return (height, widest);
        }

        Dictionary<int, Dictionary<string, NodeInfo>> GetNodes(BasePlayer player, string tree, NodesInfo nodes)
        {
            var result = new Dictionary<int, Dictionary<string, NodeInfo>>();
            if (nodes == null)
            {
                if (!TreeData.TryGetValue(player.userID, out var treeData)) return result;
                if (!treeData.trees.TryGetValue(tree, out nodes)) return result;
            }

            foreach (var node in nodes.nodes.OrderBy(x => x.Value.tier))
            {
                if (!result.TryGetValue(node.Value.tier, out var data)) result.Add(node.Value.tier, data = new Dictionary<string, NodeInfo>());
                data.Add(node.Key, node.Value);
            }

            return result;
        }

        void SendNodes(BasePlayer player, string parent, string tree, CuiElementContainer container, NodesInfo nodes, PlayerInfo playerData)
        {
            if (playerData == null && !pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;
            if (nodes == null && (!TreeData.TryGetValue(player.userID, out var treeData) || !treeData.trees.TryGetValue(tree, out nodes))) return;

            bool send = false;
            if (container == null)
            {
                container = new CuiElementContainer();
                send = true;
            }

            var nodeRows = GetNodes(player, tree, nodes);

            var count = 0;
            for (int j = 0; j < nodeRows.Count; j++)
            {
                var nodeColumns = nodeRows.ElementAt(j);
                for (int i = 0; i < nodeColumns.Value.Count; i++)
                {
                    var node = nodeColumns.Value.ElementAt(i);

                    container.Add(new CuiElement
                    {
                        Name = $"SkillTree_node_{count}",
                        Parent = parent,
                        DestroyUi = $"SkillTree_node_{count}",
                        Components =
                        {
                            new CuiNeedsCursorComponent(),
                            new CuiImageComponent{ Color = node.Value.tier == UltimateLevel ? config.ultimate_settings.ultimate_node_background_col : "0.1698113 0.1698113 0.1698113 1" },
                            new CuiRectTransformComponent{ AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{1 + (i * (config.misc_settings.uiSettings.nodeSettings.NodeSize + config.misc_settings.uiSettings.nodeSettings.NodeSpace))} {(-config.misc_settings.uiSettings.nodeSettings.NodeSize - 1) - (j * (config.misc_settings.uiSettings.nodeSettings.NodeSize + config.misc_settings.uiSettings.nodeSettings.NodeSpace))}", OffsetMax = $"{(config.misc_settings.uiSettings.nodeSettings.NodeSize + 1) + (i * (config.misc_settings.uiSettings.nodeSettings.NodeSize + config.misc_settings.uiSettings.nodeSettings.NodeSpace))} {-2 - (j * (config.misc_settings.uiSettings.nodeSettings.NodeSize + config.misc_settings.uiSettings.nodeSettings.NodeSpace))}" }
                        }
                    });

                    if (!NodeIconDirectory.TryGetValue(node.Key, out var iconData)) iconData = new IconInfo(null, 0);

                    container.Add(new CuiElement
                    {
                        Name = "Img",
                        Parent = $"SkillTree_node_{count}",
                        Components = {
                            iconData.iconID > 0 ?
                            new CuiImageComponent {Color = "1 1 1 1", ItemId = 1751045826, SkinId = iconData.iconID} :
                            !string.IsNullOrEmpty(iconData.url) && ImageLibrary != null && ImageLibrary.IsLoaded ?
                            new CuiRawImageComponent { Color = "1 1 1 1", Png = (string)ImageLibrary?.Call("GetImage", node.Key) } :
                            new CuiImageComponent {Color = "1 1 1 1", Sprite = "assets/icons/clear.png"},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "2 2", OffsetMax = "-2 -2" }
                    }
                    });
                    var errorText = NodeUnlocked(player, node.Value, playerData);
                    
                    if (!string.IsNullOrEmpty(errorText) || (nodes.point_requirements.TryGetValue(node.Value.tier, out var reqPoints) && nodes.points_spent < reqPoints))
                    {
                        container.Add(new CuiElement
                        {
                            Name = $"SkillTree_Grey_Box_{count}",
                            Parent = $"SkillTree_node_{count}",
                            Components =
                            {
                                new CuiNeedsCursorComponent(),
                                new CuiImageComponent{ Color = "0.3584906 0.3584906 0.3584906 0.8823529" },
                                new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "2 2", OffsetMax = "-2 -2" }
                            }
                        });
                        if (!string.IsNullOrEmpty(errorText))
                        {
                            container.Add(new CuiElement
                            {
                                Name = "SkillTree_SkillTree_Grey_Box_text",
                                Parent = $"SkillTree_Grey_Box_{count}",
                                Components = {
                                new CuiTextComponent { Text = errorText, Font = "robotocondensed-bold.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                                new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1"}
                            }
                            });
                        }                        
                    }                    

                    container.Add(new CuiElement
                    {
                        Name = "Points",
                        Parent = $"SkillTree_node_{count}",
                        Components = {
                        new CuiTextComponent { Text = node.Value.level_current.ToString(), Font = "robotocondensed-regular.ttf", FontSize = 20, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                        new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "2 2", OffsetMax = "29 29" }
                    }
                    });

                    container.Add(new CuiButton
                    {
                        Button = { Color = "1 1 1 0", Command = $"stsendnodedescription {tree.Replace(' ', '_')} {node.Key.Replace(' ', '_')} {parent} {tree.Contains('_')} {node.Key.Contains('_')}" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "2 2", OffsetMax = "-2 -2" }
                    }, $"SkillTree_node_{count}", "Button");

                    count++;
                }
            }
            nodeRows.Clear();
            if (send) CuiHelper.AddUi(player, container);
        }

        string NodeUnlocked(BasePlayer player, NodeInfo node, PlayerInfo playerData)
        {
            if (node.min_prestige > 0 && playerData.prestige_level < node.min_prestige) return string.Format(lang.GetMessage("UIReqPresLvl", this, player.UserIDString), node.min_prestige);
            if (!string.IsNullOrEmpty(node.required_skill) && (!playerData.buff_values.TryGetValue(node.required_skill, out var skillLevel) || skillLevel < GetNodeMaxLevel(node.required_skill))) return lang.GetMessage("UINodeLocked", this, player.UserIDString);
            if (!string.IsNullOrEmpty(node.excluded_skill) && playerData.buff_values.ContainsKey(node.excluded_skill)) return lang.GetMessage("UINodeLocked", this, player.UserIDString);
            if (node.min_level > 0 && playerData.current_level < node.min_level) return string.Format(lang.GetMessage("UIReqPlayerLvl", this, player.UserIDString), node.min_level);
            if (!string.IsNullOrEmpty(node.permission_required) && !permission.UserHasPermission(player.UserIDString, node.permission_required)) return string.Format(lang.GetMessage("UIReqPermission", this, player.UserIDString), node.permission_required);
            if (node.exclusions.Count > 0)
            {
                foreach (var kvp in playerData.buff_values.Keys)
                    if (node.exclusions.Contains(kvp))
                        return lang.GetMessage("UINodeLocked", this, player.UserIDString);
            }

            return null;
        }

        [ConsoleCommand("stsendnodedescription")]
        void SendNodeDescription(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData)) return;
            if (!bool.TryParse(arg.Args[3], out var treeFormatted)) return;
            if (!bool.TryParse(arg.Args[4], out var nodeFormatted)) return;
            var tree = treeFormatted ? arg.Args[0] : arg.Args[0].Replace('_', ' ');
            var nodeName = nodeFormatted ? arg.Args[1] : arg.Args[1].Replace('_', ' ');
            var parent = arg.Args[2];

            var container = new CuiElementContainer();
            SkillDescription(player, container, tree, playerData, nodeName, null);
            SkillLevelUpPanel(player, container, tree, nodeName, null, parent);
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Points spent

        private void SkillPointsSpent(BasePlayer player, CuiElementContainer container, string tree, TreeInfo treeData, NodesInfo nodes, PlayerInfo playerData)
        {
            if (treeData == null && !TreeData.TryGetValue(player.userID, out treeData)) return;
            if (nodes == null && !treeData.trees.TryGetValue(tree, out nodes)) return;
            if (playerData == null && !pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;

            bool send = false;
            if (container == null)
            {
                container = new CuiElementContainer();
                send = true;
            }

            var requirementsCount = 0;
            if (nodes.min_points > 0) requirementsCount++;
            if (nodes.min_prestige > 0) requirementsCount++;
            if (nodes.min_level > 0) requirementsCount++;

            container.Add(new CuiElement
            {
                Name = "SkillPointsSpent",
                Parent = "SkillTree",
                DestroyUi = "SkillPointsSpent",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-137.001 {139.8 + (requirementsCount * 13)}", OffsetMax = $"146.579 {159.8 + (requirementsCount * 13)}" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "TreePoints",
                Parent = "SkillPointsSpent",
                Components = {
                    new CuiTextComponent { Text = $"{lang.GetMessage("UITreePointsSpent", this, player.UserIDString)} <color=#42f105>{nodes.points_spent}</color>", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "-0.004 -10", OffsetMax = "141.784 10" }
                }
            });

            var maxSkillPoints = GetMaxSkillPoints(player);
            var tps = maxSkillPoints > 0 ? $"{lang.GetMessage("UITotalPointsSpent", this, player.UserIDString)} <color=#42f105>{treeData.total_points_spent}/{maxSkillPoints}</color>" : $"{lang.GetMessage("UITotalPointsSpent", this, player.UserIDString)} <color=#42f105>{treeData.total_points_spent}</color>";

            container.Add(new CuiElement
            {
                Name = "TotalPoints",
                Parent = "SkillPointsSpent",
                Components = {
                    new CuiTextComponent { Text = tps, Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-141.786 -10", OffsetMax = "0.004 10" }
                }
            });

            if (requirementsCount > 0)
            {
                var count = 0;
                if (nodes.min_points > 0)
                {
                    var minPoints = GetPointRequirement(player, tree, nodes.min_points);
                    var totalPoints = treeData.trees.Sum(x => x.Value.points_spent);

                    container.Add(new CuiElement
                    {
                        Name = "TreeRequirementWarning",
                        Parent = "SkillPointsSpent",
                        Components = {
                        new CuiTextComponent { Text = $"{(totalPoints >= minPoints ? lang.GetMessage("MinLevelColHasLevel", this, player.UserIDString) : lang.GetMessage("MinLevelColUnderLevel", this, player.UserIDString))}{string.Format(lang.GetMessage("MinPointString", this, player.UserIDString), minPoints)}", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                        new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-141.786 -13", OffsetMax = "141.794 0" }
                    }
                    });
                    count++;
                }
                if (nodes.min_level > 0)
                {                    
                    container.Add(new CuiElement
                    {
                        Name = "TreeRequirementWarning",
                        Parent = "SkillPointsSpent",
                        Components = {
                        new CuiTextComponent { Text = $"{(playerData.achieved_level >= nodes.min_level ? lang.GetMessage("MinLevelColHasLevel", this, player.UserIDString) : lang.GetMessage("MinLevelColUnderLevel", this, player.UserIDString))}{string.Format(lang.GetMessage("MinPlayerLevelString", this, player.UserIDString), nodes.min_level)}", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                        new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = $"-141.794 {-13 - (count * 13)}", OffsetMax = $"141.786 {0 - (count * 13)}" }
                    }
                    });
                    count++;
                }
                if (nodes.min_prestige > 0)
                {
                    container.Add(new CuiElement
                    {
                        Name = "TreeRequirementWarning",
                        Parent = "SkillPointsSpent",
                        Components = {
                        new CuiTextComponent { Text = $"{(playerData.prestige_level >= nodes.min_prestige ? lang.GetMessage("MinLevelColHasLevel", this, player.UserIDString) : lang.GetMessage("MinLevelColUnderLevel", this, player.UserIDString))}{string.Format(lang.GetMessage("MinPrestigeString", this, player.UserIDString), nodes.min_prestige)}", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                        new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = $"-141.794 {-13 - (count * 13)}", OffsetMax = $"141.786 {0 - (count * 13)}" }
                    }
                    });
                }
            }           

            if (send) CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Available points

        private void SkillAvailablePoints(BasePlayer player, CuiElementContainer container, PlayerInfo playerData)
        {
            if (playerData == null && !pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;

            bool send = false;
            if (container == null)
            {
                container = new CuiElementContainer();
                send = true;
            }
            
            container.Add(new CuiElement
            {
                Name = "SkillAvailablePoints",
                Parent = "SkillTree",
                DestroyUi = "SkillAvailablePoints",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-450.04 -190.02", OffsetMax = "-284.04 -166.999" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Text",
                Parent = "SkillAvailablePoints",
                Components = {
                    new CuiTextComponent { Text = $"{lang.GetMessage("UIAvailablePoints", this, player.UserIDString)} <color=#42f105>{playerData.available_points}</color>", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
            });

            if (send) CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Prestige level

        private void SkillCurrentPrestige(BasePlayer player, CuiElementContainer container, PlayerInfo playerData)
        {
            if (!config.prestige_settings.enabled) return;
            if (playerData == null && !pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;
            bool send = false;
            if (container == null)
            {
                container = new CuiElementContainer();
                send = true;
            }
            container.Add(new CuiElement
            {
                Name = "SkillCurrentPrestige",
                Parent = "SkillTree",
                DestroyUi = "SkillCurrentPrestige",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-450.04 -213.038", OffsetMax = "-339.57 -190.021" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Text",
                Parent = "SkillCurrentPrestige",
                Components = {
                    new CuiTextComponent { Text = $"{lang.GetMessage("UIPrestigeLevel", this, player.UserIDString)} <color=#42f105>{playerData.prestige_level}</color>", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
            });

            if (config.prestige_settings.levels.TryGetValue(playerData.prestige_level, out var presData) && presData.RankUpPic != 0)
            {
                container.Add(new CuiElement
                {
                    Name = "Img",
                    Parent = "SkillCurrentPrestige",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 1", ItemId = 1776460938, SkinId = presData.RankUpPic },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "-28 -12", OffsetMax = "-4 12" }
                }
                });
            }

            if (config.prestige_settings.show_button_before_level || playerData.current_level >= config.general_settings.max_player_level)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = "0.2352941 0.2352941 0.2352941 0.3176471", Command = $"stincreaseprestigepage {playerData.prestige_level + 1} {playerData.current_level >= config.general_settings.max_player_level}" },
                    Text = { Text = playerData.current_level >= config.general_settings.max_player_level ? lang.GetMessage("UIPrestigeUpButtonHasLevel", this, player.UserIDString) : lang.GetMessage("UIPrestigeUpButton", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0 0 0 1" },
                    RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "27.924 -11.509", OffsetMax = "98.487 11.509" }
                }, "SkillCurrentPrestige", "GainPrestigeButton");
            }

            if (send) CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Respec button

        private void SkillRespec(BasePlayer player, CuiElementContainer container, string tree, TreeInfo treeData, PlayerInfo playerData)
        {
            bool send = false;
            if (container == null)
            {
                container = new CuiElementContainer();
                send = true;
            }

            if (treeData == null && !TreeData.TryGetValue(player.userID, out treeData)) return;

            var totalSpent = 0;
            foreach (var _tree in treeData.trees)
                totalSpent += _tree.Value.points_spent;

            var cost = (double)0;
            string formatted;
            var respec_cost = GetRespecCost(player);
            if (respec_cost > 0) cost = Math.Round(config.general_settings.respecType == RespecType.All ? totalSpent * respec_cost : GetPointsToRespec(player, playerData, tree) * respec_cost, 2);
            if (config.general_settings.respec_cost_cap > 0 && cost > config.general_settings.respec_cost_cap) cost = config.general_settings.respec_cost_cap;
            if (config.general_settings.respec_currency.Equals("scrap", StringComparison.OrdinalIgnoreCase)) formatted = $"{cost} {lang.GetMessage("UIScrap", this, player.UserIDString)}";
            else if (config.general_settings.respec_currency.Equals("economics", StringComparison.OrdinalIgnoreCase)) formatted = $"{lang.GetMessage("UIDollars", this, player.UserIDString)}{cost}";
            else if (config.general_settings.respec_currency.Equals("srp", StringComparison.OrdinalIgnoreCase)) formatted = $"{cost} {lang.GetMessage("UIPoints", this, player.UserIDString)}";
            else if (config.general_settings.respec_currency.Equals("shoppystock", StringComparison.OrdinalIgnoreCase)) formatted = $"{cost} {lang.GetMessage("UIShoppyStock", this, player.UserIDString)}";
            else if (config.general_settings.respec_currency.Equals("custom", StringComparison.OrdinalIgnoreCase)) formatted = $"{cost} {config.general_settings.respec_currency_custom.displayName}";
            else formatted = cost.ToString();

            container.Add(new CuiElement
            {
                Name = "SkillRespec",
                Parent = "SkillTree",
                DestroyUi = "SkillRespec",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-450.04 -81.6", OffsetMax = "-233.36 -49.6" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "SkillTree_Respec_cost_title",
                Parent = "SkillRespec",
                Components = {
                    new CuiTextComponent { Text = string.Format(lang.GetMessage("RespecCost", this, player.UserIDString), formatted), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "-0.34 -16", OffsetMax = "158.34 16" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "SkillTree_RespecCost",
                Parent = "SkillRespec",
                DestroyUi = "SkillTree_RespecCost",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.2352941 0.2352941 0.2352941 0.3176471" },
                    new CuiRectTransformComponent{ AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-58 -16", OffsetMax = "0 16" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "SkillTree_Respec_cost_label",
                Parent = "SkillTree_RespecCost",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("RespecButton", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = $"respecconfirmation {cost} {tree}" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" }
            }, "SkillTree_RespecCost", "SkillTree_Respec_cost_button");


            if (send) CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("dorespec")]
        void DoRespec(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, "respec_confirmation");
            if (!double.TryParse(arg.Args[0], out var cost)) return;

            if (!PaidForRespec(player, cost)) return;

            var tree = arg.Args[1];
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData)) return;
            if (config.general_settings.respec_multiplier > 0)
            {
                playerData.respec_multiplier += config.general_settings.respec_multiplier;
                if (config.general_settings.respec_multiplier_max > 0 && playerData.respec_multiplier > config.general_settings.respec_multiplier_max) playerData.respec_multiplier = config.general_settings.respec_multiplier_max;
            }

            if (config.general_settings.respecType == RespecType.All) RespecPlayer(player);
            else RespecTree(player, tree);

            if (!TreeData.TryGetValue(player.userID, out var treeData)) return;
            if (!treeData.trees.TryGetValue(tree, out var nodes)) return;

            var container = new CuiElementContainer();
            SkillRespec(player, container, tree, treeData, playerData);
            SkillAvailablePoints(player, container, playerData);
            SkillPointsSpent(player, container, tree, treeData, nodes, playerData);
            STSkillScrollPanel(player, tree, container);
            SkillBuffInformation(player, container);
            STNextUnlock(player, container, tree, nodes);
            CuiHelper.DestroyUi(player, "SkillDescription");
            CuiHelper.DestroyUi(player, "SkillLevelUpPanel");
            CuiHelper.AddUi(player, container);

            SendPlayerMessage(player, config.general_settings.respecType == RespecType.All ? string.Format(lang.GetMessage("PaidRespec", this, player.UserIDString), cost) : string.Format(lang.GetMessage("RespecTree", this, player.UserIDString), cost, lang.GetMessage(tree, this, player.UserIDString)), config.misc_settings.messageSettings.Respec);
        }

        #endregion

        #region Skill description

        private void SkillDescription(BasePlayer player, CuiElementContainer container, string tree, PlayerInfo playerData, string nodeName, NodeInfo node)
        {
            if (playerData == null && !pcdData.pEntity.TryGetValue(player.userID, out playerData)) return;
            if (node == null && (!TreeData.TryGetValue(player.userID, out var treeData) || !treeData.trees.TryGetValue(tree, out var nodes) || !nodes.nodes.TryGetValue(nodeName, out node))) return;

            bool send = false;
            if (container == null)
            {
                container = new CuiElementContainer();
                send = true;
            }

            string nodeDescription = node.description;

            if (config.trees[tree].nodes[nodeName].permissions != null)
            {
                nodeDescription += lang.GetMessage(nodeName + ".permission", this, player.UserIDString);
            }

            nodeDescription += AddAdditionalDescription(node.buffInfo.Key, player.UserIDString);
            if (!string.IsNullOrEmpty(node.excluded_skill)) nodeDescription += string.Format(lang.GetMessage("UIExcludeDescription", this, player.UserIDString), node.excluded_skill);
            if (!string.IsNullOrEmpty(node.required_skill)) nodeDescription += string.Format(lang.GetMessage("UIRequiredDescription", this, player.UserIDString), node.required_skill);

            container.Add(new CuiElement
            {
                Name = "SkillDescription",
                Parent = "SkillTree",
                DestroyUi = "SkillDescription",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-450.04 0", OffsetMax = "-233.36 159.8" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Title",
                Parent = "SkillDescription",
                Components = {
                    new CuiTextComponent { Text = string.Format(lang.GetMessage("UISelectedNode", this, player.UserIDString), lang.GetMessage(nodeName, this, player.UserIDString)), Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-108.34 -32.2", OffsetMax = "108.34 -0.2" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Description",
                Parent = "SkillDescription",
                Components = {
                    new CuiTextComponent { Text = nodeDescription, Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-108.337 -159.9", OffsetMax = "108.337 -54.6" }
                }
            });

            if (config.misc_settings.enable_videos && config.misc_settings.videoURLs.TryGetValue(node.buffInfo.Key, out var url) && !string.IsNullOrEmpty(url))
            {
                container.Add(new CuiElement
                {
                    Name = "DemoImg",
                    Parent = "SkillDescription",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 1", ItemId = 1776460938, SkinId = 3417318875 },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "-43.597 -8.1", OffsetMax = "-11.597 23.9" }
                }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = playerData.ignoreWarning ? $"stplayskilldemo {url}" : $"stplayskilldemorequiresconfirmation {url}" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" }
                }, "DemoImg", "PlayDemoButton");
            }

            if (send) CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Level up

        private void SkillLevelUpPanel(BasePlayer player, CuiElementContainer container, string tree, string nodeName, NodeInfo node, string parent)
        {
            if (node == null && (!TreeData.TryGetValue(player.userID, out var treeData) || !treeData.trees.TryGetValue(tree, out var nodes) || !nodes.nodes.TryGetValue(nodeName, out node))) return;            

            bool send = false;
            if (container == null)
            {
                container = new CuiElementContainer();
                send = true;
            }
            
            container.Add(new CuiElement
            {
                Name = "SkillLevelUpPanel",
                Parent = "SkillTree",
                DestroyUi = "SkillLevelUpPanel",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-450.04 -33.491", OffsetMax = "-233.36 -1.491" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "SkillTree_node_max_level",
                Parent = "SkillLevelUpPanel",
                Components = {
                    new CuiTextComponent { Text = string.Format(lang.GetMessage("UIMaxLevel", this, player.UserIDString), node.level_max), Font = "robotocondensed-regular.ttf", FontSize = 15, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-108.341 -16", OffsetMax = "108.339 16" }
                }
            });

            if (node.level_current < node.level_max)
            {
                container.Add(new CuiElement
                {
                    Name = "SkillTree_LevelUp",
                    Parent = "SkillLevelUpPanel",
                    DestroyUi = "SkillTree_LevelUp",
                    Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "0.2352941 0.2352941 0.2352941 0.3176471" },
                    new CuiRectTransformComponent{ AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-57.32 -16", OffsetMax = "0.68 16" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "Title",
                    Parent = "SkillTree_LevelUp",
                    Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UILevelUpButton", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0.32 0", OffsetMax = "0 0" }
                }
                });

                container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = $"sthandlelevelup {nodeName.Replace(' ', '_')} {parent} {tree.Replace(' ', '_')} {nodeName.Contains('_')} {tree.Contains('_')}" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0.32 0", OffsetMax = "0 0" }
                }, "SkillTree_LevelUp", "Button");
            }           

            if (send) CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("sthandlelevelup")]
        void LevelUpButton(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (!bool.TryParse(arg.Args[3], out var nodeFormatted)) return;
            if (!bool.TryParse(arg.Args[4], out var treeFormatted)) return;
            var nodeName = nodeFormatted ? arg.Args[0] : arg.Args[0].Replace('_', ' ');
            var parent = arg.Args[1];
            var tree = treeFormatted ? arg.Args[2] : arg.Args[2].Replace('_', ' ');
            
            if (!pcdData.pEntity.TryGetValue(player.userID, out var playerData)) return;
            if (!TreeData.TryGetValue(player.userID, out var treeData) || !treeData.trees.TryGetValue(tree, out var nodes)) return;
            if (!nodes.nodes.TryGetValue(nodeName, out var node)) return;
            if (!LevelUpNode(player, tree, nodeName)) return;            

            var container = new CuiElementContainer();
            SendNodes(player, parent, tree, container, nodes, playerData);
            SkillAvailablePoints(player, container, playerData);
            SkillPointsSpent(player, container, tree, treeData, nodes, playerData);
            STNextUnlock(player, container, tree, nodes);
            SkillBuffInformation(player, container);
            SkillRespec(player, container, tree, treeData, playerData);
            if (node.level_current >= node.level_max)
                SkillLevelUpPanel(player, container, tree, nodeName, node, parent);
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Next unlock

        int FindClosestStrictlyGreaterValue(Dictionary<int, int> dict, int target)
        {
            if (dict == null || dict.Count == 0)
                throw new ArgumentException("Dictionary is empty.");

            int? closest = null;

            foreach (var value in dict.Values)
            {
                if (value > target)
                {
                    if (closest == null || value < closest)
                        closest = value;
                }
            }

            return closest ?? -1;
        }

        private void STNextUnlock(BasePlayer player, CuiElementContainer container, string tree, NodesInfo nodes)
        {
            if (nodes == null && (!TreeData.TryGetValue(player.userID, out var treeData) || !treeData.trees.TryGetValue(tree, out nodes))) return;
            int nextUnlock = FindClosestStrictlyGreaterValue(nodes.point_requirements, nodes.points_spent) - nodes.points_spent;
            if (nextUnlock <= 0)
            {
                CuiHelper.DestroyUi(player, "STNextUnlock");
                return;
            }
            bool send = false;
            if (container == null)
            {
                container = new CuiElementContainer();
                send = true;
            }
            container.Add(new CuiElement
            {
                Name = "STNextUnlock",
                Parent = "SkillTree",
                DestroyUi = "STNextUnlock",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-225.172 52.86", OffsetMax = "-144.628 117" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Text",
                Parent = "STNextUnlock",
                Components = {
                    new CuiTextComponent { Text = string.Format(lang.GetMessage("UINextRowUnlocks", this, player.UserIDString), nextUnlock), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "-5.59 0" }
                }
            });


            if (send) CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Buff information

        private void SkillBuffInformation(BasePlayer player, CuiElementContainer container)
        {
            if (!GetBuffDetails(player.userID, out var buffData, true)) return;
            bool send = false;
            if (container == null)
            {
                container = new CuiElementContainer();
                send = true;
            }

            float startx = -136 + config.misc_settings.uiSettings.nodeSettings.width + 50;
            container.Add(new CuiElement
            {
                Name = "SkillBuffInformation",
                Parent = "SkillTree",
                DestroyUi = "SkillBuffInformation",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{startx} -295.89", OffsetMax = $"{startx + 166} 159.8" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Title",
                Parent = "SkillBuffInformation",
                Components = {
                    new CuiTextComponent { Text = lang.GetMessage("UIBuffInformation", this, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-83 -32.155", OffsetMax = "83 -0.155" }
                }
            });

            Dictionary<string, string> Buffs = new Dictionary<string, string>();
            foreach (var buff in buffData.GetBuffs())
            {
                if (buff.Value.value == 0) continue;
                if (!BuffBuffType.TryGetValue(buff.Key, out var buffType)) continue;
                if (buffType == BuffType.Permission) continue;
                string value;
                switch (buffType)
                {
                    case BuffType.Percentage: value = string.Format(lang.GetMessage("BuffType.Percentage", this, player.UserIDString), Math.Round(buff.Value.value / 1 * 100, 2)); break;
                    case BuffType.Seconds: value = string.Format(lang.GetMessage("BuffType.Seconds", this, player.UserIDString), buff.Value.value); break;
                    case BuffType.PerSecond: value = string.Format(lang.GetMessage("BuffType.PerSecond", this, player.UserIDString), buff.Value.value); break;
                    case BuffType.Slots: value = string.Format(lang.GetMessage("BuffType.Slots", this, player.UserIDString), buff.Value.value); break;
                    case BuffType.Level: value = string.Format(lang.GetMessage("BuffType.Level", this, player.UserIDString), Mathf.RoundToInt(buff.Value.value)); break;
                    case BuffType.Distance: value = string.Format(lang.GetMessage("BuffType.Distance", this, player.UserIDString), Mathf.RoundToInt(buff.Value.value)); break;
                    default: value = lang.GetMessage("UIEnabled", this, player.UserIDString); break;
                }
                if (buffData.temp_buff_values.TryGetValue(buff.Key, out var tempData))
                {
                    string value2;
                    switch (buffType)
                    {
                        case BuffType.Percentage: value2 = string.Format(lang.GetMessage("BuffType.Percentage", this, player.UserIDString), Math.Round(tempData.buffInfo.value / 1 * 100, 2)); break;
                        case BuffType.Seconds: value2 = string.Format(lang.GetMessage("BuffType.Seconds", this, player.UserIDString), tempData.buffInfo.value); break;
                        case BuffType.PerSecond: value2 = string.Format(lang.GetMessage("BuffType.PerSecond", this, player.UserIDString), tempData.buffInfo.value); break;
                        case BuffType.Slots: value2 = string.Format(lang.GetMessage("BuffType.Slots", this, player.UserIDString), tempData.buffInfo.value); break;
                        case BuffType.Level: value2 = string.Format(lang.GetMessage("BuffType.Level", this, player.UserIDString), Mathf.RoundToInt(tempData.buffInfo.value)); break;
                        case BuffType.Distance: value2 = string.Format(lang.GetMessage("BuffType.Distance", this, player.UserIDString), Mathf.RoundToInt(tempData.buffInfo.value)); break;
                        default: value2 = lang.GetMessage("UIEnabled", this, player.UserIDString); break;
                    }
                    //BuffUIFormatWithTempBuff
                    Buffs.Add(buff.Key.ToString(), string.Format(lang.GetMessage("BuffUIFormatWithTempBuff", this, player.UserIDString), lang.GetMessage("UI" + buff.Key.ToString(), this, player.UserIDString), value, value2));
                }
                else Buffs.Add(buff.Key.ToString(), string.Format(lang.GetMessage("BuffUIFormat", this, player.UserIDString), lang.GetMessage("UI" + buff.Key.ToString(), this, player.UserIDString), value));
            }

            foreach (var buff in buffData.temp_buff_values)
            {
                var key = buff.Key.ToString();
                if (Buffs.ContainsKey(key)) continue;
                if (!BuffBuffType.TryGetValue(buff.Key, out var buffType)) continue;
                string value3;
                switch (buffType)
                {
                    case BuffType.Percentage: value3 = string.Format(lang.GetMessage("BuffType.Percentage", this, player.UserIDString), Math.Round(buff.Value.buffInfo.value / 1 * 100, 2)); break;
                    case BuffType.Seconds: value3 = string.Format(lang.GetMessage("BuffType.Seconds", this, player.UserIDString), buff.Value.buffInfo.value); break;
                    case BuffType.PerSecond: value3 = string.Format(lang.GetMessage("BuffType.PerSecond", this, player.UserIDString), buff.Value.buffInfo.value); break;
                    case BuffType.Slots: value3 = string.Format(lang.GetMessage("BuffType.Slots", this, player.UserIDString), buff.Value.buffInfo.value); break;
                    case BuffType.Level: value3 = string.Format(lang.GetMessage("BuffType.Level", this, player.UserIDString), Mathf.RoundToInt(buff.Value.buffInfo.value)); break;
                    case BuffType.Distance: value3 = string.Format(lang.GetMessage("BuffType.Distance", this, player.UserIDString), Mathf.RoundToInt(buff.Value.buffInfo.value)); break;
                    default: value3 = lang.GetMessage("UIEnabled", this, player.UserIDString); break;
                }
                Buffs.Add(key, string.Format(lang.GetMessage("BuffUIFormatOnlyTempBuff", this, player.UserIDString), lang.GetMessage("UI" + buff.Key.ToString(), this, player.UserIDString), value3));
            }
            Dictionary<string, string> perms = new Dictionary<string, string>();
            if (Tracked_perms.ContainsKey(player.UserIDString))
            {
                foreach (var list in Tracked_perms[player.UserIDString])
                {
                    foreach (var entry in list.Value)
                    {
                        if (!perms.ContainsKey(entry.Key))
                        {
                            perms.Add(entry.Key, entry.Value);
                        }
                    }
                }
            }

            foreach (var perm in perms)
            {
                Buffs.Add(perm.Key, string.Format(lang.GetMessage("PermUIFormat", this, player.UserIDString), perm.Value ?? perm.Key));
            }

            container.Add(new CuiElement
            {
                Name = "BuffList",
                Parent = "SkillBuffInformation",
                DestroyUi = "BuffList",
                Components =
                {
                    new CuiNeedsCursorComponent(),
                    new CuiImageComponent{ Color = "1 1 1 0" },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-83 -456", OffsetMax = "83 -43.11" }
                }
            });

            var parent = AddScrollElement(container, "BuffList", Buffs.Count * 10f, 0, 0, true, config.misc_settings.uiSettings.buffInfoSettings.verticalScrollBarWidth);

            var count = 0;
            foreach (var buff in Buffs)
            {
                container.Add(new CuiElement
                {
                    Name = "Text",
                    Parent = parent,
                    Components = {
                    new CuiTextComponent { Text = buff.Value, Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-83 {-10 - (count * 10)}", OffsetMax = $"83 {0 - (count * 10)}" }
                }
                });

                count++;
            }

            Buffs.Clear();
            if (send) CuiHelper.AddUi(player, container);
        }

        #endregion

        #endregion
    }
} 